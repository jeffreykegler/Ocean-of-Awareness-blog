How to parse HTML, part 2
<p>
This is the second of a series of posts that details
a Marpa-based, "Ruby Slippers"
approach to parsing liberal
and defective HTML.
This post assumes you have 
read
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/how-to-parse-html.html">
the first post</a>.
</p>
<h2>First, reduce the HTML to a token stream</h2>
<p>
Most computer languages can be viewed
as a token stream.
HTML is not an exception.
HTML tokens can be blocks of text;
comments and various other SGML entities;
HTML element start tags;
and HTML element end tags.
The HTML token stream is unusual in that
some of its tokens can
be quite complex internally.
</p>
In parsing computer languages,
it is a frequent practice to divide the
work between a tokenizer ("lexer")
and a <a href="#HIGH-LEVEL">high-level parser</a>.
The lexer takes the raw input
and turns it into a token stream.
Tokenizing HTML is a difficult job,
and one for which there is an excellent CPAN module:
<a href="https://metacpan.org/module/HTML::Parser">HTML::Parser</a>.
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>

relies on
<a href="https://metacpan.org/module/HTML::Parser">HTML::Parser</a>
to do its tokenization.
<p>
</p>
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
determines the large scale structure of the HTML document --
what I will call in this post, "high-level" parsing.
The result of high-level parsing can be
seen as a hierarchical structure.
The goal of high-level parsing is
to build a hierarchy which reflects
the structure of the document.
Conventionally, this hierarchy is visualized
as an upside-down tree,
one where the "leaves" are the tokens,
and where the "root" node represents the
document as a whole.
