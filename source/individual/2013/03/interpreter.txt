The Interpreter Design Pattern
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <p>The very influential
      <a href="http://en.wikipedia.org/wiki/Design_Patterns">
      <em>Design Patterns</em> book</a>
      lays out 23 patterns for programming.
      One of them, the Interpreter Pattern, is rarely used.
      Steve Yegge puts it a bit more strikingly -- he says
      that the book  contain 22 patterns and a practical joke.
      </p>
      <p>
      But elsewhere Yegge says that of the 23, the Interpreter pattern is
      the only one likely to shrink the size of your code,
      all the others tend to increase the amount of code it takes to solve
      the problem.
      Less code is a good thing when you're dealing with a few pages.
      If you're talking about lines of code in the 100's of thousands,
      or the millions,
      it seems more like a matter of survival.
      </p>
      <p>
      High praise as this is for the Interpreter Pattern,
      others speak even highly of it.
      A language can include all, and only, the concepts relevent
      to your domain.
      A language can allow you to relate them in all, and only, the appropriate ways.
      A language can identify errors with pinpoint precision,
      hide implementation details,
      and allow invisible "drop-in" enhancements.
      </p>
      <p>
      A language can go wrong, and in present practice, a lot do.
      Many more simply don't get off the ground.
      But because languages are so powerful and flexible,
      their use is in fact pretty much universal.
      The choice is not whether or not to use a language to solve
      the problem,
      but whether to use
      a general-purpose language,
      and a domain-specific language.
      That is, if you decide not to use a language specifically fitted
      to your domain,
      usually it means that you
      are choosing to use one that is not.
      </p>
      <p>
      Why then, is the Interpreter Pattern so little used?
      Why does Yegge call it a practical joke?
      </p>
      <h3>But there's a problem</h3>
      <p>The problem with the Interpreter Pattern is that you must
      turn your language into an AST -- you must parse it somehow.
      Simplifying the language can help here,
      but if the point is to simple at the expense of power
      and flexibility,
      why not just stick with the other 22 patterns?
      But creating a parser for a complex language
      has been a time-consuming effort,
      and one which has a high risk of disappointing results.
      Worse, it was an effort
      that had a very real risk of total failure.
      </p>
      <p>How did the Go4 deal with this?
      (The <i>Design Patterns</i> book has four authors,
      who are often called the Gang of Four, or Go4.)
      They defined the problem away.
      They stated that the parsing issue was separate from the
      Interpret Pattern, which was about what you did with the AST
      once you'd somehow come up with one.
      </p>
    <p>
      But AST's don't (so to speak) grow on trees.
      You have to get one from somewhere.
      In their example, the Go4 simply created one in their code.
      In doing this, they bypassed the BNF, and the problem parsing,
      but also the whole point of having a language.
      </p>
      <p>
      Which is why Yegge characterized the chapter as a practical joke.
      And why less ideal programming techniques and patterns are almost
      always preferred to the Interpreter Pattern.
      </p>
      <h3>That one missing piece</h3>
    <p>So that's how the Go4 left things.
    A potentially great programming technique made almost useless because
    of a missing piece.
    There was no easy, general and practical way to generate AST's.
    </p>
    <p>
    Few expected that to change.
    I was more optimistic than most,
    and in 2007 I embarked on a project to create an Earley-based
    parser that I was sure would fulfill two of the criteria --
    it would be easy to use, and general.
    As far as practical, well, a lot of parsing problems
    are small, and a lot of applications don't require a lot
    of speed, and for these I expected the result to be good enough.
    </p>
    <p>What I didn't realize was that
    the obstacles to Earley's practical use
    has been solved.
    Neither apparently did anyone else,
    including the people who had solved the problems.
    because they'd each tackled a different set of problems.
    In Canada, Aycock and Horspool had cleaned up Earley's algorithm, but their version
    was still too slow for grammars with right recursion.
    Ten years earlier, in the Netherlands,
    the mathematican Joop Leo had ignored the issues Aycock and Horspool had solved,
    drilled in on right recursion,
    and arrived at a brilliant solution.
    Apparently neither knew of the other's work.
    </p>
    <p>
    Because of Leo's work, Marpa is fast.
    For any grammar in any class currently in practical use, Marpa parses in linear time.
    That includes regular expressions,
    the LL(k) grammars on which recursive descent and PEG
    are based for all <i>k</i>, and the LR(k) grammars on which yacc and bison are based,
    again for all <i>k</i>.
    Because of Aycock and Horspool, Leo's speed can be harnessed in practice.
    <p>There was still work to do.
    The Aycock-Horspool and Leo algorithms had branched off in different directions --
    it was not obvious that the two approaches could be combined, much less how,
    and the solution was not simple.
    In the course of combining the two, I reordered the Earley parse engine,
    in a way that has some very nice properties for,
    among other things, error reporting.
    <h3>Eureka and all that</h3>
    <p>The result from all this is an algorithm which parses anything
    you can write in BNF and
    does it in times which are now considered optimal in practice.
    And, unlike recursive descent, you don't have to write it --
    Marpa takes the BNF and creates the parser for you.
    It's the easy, "drop-in" solution that the Go4 needed and did not have.
    For the example in the Go4 book, I've done exactly than and put it into a gist.
    </p>
    <h3>More about Marpa</h3>
    <p>
      Marpa's latest version is Marpa::R2, which is on CPAN.
      Marpa has a web page,
      and of course is the focus of the this blog.
      Comments on this post
      can be sent to the Marpa's Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
