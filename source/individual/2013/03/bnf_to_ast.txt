BNF to AST
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      The latest version of Marpa takes its "whipitupitude" one step further.
      You can now go straight from your input string,
      and a BNF description of the language it is in,
      to an abstract syntax tree (AST).
    </p>
    <p>To illustrate, I'll use an example from the
      Gang of Four's (Go4) chapter on the Interpreter pattern.
      The G04 had no easy generally-applicable way to go from BNF to AST,
      a problem they dealt with by punting.
      Instead of parsing the input string,
      they just built the AST they needed it to produce in the their code.
    </p>
    <p>In this post, Marpa will take us from input string and BNF to AST.
      The Go4's example was a simple boolean expression language,
      and their primary example was
    </p>
    <blockquote>
      <pre>
true and x or y and not x
</pre>
    </blockquote>
    <p>Here, in full, is the BNF,
      together with specifications to tell Marpa how to build the AST:
    </p><blockquote>
      <pre>
:default ::= action =&gt; ::array

:start ::= &lt;boolean expression&gt;
&lt;boolean expression&gt; ::=
       &lt;variable&gt; bless =&gt; variable
     | '1' bless =&gt; constant
     | '0' bless =&gt; constant
     | ('(') &lt;boolean expression&gt; (')') action =&gt; ::first bless =&gt; ::undef
    || ('not') &lt;boolean expression&gt; bless =&gt; not
    || &lt;boolean expression&gt; ('and') &lt;boolean expression&gt; bless =&gt; and
    || &lt;boolean expression&gt; ('or') &lt;boolean expression&gt; bless =&gt; or

&lt;variable&gt; ~ [[:alpha:]] &lt;zero or more word characters&gt;
&lt;zero or more word characters&gt; ~ [\w]*

:discard ~ whitespace
whitespace ~ [\s]+
</pre>
    </blockquote>
    <p>This syntax should be fairly transparent.
    In previous posts I've given
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">
        a tutorial</a>,
	and a
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">a
        mini-tutorial</a>.
	And of course, the interface is <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.048000/pod/Scanless/DSL.pod">
	documented</a>.
    </p>
    <p>For those skimming, here are a few quick comments on the less-obvious features.
      To guide Marpa in building the AST,
      the BNF statements have
      <tt>action</tt>
      and
      <tt>bless</tt>
      adverbs.
      The
      <tt>bless</tt>
      adverbs indicate a Perl class into which the node should be
      blessed.
      This is convenient for using an object-oriented approach with the AST.
      The
      <tt>action</tt>
      adverb tells Marpa how to build the nodes.
      "<tt>action =&gt; ::array</tt>" means the result of the rule should
      be an array containing its child nodes.
      "<tt>action =&gt; ::first</tt>" means the result of the rule should just be
      its first child.
      Many of the child symbols, especially literal strings of a structural
      nature are in parentheses.
      This indicates that the semantics should ignore them.
    </p>
    <p>A <tt>:default</tt>
      pseudo-rule specifies the defaults -- in this case the
      important one is the
      "<tt>action =&gt; ::array</tt>" adverb setting.
      The
      <tt>:start</tt>
      pseudo-rule specified the start symbol.
      And the
      <tt>:discard</tt>
      indicated that whitespace is to be discarded.
    </p>
    <p>Finally, I should mention that the Go4 did not deal with precedence,
    and so in their book the input string has parentheses.
    I've implemented the standard precedence in the grammar above.
    the double vertical bar ("<tt>||</tt>") is a "loosen" operator --
    the alternative after it is at a looser precedence than the one before.
    Alternatives separated by a single bar are at the same precedence.
    <h3>The AST</h3>
    <p>Here is the AST that results:
    </p><blockquote>
      <pre>
$VAR1 = bless( [
                 bless( [
                          bless( [
                                   'true'
                                 ], 'Boolean_Expression::variable' ),
                          bless( [
                                   'x'
                                 ], 'Boolean_Expression::variable' )
                        ], 'Boolean_Expression::and' ),
                 bless( [
                          bless( [
                                   'y'
                                 ], 'Boolean_Expression::variable' ),
                          bless( [
                                   bless( [
                                            'x'
                                          ], 'Boolean_Expression::variable' )
                                 ], 'Boolean_Expression::not' )
                        ], 'Boolean_Expression::and' )
               ], 'Boolean_Expression::or' );
</pre>
    </blockquote>
    <h3>Processing the AST</h3>
    <p>What the G04 did do was process the AST in several ways -- straight
    evaluation, copying,
    and substitution of the occurrences of a variable in one boolean expression
    by another boolean expression.
    While it is obvious that the AST above is the computational
    equivalent of the Go4's, 
    for the sake of completeness I carry out the same operations
    in the gist.
    <p>
    Marpa is self-hosting --
    it parses its own DSL using its own AST's.
    So, for example, the Marpa source file in this post,
    describing boolean expressions,
    was itself turned into an AST on its way to becoming a parser
    that turns boolean expressions into AST's.
    And <a href="https://gist.github.com/jddurand/5052023">a project to produce AST's from C code</a>
    is currently under development.
    <h3>Comments</h3>
    <p>
      Comments on this post
      can be sent to the Marpa Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
