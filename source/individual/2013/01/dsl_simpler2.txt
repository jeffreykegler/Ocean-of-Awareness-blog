Making DSL's even simpler
<!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
  <p>In a previous post, I showed how to make it easier to write
  domain-specific languages (DSLs).
  This post takes things one step further --
  using Marpa's new Scanless interface, it eliminates the need to
  write a separate scanner (lexer).
  <p>
  When it comes to dealing with a programming problem,
  no tool is as powerful and flexible as
  a custom language targeted at the problem domain.
  But writing a domain specific language (DSL) is among the
  least used approaches,
  and for what has been a very good reason --
  DSL's have been very difficult to write.
  <p>This post takes a tutorial approach.
  It does <b>not</b> assume any knowledge of the previous tutorials
  on this blog.
  The full code for this post is in a Github gist.
  A very similar example is part of Marpa::R2's test suite.
  Our example DSL is a calculator.
  This calculator is designed to make a good example,
  more than as something you'd want to use.
  But it goes beyond the requirement for a "toy" example
  -- its 300 lines include good diagnostics and a test suite.
  <h3>The Grammar</h3>
  Let's start right in, by showing the grammar for our calculator.
  It natural divides into two parts.  Here is the first:
  <blockquote>
  <pre>
:start ::= script
script ::= expression
script ::= script ';' expression action =&gt; do_arg2
&lt;reduce op&gt; ::= '+' | '-' | '/' | '*'
expression ::=
     number
   | variable action =&gt; do_is_var
   | '(' expression ')' assoc =&gt; group action =&gt; do_arg1
  || '-' expression action =&gt; do_negate
  || expression '^' expression action =&gt; do_caret assoc =&gt; right
  || expression '*' expression action =&gt; do_star
   | expression '/' expression action =&gt; do_slash
  || expression '+' expression action =&gt; do_plus
   | expression '-' expression action =&gt; do_minus
  || expression ',' expression action =&gt; do_array
  || &lt;reduce op&gt; 'reduce' expression action =&gt; do_reduce
  || variable '=' expression action =&gt; do_set_var
</pre></blockquote>
<p>The format of the grammar is documented
<a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.040000/pod/Scanless.pod">
here</a>.
It consists of BNF rules, whose left hand side (LHS) and right hand side (RHS)
can be separated by the BNF operator (<tt>::=</tt>).
The first rule is a pseudo-rule -- its LHS is the psuedo-symbol <tt>:start</tt>,
and it indicates that <tt>script</tt> is that start symbol.
The next two rules indicate that <tt>script</tt> is a series of one
or more <tt>expression</tt>, separated by semicolon.
<p>
Rules can have action "adverbs"
to describe the semantics.
For example, the adverb "<tt>action =&gt; do_args</tt> says that the semantics for
the preceding RHS are implemented by a Perl closure named <tt>do_args</tt>.
<p>The rules for
<tt>&lt;reduce op&gt;</tt> introduces two new features: symbols names
in angle brackets, and alternatives,
separated by a veritcal bar, ("<tt>|</tt>").
<p>The last statement is a precedence rule.
It is a series of alternatives, some separated by 
a single vertical bar,
but others separated by a double vertical ("<tt>||</tt>").
The double vertical bar indicates that the alternatives after it
are at a looser ("lower") precedence than the alternatives before it.
The single vertical bar separates alternatives as the same precedence level.
<p>
So far, we have been assuming that Marpa will "do the right
thing" about whitespace in our calculator.
The next set of rules deal with lexical issues, and specify
how this works.
</p>
  <blockquote>
  <pre>
number ~ [\d]+
variable ~ [\w]+
:discard ~ whitespace
whitespace ~ [\s]+
# allow comments
:discard ~ &lt;hash comment&gt;
&lt;hash comment&gt; ~ &lt;terminated hash comment&gt; | &lt;unterminated
   final hash comment&gt;
&lt;terminated hash comment&gt; ~ '#' &lt;hash comment body&gt; &lt;vertical space char&gt;
&lt;unterminated final hash comment&gt; ~ '#' &lt;hash comment body&gt;
&lt;hash comment body&gt; ~ &lt;hash comment char&gt;*
&lt;vertical space char&gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;hash comment char&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
END_OF_GRAMMAR
<p>
This second set of rules take the same form as rules in the earlier set,
but instead of the BNF operator (<tt>::=</tt>),
they have a match operator (<tt>~</tt>) separating the LHS and RHS.
The BNF operator can be seen as telling Marpa, "When it comes to whitespace and comments,
do what I <b>mean</b>".
The match operator instead tells Marpa to "Do exactly what I <b>say</b> on a literal,
character-by-characcter basis."
<p>
The first two lines indicate how <tt>number</tt>'s and <tt>variable</tt> are formed.
The square bracketed character classes accept anything acceptable to Perl.
<tt>:discard</tt> is another pseudo-symbol -- any lexeme recognized as a <tt>:discard</tt>
symbol is thrown away.
This is how whitespace and comments are dealt with.
</pre></blockquote>
