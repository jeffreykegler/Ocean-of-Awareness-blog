A Marpa-powered C parser
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      Jean-Damien Durand has written MarpaX::Languages::C::AST,
      a tool which parses C language into an abstract syntax tree (AST).
      Recently released, it has been tested against
      Perl's C source code, as well as Marpa's own C source file.
    </p>
    <p>
      Because it is Marpa-powered,
      MarpaX::Languages::C::AST works differently from other C parsers,
      which are based on either LALR (yacc/bison) parsing,
      or hand-written recursive descent.
      MarpaX::Languages::C::AST's is syntax-driven, like LALR.
      But it allows procedural parsing, like recursive descent --
      in fact, better, since Marpa's syntax-driven side is capable of
      feeding full information about the state of the parse to the
      procedural logic.
      This means that the two can reinforce each other.
    </p>
    <p>The result is a combined lexer/parser
    which is unusually compact, easy-to-understand
    and easy to modify.
    The logic which can be described via syntax (BNF) is implemented from the
    BNF.
    Parsing from the BNF is enough to handle lexing and parsing for almost all of standard C,
    including the
    much discussed <a href="http://en.wikipedia.org/wiki/Dangling_else>if-then-else issue</a>.
    </p>
    <p>But C is actually context-sensitive -- the disambiguation of C types from
    C variable names cannot be fully described in BNF.
    Traditional compilers handle this as
    <a href="http://en.wikipedia.org/wiki/The_lexer_hack">
    a lexer hack</a>.
    This solution can be hack-ish because the traditional lexer has no clue
    about the C grammar.
    MarpaX::Languages::C::AST deals with this by switching to procedural logic
    at the appropriate points.
    In Marpa's approach, the code deciding whether a name is a variable or a type
    knows context in which it was called,
    so no hack-ish tricks are required,
    and it is much easier to see how
    the code relates to the problem being solved.
    </p>
    <p>
      Potential uses of MarpaX::Languages::C::AST includes tools, interpreters
      and compilers for the C language.
      This code is open source, and is much easier basis on which
      to create C language supersets and subsets than
      previous C parsers.
    </p>
    <p>
      A C parser can take one of two strategies: approximate or precise.
      A compiler has, of course, to be precise.
      Tools, such as cross-referencers, often decide to be approximate, or sloppy.
      Sloppiness is easier to implement and has other advantages:
      Compilers require the user to get all the C flags right.
      A sloppy tool can tolerate missing flags: what the flags should be
      can be one of the things it guesses at.
    </p>
    <p>Of the two strategies, Jean-Damien decided to go with "precise".
      MarpaX::Languages::C::AST follows the C11 standard,
      with either GCC or Microsoft extensions.
      This has the advantage that
      MarpaX::Languages::C::AST could be used as the front end of a compiler.
    </p>
    <h3>Applications</h3>
    <ul>
    <li>Customized and customize-able "lints" -- programs to enforce C language standards
    and restrictions specific to a individual, a company or a project.
    </ul>
    <h3>Compilers?</h3>
    <p>
    I am focused on parsing,
    and I'm often tempted to call MarpaX::Languages::C::AST a "compiler".
    And it can be called that if you were willing to consider an abstract syntax tree
    a compilation "target".
    But much of what you look for in a compiler is missing from MarpaX::Languages::C::AST,
    including implementation of non-syntactic constraints -- things
    like "<tt>case</tt>" labels only being allowed in switch statements.
    These could be added in the same way that more conventional compilers typically implement them --
    in post-processing.
    But a central advantage of MarpaX::Languages::C::AST is to empower your own extensions --
    for you to pick up where it leaves off.
    </p>
    <h3>To learn more</h3>
    <p>
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2
        is available on CPAN</a>.
      A list of my Marpa tutorials can be found
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL">
        here</a>.
      There are
      new tutorials by
      <a href="http://marpa-guide.github.io/chapter1.html">Peter Stuifzand</a>
      and
      <a href="http://longanswers.blogspot.de/2013/06/transforming-syntax.html">amon</a>.
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        The Ocean of Awareness blog</a>
      focuses on Marpa,
      and it has
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">an annotated guide</a>.
      Marpa also has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is
      <a href="http://groups.google.com/group/marpa-parser">
        the "marpa parser"
        Google Group.</a>
      Comments on this post can be made there.
    </p>
