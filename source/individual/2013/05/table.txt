Why Marpa works: table parsing
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      Marpa works very differently from the parsers
      in wide use today.
      Marpa is a table parser.
    </p>
    <p>
      The currently favored parsers (recursive descent and,
      decreasing, LALR parsers like bison)
      uses stacks and/or state machines.
      These have the advantage that they are easy
      to make fast.
      They have the disadvantage of severely limiting
      what the parser can do and how much it can know.
    </p>
    <p>
      There are other table parsers besides Marpa.
      These are popular in specialized uses, particular those 
      where power is important and speed
      is not.
      Marpa is unusual among table parsers --
      its focus is on speed.
    </p>
    <h3>What is table parsing</h3>
    <p>
      Table parsing means parsing by constructing a table of all the possible parses.
      This is pretty clearly something you want -- anything less means
      not completely knowing what you're doing.
      It's like walking across the yard blindfolded.
      It's fine if you can make sure there are
      no walls, open pits, or other dangerous obstacles.
      But for the general case,
      it's a bad idea.
    </p>
    <p>
    Where the analogy between walking blindfolded and parsing breaks
    down is that taking off the blindfold has no cost,
    Building a table of everything that is happening while you parse
    <b>does</b> have a cost.
    </p>
    <h3>The advantages of table parsing</h3>
    <p>
      What are the advantages of taking off the blindfold?
      First, your parser can be completely general --
      anything you can write in BNF it can parse.
      And second,
      you always know exactly what is going on -- what rules
      are possible, what rules have been recognized,
      how far into a rule you have recognized it,
      what symbols you expect next, etc. etc.
    <p>
    </p>
      We programmers have gotten used to parsers which run blindfolded.
      Just like when you hit something blindfolded you don't know
      what it was, whether you could get around it or how,
      when these parsers fail, they don't know why.
      They can only guess.
      If you have a full parse table
      built from left to right,
      you know what you were looking for and what you already think you
      found.
      This means that you can pinpoint and identify errors precisely.
    </p>
    <p>
       Knowing where you are in a parse also allows certain tricks,
       like the one I call the Ruby Slippers.
       In this, you parse with an over-simplified grammar and,
       when it fails, you ask the parser what it was looking for.
       Then -- poof! -- you provide it.
       The Ruby Slippers works beautifully when dealing with
       missing tags in HTML.
       You can define a simplified HTML grammar,
       one that leaves in a non-existent ideal world where all start
       and end tags are always where they belong.
       Then you parse away.
       If, as will happen with real-world input, a tag is missing,
       you ask the table parser what it was looking for,
       and give it a virtual tag.
    </p>
    <h3>The feasibility of table parsing</h3>
    <p>But a question arises about table parsing:
      "Sounds great, but can you do it fast enough to be useful in practice?"
    </p>
    <p>
      First, let's assure ourselves that it can be done.
      If we ignore speed issues,
      the answer is fairly clearly "yes".
      A grammar has a finite number of rules, each of finite length,
      and parses a finite number of input symbols.
      Since the number of input symbols is finite,
      at any location the number of previous location at which a rule
      or symbol could have started is also finite.
      Since everything is finite, all we have to do is check all the possibilities
      as we progress from left-to-right, making sure they apply.
    </p>
    <p>
      So table parsing is definitely possible.
      But way of implementing it described above would be too slow for it
      to be a practical method.
    Fortunately, there are faster ways to do it,
      and a number of these are in use.
      But most of them concentrate on power -- they don't try to
      be fast enough for a wide range of practical applications,
      and they aren't.
    </p>
    <h3>Fast table parsing</h3>
    <p>
    </p>
    <h3>For more about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      A list of Marpa tutorials can be found
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL">
      here</a>.
      There is
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        this blog</a>,
	which has
	<a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">an annotated guide</a>,
	and 
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is a
      Google Group:
      <code>marpa-parser@googlegroups.com</code>.
      Comments on this post can be made there.
    </p>
