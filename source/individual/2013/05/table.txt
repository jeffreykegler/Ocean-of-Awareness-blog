Why Marpa works: table parsing
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      Seasoned observers of the parsing scene may have been unimpressed
      by my confidence in Marpa's abilities,
      present and future.
      They've certainly seen it before.
      "New" parsing algorithms have come along over the past decades with
      some regularity.
      They tried a wide variety of different approaches,
      but all of them shared two things: confident authors
      and disappointing results.
    </p>
    <p>
      In this post I'll explain, on what this confidence is based,
      and why I think that the candid and seasoned observer could convince himself,
      "This time it's different".
    </p>
    <h3>The power and flexibility table parsing</h3>
    <p>
      Marpa is a table parser, one of a family of such algorithms.
      Marpa is unusual among this family in its focus on speed.
    </p>
    <p>
      Table parsing means parsing by constructing a table of all the possible parses.
      The current favorite parsers (yacc, recursive descent, etc.) do not do this --
      their quest for speed uses state diagrams and/or stacks,
      and they are not able to track all possible parses.
    </p>
    <p>
      The advantages of table parsing are pretty obvious.
      If your table tracks BNF rules,
      you can parse any grammar that you can write in BNF.
      You always know exactly what is going on -- what rules
      are possible, what rules have been recognized,
      how far into a rule you have recognized it,
      what symbols you expect next, etc. etc.
      This means that if you keep the parsing from left-to_right
      (which Marpa does)
      you can easily combine procedural parsing with your parsing algorithm.
    </p>
    <h3>The feasibility of table parsing</h3>
    <p>But a questions arises about table parsing:
      "Sounds great, but can you do it fast enough to be useful in practice?"
    </p>
    <p>
      First, let's assure ourselves that it can be done.
      If we ignore speed issues,
      the answer is fairly clearly "yes".
      A grammar has a finite number of rules, each of finite length,
      and parses a finite number of input symbols.
      Since the number of input symbols is finite,
      at any location the number of previous location at which a rule
      or symbol could have started is also finite.
      Since everything is finite, all we have to do is check all the possibilities
      as we progress from left-to-right, making sure they apply.
    </p>
    <p>
      So table parsing is definitely possible.
      But way of implementing it described above would be too slow for it
      to be a practical method.
    </p><p>Fortunately, there are faster ways to do it,
      and a number of these are in use.
      But most of them concentrate on power -- they don't try to
      be fast enough for a wide range of practical applications
      and they aren't.
    </p>
    <h3>Fast table parsing</h3>
    <p>
    </p>
    <h3>For more about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      There is
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        a blog</a>,
      as well as a
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is a
      Google Group:
      <code>marpa-parser@googlegroups.com</code>.
      Comments on this post can be made there.
    </p>
