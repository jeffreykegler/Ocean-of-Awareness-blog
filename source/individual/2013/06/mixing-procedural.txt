Mixing procedural and declarative parsing gracefully
<h3>Declarative and procedural parsing</h3>
<p><!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
-->A declarative parser
takes a description of your language and parses it
for you.
On the face of it, this sounds like the way you'd want
to go,
and Marpa offers that possibily -- it generates
a parser from anything you can write in BNF and,
if the parser in is one of the classes currently in
practical use,
that parser will run in linear time.
</p>
<p>
But practical grammars often have context-sensitive parts --
features which cannot be described in BNF.
Nice as declarative parsing may sound,
the need to do at least <b>some</b> procedural parsing
can seem to an obstacle
in real-life.
</p>
In this post, I take a problem for which procedural
parsing is essential,
and create a fast, short solution that
mixes procedural and declarative.
The "weld point" between
the procedural and the declaration is
not tricky or awkward,
and the solution comes out looking like
the problem.
</p>
<h3>The application</h3>
<p>This is a sample of the language:
</p>
<blockquote>
<pre>
A2(A2(S3(Hey)S13(Hello, World!))S5(Ciao!))
</pre>
</blockquote>
<p>
It describes strings in nested arrays.
The strings are introducted by the letter 'S', followed by a length count and then,
in parentheses, the string itself.
Arrays are introducted by the letter 'A' followed by an element count and, inside parentheses, the
arrays contents.
The array contents are a concatenated series of strings and other arrays.
</p>
<p>I call this a Dyck-Hollerith language because it
combines
<a href="http://en.wikipedia.org/wiki/Hollerith_constant">
Hollerith constants</a>
(strings preceded by a count),
with balanced parentheses
(what is called
<a href="http://en.wikipedia.org/wiki/Dyck_language">
a Dyck language</a>
by mathematicians).
</p>
<p>
The language is one I've dealt with before.
It is apparently from "real life", and is described more fully
in 
In
<a href="http://blogs.perl.org/users/polettix/2012/04/parserecdescent-and-number-of-elements-read-on-the-fly.html">
a blog post by
Flavio Poletti</a>.
Several people, Gabor Szabo among them, challenged me to show how
<a href="http://jeffreykegler.github.com/Marpa-web-site/">
Marpa</a>
would do on this language.
I did this a year ago, using Marpa's previous version, Marpa::XS.
In this post, I redo it, using Marpa's new SLIF interface.
The result, already quite satisfactory, is a considerable improvement
in readability, flexibility and speed.
</p>
<h3>The code</h3>
<p>The full code for this example is in
<a href="https://gist.github.com/jeffreykegler/5745272">
a Github gist</a>.
In what follows, I will assume the reader is skimming,
looking for the general idea,
and I will focus on major features.
Actual tutorials can be found
<a href="https://metacpan.org/module/Marpa::R2".
in Marpa's documentation</a>,
on
<a href=http://jeffreykegler.github.io/Ocean-of-Awareness-blog/">
the Ocean of Awareness blog</a>,
and on
<a href="http://marpa-guide.github.io/index.html"
the Marpa Guide,
a new website</a>
being
built due to the generosity of Peter Stuifzand
and Ron Savage.
</p>
<h3>The DSL</h3>
<p>First off, let's look at the declarative part.
The core of the parser is the following lines,
containing the BNF for the language's top-level structure.
</p>
<blockquote>
<pre>
my $dsl = &lt;&lt;'END_OF_DSL';
# The BNF
:start ::= sentence
sentence ::= element
array ::= 'A' &lt;array count&gt; '(' elements ')'
    action =&gt; check_array
string ::= ( 'S' &lt;string length&gt; '(' ) text ( ')' )
elements ::= element+
  action =&gt; ::array
element ::= string | array
</pre>
</blockquote>
<p>Details of this syntax are in Marpa's documentation,
but it's a dialect of EBNF.
Adverbs like <tt>action =&gt; semantics</tt> tell Marpa what the semantics will be.
The default (which will be set below) is for a rule to retun its first child.
The parentheses in the <tt>string</tt> declaration "hide" the symbols from the
semantics, so that <tt>text</tt> is treated by the semantics as if it
were the "first" symbol.
<tt>::array</tt> semantics tell Marpa to return all every <tt>element</tt>
of <tt>elements</tt> in an array.
And <tt>check_array</tt> is the name of a function providing
the semantics, one which will be described below.
</p>
<p>Marpa's SLIF provides a lexer for the user, and this one will handle most
of the symbols.  The single-quoted strings we saw in the BNF are actually instructions
to this lexer, and here are some on how to handle
<tt>&lt;array_count&gt;</tt> and
<tt>&lt;string length&gt;</tt>.
<blockquote>
<pre>
&lt;array count&gt; ~ [\d]+
&lt;string length&gt; ~ [\d]+
text ~ [\d\D]
END_OF_DSL
</pre>
</blockquote>
<p>
<tt>&lt;array_count&gt;</tt> are
<tt>&lt;string length&gt;</tt> are both declared to be a series of digits.
<tt>text</tt> is a stub.
The length of <tt>text</tt> depends on the numeric value of
<tt>&lt;string length&gt;</tt>, and that's beyond the power of BNF to deal with,
so when the time comes,
When it comes time to deal with <tt>text</tt>,
we will hand control over to an external lexer.
For the purposes of Marpa's lexer, it's enough to tell it
that text is a single character of anything.
</p>
<p>Now comes the weld between declarative and procedural ...
</p>
<blockquote>
<pre>
:lexeme ~ &lt;string length&gt; pause =&gt; after
:lexeme ~ text pause =&gt; before
</pre>
</blockquote>
<p>These two statements tell Marpa that 
<tt>&lt;string length&gt;</tt>
and
<tt>&lt;text&gt;</tt>
are two lexicals at which Marpa's own parsing should "pause",
handing over control to external procedural logic.
In the case of <tt>&lt;string length&gt;</tt>,
the pause should be after it is read.
In the case of <tt>&lt;text&gt;</tt>
the pause should be before.
What happens during the "pause", we will soon see.
</p>
<h3>Starting the parse</h3>
<p>Next follows the code to read the DSL,
and start the parser.
<blockquote>
<pre>
my $grammar = Marpa::R2::Scanless::G-&gt;new(
    {   action_object  =&gt; 'My_Actions',
        default_action =&gt; '::first',
        source         =&gt; \$dsl
    }
);

my $recce = Marpa::R2::Scanless::R-&gt;new( { grammar =&gt; $grammar } );
</pre>
</blockquote>
<p>The previous lines tell Marpa that, when its semantics
is provided by a Perl semantics, to look for its semantics in a package called
<tt>My_Actions</tt>.
The default semantics are <tt>::first</tt>, which means simply pass the value of
the first RHS symbol of a rule upwards.
</p>
<blockquote>
<pre>
    $input = 'A2(A2(S3(Hey)S13(Hello, World!))S5(Ciao!))';
</pre>
</blockquote>
<blockquote>
<pre>

my $last_string_length;
my $input_length = length $input;
INPUT:
for (
    my $pos = $recce-&gt;read( \$input );
    $pos &lt; $input_length;
    $pos = $recce-&gt;resume($pos)
    )
{
    my $lexeme = $recce-&gt;pause_lexeme();
    die q{Parse exhausted in front of this string: "},
        substr( $input, $pos ), q{"}
        if not defined $lexeme;
    my ( $start, $lexeme_length ) = $recce-&gt;pause_span();
    if ( $lexeme eq 'string length' ) {
        $last_string_length = $recce-&gt;literal( $start, $lexeme_length ) + 0;
        $pos = $start + $lexeme_length;
        next INPUT;
    }
    if ( $lexeme eq 'text' ) {
        my $text_length = $last_string_length;
        $recce-&gt;lexeme_read( 'text', $start, $text_length );
        $pos = $start + $text_length;
        next INPUT;
    } ## end if ( $lexeme eq 'text' )
    die "Unexpected lexeme: $lexeme";
} ## end INPUT: for ( my $pos = $recce-&gt;read( \$input ); $pos &lt; $input_length...)
</pre>
</blockquote>
<blockquote>
<pre>

package My_Actions;

</pre>
</blockquote>
<blockquote>
<pre>

sub check_array {
    my ( undef, undef, $declared_size, undef, $array ) = @_;
    my $actual_size = @{$array};
    warn
        "Array size ($actual_size) does not match that specified ($declared_size)"
        if $declared_size != $actual_size;
    return $array;
} ## end sub check_array

</pre>
</blockquote>
<blockquote>
<pre>

my $result = $recce-&gt;value();
die 'No parse' if not defined $result;
my $received = Data::Dumper::Dumper( ${$result} );

</pre>
</blockquote>
    <h3>For more about Marpa</h3>
    <p>The techniques described apply to problems considerably
    larger this than the example of this post.
    Jean-Damien Durand is using them to create
    <a href="https://github.com/jddurand/MarpaX-Languages-C-AST">
    a C-to-AST tool</a>.
    This
    takes C language and converts it to an AST,
    following the C11
    specification carefully.
    The AST can then be manipulated
    as you wish.
    </p
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      A list of my Marpa tutorials can be found
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL">
        here</a>.
      There is
      <a href="http://marpa-guide.github.io/chapter1.html">
        a new tutorial by Peter Stuifzand</a>.
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        This blog</a>
      focuses on Marpa,
      and it has
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">an annotated guide</a>.
      Marpa also has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is a
      Google Group:
      <code>marpa-parser@googlegroups.com</code>.
      Comments on this post can be made there.
    </p>
