Mixing procedural and declarative parsing gracefully
<h3>Declarative and procedural parsing</h3>
<p><!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
-->A declarative parser
takes a description of your language and parses it
for you.
On the face of it, this sounds like the way you'd want
to go,
and Marpa offers that possibily -- it generates
a parser from anything you can write in BNF and,
if the parser in is one of the classes currently in
practical use,
that parser will run in linear time.
</p>
<p>
But practical grammars often have context-sensitive parts --
features which cannot be described in BNF.
Nice as declarative parsing may sound,
the need to do at least <b>some</b> procedural parsing
can seem to an obstacle
in real-life.
</p>
In this post, I take a problem for which procedural
parsing is essential,
and create a fast, short solution that
mixes procedural and declarative.
The "weld point" between
the procedural and the declaration is
not tricky or awkward,
and the solution comes out looking like
the problem.
</p>
<h3>The application</h3>
<p>This is a sample of the language:
</p>
<blockquote>
<pre>
A2(A2(S3(Hey)S13(Hello, World!))S5(Ciao!))
</pre>
</blockquote>
<p>
It describes strings in nested arrays.
The strings are introducted by the letter 'S', followed by a length count and then,
in parentheses, the string itself.
Arrays are introducted by the letter 'A' followed by an element count and, inside parentheses, the
arrays contents.
The array contents are a concatenated series of strings and other arrays.
</p>
<p>I call this a Dyck-Hollerith language because it
combines
<a href="http://en.wikipedia.org/wiki/Hollerith_constant">
Hollerith constants</a>
(strings preceded by a count),
with balanced parentheses
(what is called
<a href="http://en.wikipedia.org/wiki/Dyck_language">
a Dyck language</a>
by mathematicians).
</p>
<p>
The language is one I've dealt with before.
It is apparently from "real life", and is described more fully
in 
In
<a href="http://blogs.perl.org/users/polettix/2012/04/parserecdescent-and-number-of-elements-read-on-the-fly.html">
a blog post by
Flavio Poletti</a>.
Several people, Gabor Szabo among them, challenged me to show how
<a href="http://jeffreykegler.github.com/Marpa-web-site/">
Marpa</a>
would do on this language.
I did this a year ago, using Marpa's previous version, Marpa::XS.
In this post, I redo it, using Marpa's new SLIF interface.
The result, already quite satisfactory, is a considerable improvement
in readability, flexibility and speed.
</p>
<h3>code</h3>
<blockquote>
<pre>
my $dsl = &lt;&lt;'END_OF_DSL';
# The BNF
:start ::= sentence
sentence ::= element
array ::= 'A' &lt;array count&gt; '(' elements ')'
    action =&gt; check_array
string ::= ( 'S' &lt;string length&gt; '(' ) text ( ')' )
elements ::= element+
  action =&gt; ::array
element ::= string | array
</pre>
</blockquote>
<blockquote>
<pre>
# Declare the places where we pause before
# and after lexemes
:lexeme ~ &lt;string length&gt; pause =&gt; after
:lexeme ~ text pause =&gt; before
</pre>
</blockquote>
<blockquote>
<pre>

# Declare the lexemes themselves
&lt;array count&gt; ~ [\d]+
&lt;string length&gt; ~ [\d]+
# define &lt;text&gt; as one character of anything, as a stub
# the external scanner determines its actual size and value
text ~ [\d\D]
END_OF_DSL
</pre>
</blockquote>
<blockquote>
<pre>

my $grammar = Marpa::R2::Scanless::G-&gt;new(
    {   action_object  =&gt; 'My_Actions',
        default_action =&gt; '::first',
        source         =&gt; \$dsl
    }
);

my $recce = Marpa::R2::Scanless::R-&gt;new( { grammar =&gt; $grammar } );

</pre>
</blockquote>
<blockquote>
<pre>
    $input = 'A2(A2(S3(Hey)S13(Hello, World!))S5(Ciao!))';
</pre>
</blockquote>
<blockquote>
<pre>

my $last_string_length;
my $input_length = length $input;
INPUT:
for (
    my $pos = $recce-&gt;read( \$input );
    $pos &lt; $input_length;
    $pos = $recce-&gt;resume($pos)
    )
{
    my $lexeme = $recce-&gt;pause_lexeme();
    die q{Parse exhausted in front of this string: "},
        substr( $input, $pos ), q{"}
        if not defined $lexeme;
    my ( $start, $lexeme_length ) = $recce-&gt;pause_span();
    if ( $lexeme eq 'string length' ) {
        $last_string_length = $recce-&gt;literal( $start, $lexeme_length ) + 0;
        $pos = $start + $lexeme_length;
        next INPUT;
    }
    if ( $lexeme eq 'text' ) {
        my $text_length = $last_string_length;
        $recce-&gt;lexeme_read( 'text', $start, $text_length );
        $pos = $start + $text_length;
        next INPUT;
    } ## end if ( $lexeme eq 'text' )
    die "Unexpected lexeme: $lexeme";
} ## end INPUT: for ( my $pos = $recce-&gt;read( \$input ); $pos &lt; $input_length...)
</pre>
</blockquote>
<blockquote>
<pre>

package My_Actions;

</pre>
</blockquote>
<blockquote>
<pre>

sub check_array {
    my ( undef, undef, $declared_size, undef, $array ) = @_;
    my $actual_size = @{$array};
    warn
        "Array size ($actual_size) does not match that specified ($declared_size)"
        if $declared_size != $actual_size;
    return $array;
} ## end sub check_array

</pre>
</blockquote>
<blockquote>
<pre>

my $result = $recce-&gt;value();
die 'No parse' if not defined $result;
my $received = Data::Dumper::Dumper( ${$result} );

</pre>
</blockquote>
    <h3>For more about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      A list of my Marpa tutorials can be found
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL">
        here</a>.
      There is
      <a href="http://marpa-guide.github.io/chapter1.html">
        a new tutorial by Peter Stuifzand</a>.
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        This blog</a>
      focuses on Marpa,
      and it has
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">an annotated guide</a>.
      Marpa also has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is a
      Google Group:
      <code>marpa-parser@googlegroups.com</code>.
      Comments on this post can be made there.
    </p>
