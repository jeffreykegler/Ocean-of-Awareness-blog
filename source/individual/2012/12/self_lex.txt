Self-parsing and self-lexing
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      In a previous post, I showed a self-parsing grammar,
      written in Marpa's new BNF interface.
      This post does the same for Marpa's forthcoming
      Scanless interface.
      Many readers will no doubt
      prefer to be introduced to the Scanless interface
      via a simpler example,
      but from the response to the previous past I know
      there are others who see the fascination of
      self-description and self-exemplification.
    </p><p>
      The previous self-parsing grammar,
      following the tradition, cheated a bit.
      It required, but did not include, a lexer to make a prepass over
      its input.
      This self-parsing scannerless grammar is as completely self-contained
      as it can get.
      It is the complete and ultimate authority on its own syntax.
      It does not describe its own semantics,
      but even a self-describing Turing machine has to be written
      assuming the semantics of a Turing machine.
      So that's one limit that is probably going to stand.
    </p><p>
      In terms of being a practical example, this is as practical
      as they come.
      This grammar I will describe is the one actually used not
      only to parse itself and all other grammars written in the
      Scanless language,
      but also to parse the strings written
      in the BNF interface,
      it non-scannerless predecessor.
      So this grammar is an
      authority, if an over-liberal one,
      on the syntax
      of the BNF interface as well,
      with the exception that it is over-liberal.
      (Constructs allowed in the Scanless interface, but prohibited
      in the BNF interface are caught when the semantics are processed.)
    </p><p>
      The grammar in this blog post is abridged a bit,
      and rearranged for ease of explanation.
      The original that is actually used for self-parsing can be
      found here.
    </p><blockquote>
      <pre>
# Copyright 2012 Jeffrey Kegler
      </pre>
    </blockquote>
    <p>The file starts with legalese -- it goes on to say that it is LGPL 3.0.
      Note the hash comment -- since they is a self-describing self-lexer,
      it is eventually going to have to tell us how it deals with comments.
    </p>
    <blockquote>
      <pre>
:start ::= rules
rules ::= rule+
rule ::= &lt;start rule&gt; | &lt;empty rule&gt; | &lt;priority rule&gt; | &lt;quantified rule&gt; | &lt;discard rule&gt;
      </pre>
    </blockquote>
    <p>Next it tells us that the
      <tt>rules</tt>
      symbol is the start symbol,
      that file consists of a series of one or more rules,
      and that rules fall into one of five types.
      The last rule, with the LHS
      <tt>rule</tt>
      is self-describing -- among the
      options it lists, it is a
      <tt>&lt;priority rule&gt;</tt>.
      In the previous two lines are two of the other possibilities:
      a
      <tt>&lt;start rule&gt;</tt>
      and a
      <tt>&lt;quantified rule&gt;</tt>.
    </p><blockquote>
      <pre>
&lt;start rule&gt; ::= (':start' &lt;op declare bnf&gt;) symbol
&lt;op declare bnf&gt; ~ '::='
      </pre>
    </blockquote><p>
      The parentheses can be ignored -- they are to help out the semantics.
      (Symbols inside parentheses can be ignored by the semantics.)
      Here we see the description of a start rule:
      the
      <tt>:start</tt>
      pseudo-symbol,
      and an
      <tt>::=</tt>
      operator,
      followed by a
      <tt>symbol</tt>.
    </p>
    <blockquote>
      <pre>
&lt;quantified rule&gt; ::= lhs &lt;op declare&gt; &lt;single symbol&gt; quantifier &lt;adverb list&gt;
lhs ::= &lt;symbol name&gt;
&lt;op declare&gt; ::= &lt;op declare bnf&gt; | &lt;op declare match&gt;
&lt;op declare match&gt; ~ '~'
quantifier ::= '*' | '+'
      </pre>
    </blockquote>
    <p>Above we saw a quantified rule: "<tt>rules ::= rule+</tt>"
      It contains a left hand side (LHS) symbol name
      one of the two declaration operators,
      a
      <tt>single symbol</tt>,
      a plus or minus "quantifier",
      and an adverb list.
      The adverb list can be empty, which it was in that case.
    </p><p>
      Next come two rules we've yet to see:
    </p>
    <blockquote>
      <pre>
&lt;discard rule&gt; ::= (':discard' &lt;op declare match&gt;) &lt;single symbol&gt;
&lt;empty rule&gt; ::= lhs &lt;op declare&gt; &lt;adverb list&gt;
      </pre>
    </blockquote>
    <p>
      We'll explain what a "discard rule" is when we encounter one.
      An empty rule is what is sounds like.
      Note that an empty rule can have an adverb list.
    </p>
    <blockquote>
      <pre>
&lt;priority rule&gt; ::= lhs &lt;op declare&gt; priorities
priorities ::= alternatives+
    separator =&gt; &lt;op loosen&gt; proper =&gt; 1
&lt;op loosen&gt; ~ '||'
alternatives ::= alternative+
    separator =&gt; &lt;op equal priority&gt; proper =&gt; 1
alternative ::= rhs &lt;adverb list&gt;
&lt;op equal priority&gt; ~ '|'
      </pre>
    </blockquote>
    <p>
      Most rules, including most of the rules we've already seen,
      are priority rules,
      so-called because in their most complicated form they can express
      a precedence scheme.
      The typical rule in a grammar is a priority rule with only
      one priority -- we've yet to see anything else.
      Within priorities, there can be alternatives,
      and we have seen example of this.
      When
      <tt>rule</tt>
      was defined as being one of a set of possible
      rule types, priority rule being among those types,
      the different types of rule were alternatives within a single
      priority.
    </p>
    <blockquote>
      <pre>
&lt;adverb list&gt; ::= &lt;adverb item&gt;*
&lt;adverb item&gt; ::=
      action
    | &lt;left association&gt; | &lt;right association&gt; | &lt;group association&gt;
    | &lt;separator specification&gt; | &lt;proper specification&gt;

action ::= ('action' '=&gt;') &lt;action name&gt;
&lt;left association&gt; ::= ('assoc' '=&gt;' 'left')
&lt;right association&gt; ::= ('assoc' '=&gt;' 'right')
&lt;group association&gt; ::= ('assoc' '=&gt;' 'group')
&lt;separator specification&gt; ::= ('separator' '=&gt;') &lt;single symbol&gt;
&lt;proper specification&gt; ::= ('proper' '=&gt;') boolean

rhs ::= &lt;rhs primary&gt;+
&lt;rhs primary&gt; ::= &lt;single symbol&gt;
&lt;rhs primary&gt; ::= &lt;kwc ws star&gt;
&lt;rhs primary&gt; ::= &lt;kwc ws plus&gt;
&lt;rhs primary&gt; ::= &lt;kwc ws&gt;
&lt;rhs primary&gt; ::= &lt;kwc any&gt;
&lt;rhs primary&gt; ::= &lt;single quoted string&gt;
&lt;rhs primary&gt; ::= &lt;parenthesized rhs primary list&gt;
&lt;parenthesized rhs primary list&gt; ::= ('(') &lt;rhs primary list&gt; (')')
&lt;rhs primary list&gt; ::= &lt;rhs primary&gt;+
&lt;single symbol&gt; ::=
    symbol
  | &lt;character class&gt;
symbol ::= &lt;symbol name&gt;
&lt;symbol name&gt; ::= &lt;bare name&gt;
&lt;symbol name&gt; ::= &lt;bracketed name&gt;
&lt;action name&gt; ::= &lt;bare name&gt;

:discard ~ whitespace
whitespace ~ [\s]+

# allow comments
:discard ~ &lt;hash comment&gt;
&lt;hash comment&gt; ~ &lt;terminated hash comment&gt; | &lt;unterminated
   final hash comment&gt;
&lt;terminated hash comment&gt; ~ '#' &lt;hash comment body&gt; &lt;vertical space char&gt;
&lt;unterminated final hash comment&gt; ~ '#' &lt;hash comment body&gt;
&lt;hash comment body&gt; ~ &lt;hash comment char&gt;*
&lt;vertical space char&gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;hash comment char&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]


boolean ~ [01]
&lt;bare name&gt; ~ [\w]+
&lt;bracketed name&gt; ~ '&lt;' &lt;bracketed name string&gt; '&gt;'
&lt;bracketed name string&gt; ~ [\s\w]+
&lt;kwc ws star&gt; ~ ':ws*'
&lt;kwc ws plus&gt; ~ ':ws+'
&lt;kwc ws&gt; ~ ':ws'
&lt;kwc any&gt; ~ ':any'

# In single quotes strings and character classes
# no escaping or internal newlines, and disallow empty string

&lt;single quoted string&gt; ~ ['] &lt;string without single quote or vertical space&gt; [']
&lt;string without single quote or vertical space&gt; ~ [^'\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]+

&lt;character class&gt; ~ '[' &lt;cc string&gt; ']'
&lt;cc string&gt; ~ &lt;cc character&gt;+
&lt;cc character&gt; ~ &lt;escaped cc character&gt; | &lt;safe cc character&gt;
&lt;escaped cc character&gt; ~ '\' &lt;horizontal character&gt;
# hex 5d is right square bracket
&lt;safe cc character&gt; ~ [^\x{5d}\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]

# a horizontal character is any character that is not vertical space
&lt;horizontal character&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
</pre>
    </blockquote>
    <p>
    </p>
    <h3>Comments</h3>
    <p>
      Comments on this post can be sent to the Marpa Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
