Parsing on a quantum computer
    <blockquote>
      <!--
      perl ./marpa_r2_html_fmt
      -->
      <i>
        If you want to build a ship, don't drum up the men to gather wood,
        divide the work and give orders. Instead, teach them to yearn for
        the vast and endless sea.</i>
      -- Antoine de Saint-Exupery
    </blockquote>
    <p>
      Imagine that you have a recursive descent parser,
      and a new box arrives to replace your staid old von Neumann machine --
      a quantum computer.
      In fact, your new machine is strictly speaking not a quantum computer,
      but a step beyond - a hyper-quantum computer.
      It is capable of fully non-deterministic programming,
      and has access to the hidden-variables of the quantum mechanics.
      The access to the hidden variables makes it
      possible to interrupt the non-determinism as often as you like,
      list all the possibilities, at that point.
      That is, you can superpostiion and unsuperposition as much
      as you want.
    </p>
    <p>
      How could you rewrite your
      recursive descent logic to take advantage this new machine?
      Essentially, this is the same question as how do you use Marpa for
      parsing.
      Because for all classes of grammar in practical use today, including
      the LL(k) grammars parseable by recursive descent,
      Marpa is efficient non-determinism available today.
    </p>
    <p>
      A recursive descent parser,
      follows a single thread of possibilities --
      it is deterministic programming.
      Marpa is non-deterministic -- at each token it keeps track of
      all parsing possibilities.
      For each token seen so far,
      Marpa knows all the rules that
      in which it could occur.
      Marpa also knows all rules which could start all any point.
      These can be listed and examined.
    </p>
    <p>
      If the hyper-quantum computer plopped onto your desk today,
      it might seem at first to make your job as a programmer harder.
      You were used to thinking in terms of a single procedural thread.
      On the hyper-quantum computer,
      many things are happening at once.
      If you keep thinking procedural,
      and try to work out all the threads,
      it is just too much.
    </p>
    <p>
      But as you get used to the new approach,
      things may seem easier.
      In the deterministic approach,
      you only needed to follow a single thread,
      but you often needed to have that thread
      deal multiple alternatives.
      To do this, you had to create
      state information and keep track of it yourself.
      This seemed natural because you'd gotten used to having to do it,
      but actually your logic could get very hairy.
      The hyper-quantum machine is now tracking of all these choices
      for you.
      You have to switch from thinking in terms of procedure,
      to thinking in terms of sets of alternatives.
    </p>
    <p>
      Before, the alternatives did not come in sets.
      You had to examine each of them on your own, track whatever relevant
      information you found.
      This certainly gave you a degree of control,
      but the backtracking was not very efficient.
      And in practice the complexity of dealing with
      all this roll-your-own state
      information severely limited the kinds of grammar that you could parse,
      and even the extent to which you understood exactly what your parser
      would and would not accept.
    </p>
    <p>
      You have to retrain yourself to think in terms of the alternatives
      available at any point,
      instead of thinking about how to come up with the alternatives.
      The hyper-quantum computer (and the Marpa parser)
      new comes up with the alternatives for you.
      You don't even have to know which alternatives are there --
      if you need to ask Marpa, it can tell you.
      But you do have to learn to ask the right questions
      at the right places.
      Once you do this, you will have a much more expressive
      and flexible language,
      translated at comparable or faster speeds
      by an easier to program,
      and easier to understand parser.
    </p>
