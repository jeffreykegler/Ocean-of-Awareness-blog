Reporting mismatched delimiters
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>A modern computer languages divides
      texts in that language into pieces.
      One very direct way for a language to identify a piece
      is to mark its boundaries with a pair of delimiters,
      where one delimiter marks the start and the other marks the end of the piece.
    </p><p>
      Delimiters, in the sense I am using the word,
      can take many forms.
      Quote marks, parentheses, curly braces and square brackets
      are all delimiters.
      Delimiters can be much more complex.
      XML and HTML tags are delimiters
      that have an complex internal structure of their own.
    </p>
    <p>
      Mismatching delimiters is an easy mistake to make and
      traditional parsers are often poor at reporting these:
      hopeless after the first mismatch,
      and for that matter none too precise about the first one.
      This post outlines a scaleable method for the accurate
      reporting of mismatched delimiters.
      I will illustrate the method with an example of a simple
      but useful tool --
      a utility which reports mismatched brackets.
    </p>
    <h3>The example script</h3>
    <p>The example script
      is a utility that reports mismatched brackets in the set:
    </p><blockquote><pre>
      () {} []
      </pre></blockquote><p>
      They are required to nest in the usual way.
      Other text is treated as filler, so that this utility
      will not be smart about things
      like strings or comments.
      This does have the advantage of making this utility mostly
      language-agnostic.
    </p>
    <p>
      Because it's intended primarily to be read
      as an illustration of the technique,
      this example is kept relatively simple.
      It's simple enough that a recursive descent parser, for
      example, might be able to emulate it.
      I hope the reader will see that this technique scales to more
      complex situations,
      in a way in which a solution based on a traditional parser
      could not.
    </p>
    <h3>Error reports</h3>
    <p>The description of how the method works will make more
      sense after we've looked a some examples of the diagnostics
      it produces.
      But, peeking, ahead, the strategy is to pinpoint failures quickly
      and correct them on the fly
    </p><p>
      To be truly useful,
      <tt>bracket.pl</tt>
      must report mismatches that span
      many lines,
      and it can do this.
      But single-line examples are easier to follow,
      and all the examples in this post will be contained in a one line.
      Consider the string '((([))', the
      <tt>bracket.pl</tt>'s diagnostics are:
    </p><blockquote><pre>
* Line 1, column 1: Opening '(' never closed, problem detected at end of string
((([))
^
====================
* Line 1, column 4: Missing close ], problem detected at line 1, column 5
((([))
   ^^
</pre></blockquote>
    <p>
      In the next example
      <tt>bracket.pl</tt>
      realizes that it
      cannot accept the ')' at column 16, without first closing the set of curly braces started at column 5.
      It identifies the problem, along with both of the locations involved.
    </p>
    <blockquote><pre>
* Line 1, column 5: Missing close }, problem detected at line 1, column 16
[({({x[]x{}x()x)})]
    ^          ^
</pre></blockquote>
    <p>
      So far, so good.
      But an important advantage of
      <tt>bracket.pl</tt>
      has yet to be seen.
      With most compilers, once they encounter one mismatched delimiter,
      the rest of their error messages will be useless.
      <tt>bracket.pl</tt>
      attempts to repair the damage,
      and usually succeeds well enough to accurately report
      some or all of the subsequent issues.
      Consider the text
      <tt>'({]-[(}-[{)'</tt>.
      The output of
      <tt>bracket.pl</tt>
      is
    </p><blockquote><pre>
* Line 1, column 1: Missing close ), problem detected at line 1, column 3
({]-[(}-[{)
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
({]-[(}-[{)
 ^^
====================
* Line 1, column 3: Missing open [
({]-[(}-[{)
  ^
====================
* Line 1, column 5: Missing close ], problem detected at line 1, column 7
({]-[(}-[{)
    ^ ^
====================
* Line 1, column 6: Missing close ), problem detected at line 1, column 7
({]-[(}-[{)
     ^^
====================
* Line 1, column 7: Missing open {
({]-[(}-[{)
      ^
====================
* Line 1, column 9: Missing close ], problem detected at line 1, column 11
({]-[(}-[{)
        ^ ^
====================
* Line 1, column 10: Missing close }, problem detected at line 1, column 11
({]-[(}-[{)
         ^^
====================
* Line 1, column 11: Missing open (
({]-[(}-[{)
          ^
</pre></blockquote>
    <p>Each time,
      <tt>bracket.pl</tt>
      corrects itself,
      so that it can accurately spot later problems.
    </p><h3>A difficult error report</h3>
    <p>
      To be 100%,
      <tt>bracket.pl</tt>
      would have to guess the programmer's intent.
      This is of course not possible.
      Let's look at a text where
      <tt>bracket.pl</tt>'s guesses are not so good:
      <tt>{{]}</tt>.
      Here we will assume the closing square bracket is a typo for a closing parenthesis.
      Here's the result:
    </p><blockquote><pre>
* Line 1, column 1: Missing close }, problem detected at line 1, column 3
{{]}
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
{{]}
 ^^
====================
* Line 1, column 3: Missing open [
{{]}
  ^
====================
* Line 1, column 4: Missing open {
{{]}
   ^
</pre></blockquote><p>
      Instead of one error,
      <tt>bracket.pl</tt>
      finds four.
    </p><p>
      But even in this case, the method is fairly good, especially when
      compared with current practice.
      The problem is at line 1, column 3,
      and the first three messages all identify this as one of their
      potential problem locations.
      It is reasonable to believe that a programmer, especially once
      he becomes used to this kind of mismatch reporting,
      will quickly find the first mismatch and fix it.
      This may not be much better than the state of the art,
      but it is certainly no worse.
    </p>
    <h3>How it works</h3>
    <p>
      For full details of the workings of
      <tt>bracket.pl</tt>
      there is the code,
      which is heavily commented.
      This section provides a conceptual overview.
    </p><p>
      <tt>bracket.pl</tt>
      uses two features of Marpa:
      left-eideticism and the Ruby Slippers.
      By left-eidetic, I mean that Marpa knows everything there is to know
      about the parse at, and to left of, the current position.
      This means that Marpa
      also knows exactly what symbols can lead to a successful parse,
      and can stop as soon as it knows it cannot find one.
    </p><p>
      In the Ruby Slippers technique, we arrange for parsing to stop
      whenever we reach a point where we are trying to read an input which
      would cause parsing to fail.
      The applications next
      asks Marpa, "OK.  What input would allow the
      parse to continue?"
      The application then uses this information to provide
      Marpa with the input it is looking for.
      In this case,
      <tt>bracket.pl</tt>
      concocts a virtual token which fixes the mismatch
      of brackets.
      Whatever the missing bracket may be,
      <tt>bracket.pl</tt>
      invents a bracket of that kind,
      and adds it to the virtual input.
      This done, parsing,
      and error detection
      can proceed as if there was no problem.
      Of course,
      the error which made the Ruby Slippers token necessary
      is recorded, and those records are the source of the
      error reports we saw above.
    </p>
    <p>
      To make its error messages as informative as possible
      in the case of missing closing brackets,
      <tt>bracket.pl</tt>
      needs to report the exact location of
      the opening bracket.
      Left-eideticism again comes in handy here.
      Once the virtual closing bracket is supplied to Marpa,
      <tt>bracket.pl</tt>
      asks, "That bracketed text that I just closed -- where did it begin?"
      The Marpa parser tracks the start location
      of all symbol and rule instances,
      so it is able to provide the application
      with the exact location of
      the starting bracket.
    </p><p>
      Finally, but importantly,
      when
      <tt>bracket.pl</tt>
      encounters a problem, at a point where there are unclosed opening
      brackets, it has two choices.
      It can be optimistic or it can be pessimistic.
      "Optimistic" means it can hope that something later in the input will close
      the opening bracket.
      "Pessimistic" means it can decide that "all bets are off" and use
      Ruby Slippers tokens to close all the currently active open brackets.
    </p><p>
      While the optimistic strategy sounds better, in practice
      the pessimistic one seems to provide better diagnostics.
      The pessimistic strategy does report some fixable problems
      as errors.
      But the optmistic one can introduce spurious fixes.
      These hide the real errors,
      and missing errors is worse than overreporting them.
      Even when the pessimistic strategy overreports,
      its first error messages will always accurately identify a
      a problem location.
    </p>
    <h3>Implications</h3>
    <p>
      While this utility is already useful, I think of it as a prototype for what could be done.
      This problem -- matching delimiters --
      is in fact very general, and I believe these techniques have very wide application.
    </p>
    <h3>For more</h3>
    <p>
      For more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>.
    </p>
  </body>
</html>
