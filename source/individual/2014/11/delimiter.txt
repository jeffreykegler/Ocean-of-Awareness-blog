Reporting mismatched delimiters
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p><p>Computer languages need to identify
      strings which need to treated as a single piece.
      (Very often,
      these pieces are often composed of other pieces.)
      One way to mark the pieces is with pairs of delimiters,
      one marking the start and the other the end of the various
      pieces of text.
    </p><p>
      Delimiters can take many forms.
      In the sense I am using the work "delimiter"
      quote marks, parentheses, curly braces and square brackets
      are all delimiters.
      XML and HTML tags are also delimiters,
      and they are complex enough for the delimiters themselves
      to have an internal syntax which contains delimited text.
    </p>
    <p>
      Delimiters are powerful,
      and mismatching them is a common mistake,
      an error which traditional parsers are often poor at reporting.
      This post outlines a method for more accurate
      reporting of mismatched delimiters.
    </p><p>
      I will demonstrate this technique with an example.
      While intended to demonstrate what can be done,
      it is a useable tool --
      you can use it immediately to check files for mismatched brackets.
    </p>
    <h3>The example script</h3>
    <p>The example script
      is a utility that reports mismatched brackets in the set:
      <tt>() {} []</tt>:
      round brackets (parentheses), square bracets,
      and curly brackets (braces),
      They are required to nest in the usual way.
      The rest of the text is treated as filler.
      This example will not
      be smart about other things,
      such as strings or comments in whatever language is of
      interest to you.
    </p><p>
      For purposes of demonstrating the technique,
      this example is kept relatively simple --
      simple enough that a recursive descent parser, for
      example, might be able to emulate it.
      I hope the reader who goes on to investigate the details
      will see that,
      unlike solutions that use traditional parsers,
      this one scales.
    </p>
    <p>
      It was written as a demo, but is quite useable as it is --
      you may find it more accurate than the native compiler/interpreter for your language.
    </p>
    <p>
      To be sure, ultimately it comes down to the programmer's intent,
      but I think you'll find this utility is highly accurate in most practical situations.
      The formatting of the reports is (I hope) helpful.
      For the string '((([))', the diagnostics are:
    </p><blockquote><pre>
* Line 1, column 1: Opening '(' never closed, problem detected at end of string
((([))
^
====================
* Line 1, column 4: Missing close ], problem detected at line 1, column 5
((([))
   ^^
</pre></blockquote>
    <p>
      Marpa is left-eidetic --
      it knows everything about the parse to the left of the current position, and the utility exploits this.
      For the string '[({({x[]x{}x()x)})]',
      it spots the extra closing ')' at column 16, but it's also able to tell *why* it's wrong.
      It cannot accept the ')' at column 16, without first closing the set of curly braces started at column 5.
      Maybe your compiler is giving you this sort of feedback, but I doubt it.
    </p>
    <blockquote><pre>
* Line 1, column 5: Missing close }, problem detected at line 1, column 16
[({({x[]x{}x()x)})]
    ^          ^
</pre></blockquote>
    <p>
      While this utility is already useful, I think of it as a prototype for what could be done.
      This problem -- matching delimiters --
      is in fact very general, and I believe these techniques have very wide application.
    </p>
    <h3>How it works</h3>
    <p>
      It works using the Ruby Slippers.
      t uses the new rejection events to stop parsing whenever the parser rejects all lexemes, so that the application can dummy up a new "Ruby Slippers" token.
      It makes its best guess as to how to correct the problem and proceeds.
      This makes the parse "self-correcting",
      allowing the utility to accurately diagnose a series of mismatched parentheses.
      Traditional parsers are usually hopeless after the first mismatch, and not any too clever about the first one.
    </p>
    <h3>For more</h3>
    <p>
      For more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>.
    </p>
  </body>
</html>
