<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 15 Oct 2012</h3>
<br />
<center><a name="config_html2"> <h2>A configurable HTML parser, part 2</h2> </a>
</center>
    <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment
      -->
      My last post introduced Marpa::R2::HTML,
      a configurable HTML parser.
      By editing a configuration file,
      the user can change,
      over a very wide range,
      the variant of HTML
      that Marpa::R2::HTML parses.
      The previous post showed one of the simplest variations --
      the ability to specify the contents of new tags,
      and the context in which they can appear.
      <p>
      This post is about a more aggressive variation of
      the HTML grammar -- the ability to change the contents
      of the HTML body (the
      <tt>&lt;body&gt;</tt>
      element).
      <h3>Is changing the definition of the HTML body useful?</h3>
      Marpa::R2::HTML allows changing the contents of all pre-existing
      element, with the exception of the highest level one --
      the 
      <tt>&lt;html&gt;</tt> element itself.
      This can be more impressive than utilitarian,
      but in the case of the
      <tt>&lt;body&gt;</tt>
      element there is a real case to be made for allowing the
      application to choose.
      <h3>Can text appear directly in an HTML body?</h3>
      <p>Can text appear directly in an HTML
      <tt>&lt;body&gt;</tt>
      element?
      That is, must text inside an HTML
      <tt>&lt;body&gt;</tt>
      be part of one of its child elements,
      or can it be directly part of the contents
      of the 
      <tt>&lt;body&gt;</tt> element?
      <p>
      If you want an
      answer strictly according to the standards,
      then you get your choice in the matter.
      According the 
      <a href="http://www.w3.org/TR/1999/PR-html40-19990824/sgml/dtd.html#inline">
        HTML 4.01 Strict DTD</a>,
	the 
      <tt>&lt;body&gt;</tt> contains a "block flow",
      which means that
	the answer is "No, text must be in the contents of a child element".
	Implementations of HTML were encouraged to be liberal, however,
	and in practice so much of the HTML out there has text directly
	in
      <tt>&lt;body&gt;</tt> elements,
      that a browser is expected to allow it.
      <p>
	Recognizing existing practice,
	HTML 5 changed to require conforming implementations to
	allow text to be interspersed with the block flow,
	in what I call a "mixed flow".
      A mixed flow can directly contain blocks and text,
      as well as inline elements.
      (The inline vs. block element distinction is basic to HTML parsing.
      See my earlier post or
      <a href="http://en.wikipedia.org/wiki/HTML_element">
      the well-organized Wikipedia page on HTML elements</a>.)
      <h3>Block or mixed flow?</h3>
      In parsing HTML, do you want to treat the body as a block flow or a mixed flow?
      Here are some of the factors.
      <ul>
      <li>Common practice requires accepting a mixed flow.
      <li>Careful practice suggests writing a block flow.
      <li>HTML 4.01 requires block, but suggests being liberal.
      <li>HTML 5 requires that a mixed flow be accepting,
      but also requires that it be displayed as if it was blocked into
      paragraphs, and suggests that blocking be used to eliminate
      ambiguities.
      </ul>
      <h3>Examples</h3>
<h4>Body contains mixed flow</h4>
      Two examples parses will illustrate what I mean.
      The first uses a a block-flow
      <tt>&lt;body&gt;</tt>,
      which is the default.
      Here is the pertinent line from the configuration file:
<blockquote><pre><tt>
&lt;body&gt; is *block
</tt></pre></blockquote>
This line says
that the 
<tt>&lt;body&gt;</tt>
element contains a block flow (<tt>*block</tt>).
Here the star is a sigil which suggests the repetition operator
of DTD's and regular expressions.
(Readers of my last post will notice I've changed the configuration
file syntax and will I hope find the new format an improvement.)
<p>For all of the examples in this post,
the HTML will be
<blockquote><pre><tt>
I cannot wait for a start tag&lt;p&gt;I can
</tt></pre></blockquote>
We run this through the <tt>marpa_r2_html_fmt --no-added-tag</tt>.
(The examples here were run using Marpa::R@ release 2.021_010.
There are part of its test suite as <tt>html/t/cfg_fmt.t</tt>.)
Here is the output:
<blockquote><pre><tt>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;
      I cannot wait for a start tag&lt;/p&gt;&lt;p>
      I can&lt;/p&gt;&lt;/body>
&lt;/html&gt;
</tt></pre></blockquote>
<p>In each example
      <p>
      Faced with all this,
      in my first implementation of the <tt>html_fmt</tt> utility,
      my grammar specified a mixed flow.
      In a second version,
      I decided that it produced a more precise parse if I was stricter in the grammar,
      and use the Ruby Slippers to "loosen things up",
      getting close, I hoped, to the best of both worlds.
      This second choice -- strict grammar and liberal Ruby Slippers --
      remains the default in the configurable version.
      <p>
      In this new configurable version,
      both the grammar and Ruby Slippers are configurable,
      and the user gets to decide.
      A user may have a clear preference,
      or may want to use different configurations
      in different situations.
 
<h4>Body contains mixed flow</h4>
<blockquote><pre><tt>
&lt;body&gt; is *mixed
</tt></pre></blockquote>
<blockquote><pre><tt>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    I cannot wait for a start tag&lt;p&gt;
      I can&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</tt></pre></blockquote>

<h4>Body contains inline flow</h4>
<blockquote><pre><tt>
&lt;body&gt; is *inline
</tt></pre></blockquote>
<blockquote><pre><tt>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    I cannot wait for a start tag&lt;!--
        html_fmt: Next line is cruft
      --&gt;&lt;p&gt;I can&lt;/body&gt;
&lt;/html&gt;
</tt></pre></blockquote>

<h4>Body is empty</h4>
<blockquote><pre><tt>
&lt;body&gt; is *empty
</tt></pre></blockquote>
<blockquote><pre><tt>
$test_config =~ s{^ \s* [<][/]body[>] \s [^\n]* $}{}xms;
$test_config =~ s{  [<][/]body[>] }{}gxms;
$expected_output = <<'END_OF_EXPECTED_OUTPUT';
<blockquote><pre><tt>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;&lt;body&gt;&lt;!--
      html_fmt: Next line is cruft
    --&gt;I cannot wait for a start tag&lt;!--
      html_fmt: Next line is cruft
    --&gt;&lt;p&gt;&lt;!--
      html_fmt: Next line is cruft
    --&gt;I can&lt;/html&gt;
</tt></pre></blockquote>
<br />
<p>posted at: 18:50 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html2.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 08 Oct 2012</h3>
<br />
<center><a name="config_html"> <h2>A Configurable HTML Parser</h2> </a>
</center>
    <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment
      -->
      This post introduces an HTML parser which is both liberal and configurable.
      Currently available as a
      <a href="https://metacpan.org/release/JKEGL/Marpa-R2-2.021_006">
        part of a Marpa::R2 developer's release on CPAN</a>,
      the new Marpa::R2::HTML allows detailed
      configuration of new tags
      and respecification of the behavior of existing tags.
    </p><p>
      To show how a configurable HTML parser works,
      I will start with a simple task.
      Let's suppose we have a new tag, call it
      <code>
        &lt;acme&gt;</code>.
      The older, non-configurable version of Marpa, and most browsers,
      would recognize this tag.
      But they'd simply give it a default configuration,
      one which is usually very liberal --
      liberal meaning the tag is allowed to contain just about anything,
      and to go just about anywhere.
      A configurable parser allows us to specify the new tag's behavior
      more explicitly and strictly.
    </p><h3>
      Block vs. inline</h3><p>
      In this post
      I am going to assume that the reader knows,
      or will look up what he needs to know,
      about HTML.
      But block vs. inline is a essential HTML concept
      which is often ignored -- even
      <a href="http://en.wikipedia.org/wiki/HTML">
      the excellent Wikipedia page on HTML</a>
      does not define "inline", although it uses the term in the technical
      sense twice.
      Since the concept is also central to this post,
      let me briefly summarize it.
    </p><p>
      Quoting from the
      <a href="http://www.w3.org/TR/1999/PR-html40-19990824/sgml/dtd.html#inline">
        HTML 4.01 Strict DTD</a>,
    </p><blockquote>
      <pre>
      HTML has two basic content models:

        %inline;     character level elements and text strings
        %block;      block-like elements e.g. paragraphs and lists
</pre>
    </blockquote>
    <p>
      There is also what I will call a "mixed flow",
      which can contain anything that
      can appear in either a block or inline flow.
      (What I call a mixed flow is
      simply called a "flow"
      in the HTML 4.01 DTD.)
    </p><p>
      Significant in the examples are
      <code>
        &lt;p&gt;</code>,
      which is a block element that contains an inline flow and
      <code>
        &lt;span&gt;</code>,
      which is an inline element that contains an inline flow.
      The
      <code>
        &lt;body&gt;</code>
      tag is an important structural tag,
      which contains an block flow.
    </p><p>
      For simplicity I am following HTML 4.01 DTD.
      HTML 5
      uses radically different terminology and is more liberal
      in what it allows.
      Differences among standards are an important reason for
      an HTML parser to be configurable.
    </p>
    <h3>
      Controlling element context</h3>
    <h4>
      An inline element containing an inline flow</h4>
    <p>
      Let's define the
      <code>
        &lt;acme&gt;</code>
      tag
      to be an inline tag with inline contents.
      This is done by adding the following line to the
      Marpa::R2::HTML grammar configuration file:
    </p>
    <blockquote>
      <pre>
ELE_acme is a FLO_inline included in GRP_inline
</pre></blockquote><p>
      Let's take as our HTML, the following:
    </p>
    <blockquote>
      <pre>
&lt;acme&gt;-during-&lt;span&gt;-more inline stuff-&lt;p&gt;-new block-
</pre></blockquote>
    <p>
      With the following shell commands,
      we add the new line to
      <a href="https://gist.github.com/3869482">
        <code>
          default.cfg</code>,
        the default grammar configuration file</a>.
      We then use the
      <code>
        marpa_r2_html_fmt</code>
      utility
      that comes with Marpa::R2
      to parse the HTML.
    </p>
    <blockquote>
      <pre>
cp default.cfg test.cfg
echo "ELE_acme is a FLO_inline included in GRP_inline" &gt;&gt; test.cfg
echo '&lt;acme&gt;-during-&lt;span&gt;-more inline stuff-&lt;p&gt;-new block-' |
  marpa_r2_html_fmt --no-added-tag --compile test.cfg
</pre></blockquote>
    <p>
<code>marpa_r2_html_fmt</code> indents the HTML and
      adds missing tags
This will show us the structure of our small HTML document.
      Here is what we get:
    </p>
    <!-- examples/acme-inline-inline.out -->
    <blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;
      &lt;acme&gt;
        -during-&lt;span&gt;
          -more inline stuff-&lt;/span&gt;&lt;/acme&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <p>
      We see from this that the configuration took proper effect.
      Since the
      <code>
        &lt;acme&gt;</code>
      tag was configured as an inline element,
      it cannot go directly inside the
      the
      <code>
        &lt;body&gt;</code>.
      So a new
      <code>
        &lt;p&gt;</code>
      is created to contain the
      <code>
        &lt;acme&gt;</code>
      element.
      (A Marpa::R2::HTML configuration can also change
      the contents that are acceptable inside the
      <code>
        &lt;body&gt;</code>.
      For the moment, we'll keep it simple
      and accept as given that
      <code>
        &lt;body&gt;</code>
      contains a block flow.)
    </p><p>
      Similarly,
      since the
      <code>
        &lt;acme&gt;</code>
      tag contains an inline flow,
      it must end before the next
      <code>
        &lt;p&gt;</code>
      tag.
      The parser supplies an
      end tag for the
      <code>
        &lt;acme&gt;</code>
      element,
      and also
      closes the
      <code>
        &lt;p&gt;</code>
      paragraph that was
      started to hold the
      <code>
        &lt;acme&gt;</code>
      element.
    </p>
    <h4>
      A block element containing an inline flow</h4>
    <!-- examples/acme-block-inline.out -->
    <p>
      Our new configuration line can also specify that
      <code>
        &lt;acme&gt;</code>
      is a block element:
    </p><blockquote>
      <pre>
ELE_acme is a FLO_inline included in GRP_block
</pre></blockquote><p>
      The code to test this is very similar to that displayed above.
      It, and the scripts for all of this post's other examples,
      can be found
      <a href="https://gist.github.com/3870030">
        as a gist</a>.
      Here's the result:
    </p><blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/acme&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <p>
      Here the
      <code>
        &lt;acme&gt;</code>
      element is allowed in a block,
      so no new
      <code>
        &lt;p&gt;</code>
      element was needed to contain it.
      Since
      the
      <code>
        &lt;acme&gt;</code>
      element's contents are inline,
      the
      <code>
        &lt;acme&gt;</code>
      element still needed to be ended before
      the
      <code>
        &lt;p&gt;</code>
      tag in the actual input.
    </p>
    <h3>
      The grammar configuration file</h3>
    <p>
      Those who click through to look at
      <a href="https://gist.github.com/3869482">
        the grammar configuration file</a>
      may notice
      its length.
      Three pages.
      And almost half of those three pages
      are single-line descriptions of elements
      which are one or more of deprecated, obsolete
      or proprietary.
      Arguably the configuration file
      should be even shorter.
    </p><p>
      Other implementations of liberal HTML
      parsers spread the logic specifying the HTML
      variant across a considerably larger body of code,
      sometimes a vastly larger.
      This very much affects the cost of evolving and
      maintain the parser.
    </p><p>
      As for the configuration file's format at the moment:
      it is experimental.
      I can state from experience that it is
      quite serviceable,
      and fairly readable,
      but it could be more elegant.
    </p><h3>
      Controlling element content</h3>
    <h4>
      A block element containing a mixed flow</h4>
    <!-- examples/acme-block-mixed.out -->
    <p>
      We can also configure the contents of
      the
      <code>
        &lt;acme&gt;</code>
      element.
      This configuration line specifies a mixed flow.
    </p><blockquote>
      <pre>
ELE_acme is a FLO_mixed included in GRP_block
</pre></blockquote>
<p>And here is what we get:</p>
    <blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;p&gt;
        -new block-
      &lt;/p&gt;&lt;/acme&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <p>
      A mixed flow accepts any contents,
      so that the
      <code>
        &lt;acme&gt;</code>
      element's contents expand to include the
      entire body of the html document.
    </p>
    <h4>
      A block element containing a block flow</h4>
    <!-- examples/acme-block-block.out -->
<p>With this configuration line, we request a block
        flow for the contents:
      </p>
    <blockquote>
      <pre>
ELE_acme is a FLO_block included in GRP_block
</pre></blockquote>
    <p>
      The results:
    </p>
    <blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      &lt;p&gt;
        -during-&lt;span&gt;
          -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
        -new block-
      &lt;/p&gt;&lt;/acme&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <p>
      Here the
      <code>
        &lt;acme&gt;</code>
      element also spans the entire body of the HTML
      element,
      but because block flows are less liberal than
      mixed flows,
      the contents of the
      <code>
        &lt;acme&gt;</code>
      element have to be properly "packaged" inside
      block elements.
    </p>
    <h4>
      A block element containing PCDATA</h4>
    <!-- examples/acme-block-pcdata.out -->
    <p>
      We are getting progressively more restrictive with the contents
      of the
      <code>
        &lt;acme&gt;</code>
      element.
      We've already seen the example
      of an
      <code>
        &lt;acme&gt;</code>
      block element for inline contents.
      This configuration line specifies that the contents
      must be PCDATA.
      PCDATA allows text, but not child elements.
    </p><blockquote>
      <pre>
ELE_acme is a FLO_pcdata included in GRP_block
</pre></blockquote><p>
      The result:
    </p><blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;/acme&gt;&lt;p&gt;
      &lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <p>
      Note here that the
      <code>
        &lt;acme&gt;</code>
      tag ends as soon as another element is encountered.
    </p><h4>
      An empty block element</h4>
    <p>
      The final restriction on the
      <code>
        &lt;acme&gt;</code>
      element is the insistance that it be empty:
      <!-- examples/acme-block-empty.out -->
    </p><blockquote>
      <pre>
ELE_acme is a FLO_empty included in GRP_block
</pre></blockquote>
      <p>
        And here is our result:</p>
    <blockquote>
      <pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
    &lt;/acme&gt;&lt;p&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
    <h3>
      Displayed effects</h3>
    <p>
      Any of these different configurations of
      the
      <code>
        &lt;acme&gt;</code>
      tag could have a dramatic effect on what is displayed,
      depending on your CSS file.
      Whether or not
      <code>
        &lt;acme&gt;</code>
      is a block element also affects
      what is displayed.
      When
      <code>
        &lt;acme&gt;</code>
      is a block element,
      its boundaries will typically display as paragraph breaks.
    </p>
    <p>
      In the above examples,
      the case where
      <code>
        &lt;acme&gt;</code>
      is configured as a block element containing PCDATA
      typically displays as three paragraphs:
    </p><pre>
-during-

-more inline stuff-

-new block-
</pre>
    <!-- html_fmt: Next line is cruft -->
    </p>
    <p>
      In the other cases, the end boundary of the
      <code>
        &lt;acme&gt;</code>
      element varies,
      but always coincides with the beginning or
      end of other block elements,
      so that the visible display is as
      two paragraphs:
    </p><pre>
-during- -more inline stuff-

-new block-
</pre>
    <!-- html_fmt: Next line is cruft -->
    </p>
    <h3>
      Final remarks</h3><p>
      The configurable Marpa::R2::HTML does considerably more than
      could be mentioned in this post.
      I hope to say more about it soon.
      Comments on this post can be sent to the Marpa Google Group:
      <code>
        marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 17:46 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Fri, 14 Sep 2012</h3>
<br />
<center><a name="quantum"> <h2>Parsing on your new hyper-quantum computer</h2> </a>
</center>
    <blockquote>
      <!--
      perl ./marpa_r2_html_fmt
      -->
      <i>
        If you want to build a ship, don't drum up the men to gather wood,
        divide the work and give orders. Instead, teach them to yearn for
        the vast and endless sea.</i>
      -- Antoine de Saint-Exupery
    </blockquote>
    <p>
      Imagine that, the day the new machine arrives,
      you are maintaining a parser.
      Your parser
      is the current state of the art
      -- hand-written recursive descent.
    </p><p>
    </p>
    The new computer will
    replace your staid old von Neumann box is not
    just a quantum computer.
    It's fully non-deterministic.
    You can superposition any time you'd like,
    and then "unsuperposition" to restart.
    And when superpositioning, you can can examine
    <strong>
      all</strong>
    the possibilities, not just one.
    <p>
      How would you rewrite your
      recursive descent logic to take advantage of this new hyper-quantum computer?
      Actually, this is exactly the same question that
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>
      poses
      to you today.
      Because for all classes of grammar in practical use, including
      the LL(k) grammars parseable by recursive descent,
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>
      is efficient non-determinism.
    </p>
    <p>
      Your new hyper-quantum computer
      might seem at first to make your work as a programmer harder.
      On the hyper-quantum computer,
      many things are happening at once.
      On the deterministic box,
      you were dealing with a single procedural thread.
    </p>
    <p>
      But as you get used to the new non-deterministic computer,
      you find ways in which it makes things easier.
      On the deterministic box,
      you only needed to follow a single thread,
      but you often needed to make that thread
      deal with multiple alternatives.
      To do this, you had to create
      state information and keep track of it yourself
      while backtracking.
      The complexity of dealing with
      all this roll-your-own state
      information severely limited the kinds of grammar that you could parse,
      and even the extent to which you understood exactly what your parser
      would and would not accept.
      Since much of the time on your old parser was spent
      backtracking,
      you no longer had a real handle on the
      time complexity in many sections of your code.
      In a couple of previous releases,
      minor changes had let the backtracking get out of hand.
    </p>
    <p>
      The hyper-quantum computer
      now comes up with the parsing
      alternatives for you.
      True, you have to retrain yourself to think in terms of the alternatives
      available at any point.
      But you don't even have to know which alternatives are there --
      if you need to ask the hyper-quantum computer (or
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>),
      <a href="https://metacpan.org/module/Marpa::R2::Progress">
        it can tell you</a>.
    </p>
    <p>
      You do have to learn to ask the right questions
      at the right places.
      Once you do this,
      you have a simpler and more cleanly written parser,
      running at comparable or faster speeds.
      And you begin to think about a few changes to
      the language,
      changes that will make your language more
      natural and expressive,
      but one which
      you could not have parsed before.
    </p>
<br />
<p>posted at: 21:38 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/quantum.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Thu, 13 Sep 2012</h3>
<br />
<center><a name="html_fmt"> <h2>A Marpa-based HTML reformatter</h2> </a>
</center>
    <p>
      <!--
      perl ./marpa_r2_html_fmt
      -->
      This post is about
      <tt>
        html_fmt</tt>,
      a
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa-</a>based
      reformatter ("tidier") for liberal HTML.
      <tt>
        html_fmt</tt>
      indents HTML according to the structure of the document,
      which makes the HTML a lot easier to read.
      In the process
      <tt>
        html_fmt</tt>
      adds missing start and end tags and identifies "cruft".
    </p>
    <p>
      <tt>
        html_fmt</tt>
      is ultra-liberal about its input.
      Like a browser's rendering engine,
      <tt>
        html_fmt</tt>
      never rejects a file,
      no matter how defective it is as an HTML document.
      An interesting experiment would be to compare what your
      favorite browser does with a random text file feed to
      it directly,
      with what it does to the same file
      after it has been passed through
      <tt>
        html_fmt</tt>.
    </p>
    <p>
      <tt>
        html_fmt</tt>
      is a by-product of moving
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        this blog to Github</a>.
      In the course of bringing over
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">
        my old posts</a>,
      I wanted a filter that would tidy them up,
      so I turned to an old demo script I'd written.
      The old demo's usefulness was a pleasant surprise,
      but it lacked two features.
      First, it wouldn't read from standard input.
      Second, in formatting the HTML, it introduced new whitespace.
      The first problem was easy to fix.
      Fixing the second involved coming up with a
      "lowest common denominator" for whitespace treatment
      among browsers and HTML variants.
    </p>
    <p>
      The result,
      <tt>
        html_fmt</tt>,
      works very well as the first step in dealing with HTML
      that you are rewriting by hand.
      One quick pass-through and your file is much easier to read,
      has all the proper tags,
      and has comments pointing out any "cruft" that's there.
    </p>
    <p>
      A production quality "tidier" would need to be something like
      <tt>
        gnuindent</tt>
      --
      bristling with options.
      <tt>
        html_fmt</tt>
      so far has only two options,
      one dealing with whitespace before end tags,
      the other allowing
      a choice of strategies for avoiding added whitespace.
      (One strategy uses comments, while the other simply leaves
      the whitespace-sensitive locations as-is.)
      These two options are not nearly
      sufficient to deal with the full
      range of whitespace issues,
      never mind anything else.
    </p>
    <p>
      But from a
      <a href="http://blog.plover.com/oops/blosxom-sux.html">
        "Worse is Better"</a>
      point of view,
      <tt>
        html_fmt</tt>
      is a good start.
      It is 600 lines,
      short enough to find your
      way around in,
      particularly once you've deleted the parts you don't like.
      And its underlying Marpa-based interface is documented:
      <a href="https://metacpan.org/module/Marpa::R2::HTML">
        Marpa::R2::HTML</a>.
      Marpa::R2::HTML is beta, but has been stable for some time.
    </p>
    <p>
      <a href="https://gist.github.com/3725639">
      <tt>
        html_fmt</tt>
      is now available as a gist.</a>
      In a future release of
      <a href="https://metacpan.org/release/Marpa-R2">
        Marpa::R2</a>,
      it will be available as the
      <tt>
        marpa_r2_html_fmt</tt> script.
      But why wait until then to fork it?
    </p>
<br />
<p>posted at: 20:08 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/html_fmt.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 03 Sep 2012</h3>
<br />
<center><a name="r2_is_beta"> <h2>Marpa::R2 is beta</h2> </a>
</center>
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
is now beta.
Marpa is a new parsing algorithm,
based on decades of prior art.
It is a practical and efficient solution
targeted at all parsing problems that are too
complex for regular expressions.
<p>
The
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
module is the most recent Marpa module.
Marpa is also available as the
<a href="https://metacpan.org/release/Marpa-XS">
Marpa::XS</a>
module,
which is stable and bug-fix only.
Both Marpa modules:
<ol>
<li><p>Parse everything you can write in BNF.
<li><p>
Parse all
classes of grammar in practical use today in linear time.
<li><p>Parse all BNF grammars
in times considered theoretically optimal.
For unambiguous grammars, Marpa is never worse than
O(n<sup>2</sup>).
For ambiguous grammars, Marpa is never worse than
O(n<sup>3</sup>).
Marpa never goes exponential.
<li><p>
Are fully aware, at every point in the parse, of
all the rules they are parsing,
how far into them they have proceeded,
and of what tokens they expect next.
Especially with Marpa::R2,
this information is available
to the application
conveniently and efficiently.
<li><p>
Do not need to be handwritten.
Marpa is available as a open-source library.
It is written in C,
and the C library can be used
<a href="http://jeffreykegler.github.com/Marpa/libmarpa.html">
directly</a>
or via
<a href="https://metacpan.org/release/Marpa-R2">
a Perl interface</a>.
<li><p>
For general BNF parsing,
do not require
the user to craft
a lookahead or backtracking strategy -- Marpa
does not use lookahead and never backtracks.
<li><p>
Come
with the traditional theoretical apparatus of
proofs based on prior literature.
</ol>
<p>
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
is a major rewrite of the Marpa internals.
The most visible of these changes:
<ol>
<li><p>Marpa::R2 is faster.
<li><p>Marpa::R2 is easier to install.
In particular the dependency on Glib has been removed.
Marpa::R2 now has no non-core CPAN dependencies.
<li><p>Marpa::R2's internal symbols are now invisible
to the user, even when tracing and debugging.
<li><p>
<a href="http://jeffreykegler.github.com/Marpa/libmarpa">
Libmarpa, the C library which is at the core of Marpa</a>,
is now documented
and separately installable.
(Libmarpa remains alpha at this point.)
<li><p>Another new documented interface,
<a href="https://metacpan.org/module/Marpa::R2::Advanced::Thin">
Marpa::R2::Thin</a>,
is a "thin" interface to Libmarpa from Perl.
(Marpa::R2::Thin remains alpha at this point.)
</ol>
<br />
<p>posted at: 17:16 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/r2_is_beta.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
