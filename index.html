<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Tue, 02 Oct 2018</h3>
<br />
<center><a name="popularity"> <h2>Measuring language popularity</h2> </a>
</center>
<html>
  <head>
  </head>
  <body style="max-width:850px">
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <h2>Language popularity</h2>
    <p>
      <a href="https://github.com/github/linguist">Github's
        linguist</a>
      is seen as the most trustworthy tool
      for estimating language popularity<a id="footnote-1-ref" href="#footnote-1">[1]</a>,
      in large part because it reports its result as
      the proportion of code in a very large dataset,
      instead of web hits or searches.<a id="footnote-2-ref" href="#footnote-2">[2]</a>
      It is ironic, in this context,
      that
      <tt>linguist</tt>
      avoids looking at the code,
      preferring to use
      metadata -- file name and the vim and shebang lines.
      Scanning the actual code is <tt>linguist</tt>'s last resort.<a id="footnote-3-ref" href="#footnote-3">[3]</a>
    </p>
    <p>How accurate is this?
      For files that are mostly in a single programming language,
      currently the majority of them,
      <tt>linguist</tt>'s method are probably very accurate.
    </p>
    <p>But literate programming often requires mixing languages.
      It is perhaps an extreme example,
      but much of the code used in this blog post
      comes from a Markdown file, which contains both C and Lua.
      This code is "untangled" from the Lua by ad-hoc scripts<a id="footnote-4-ref" href="#footnote-4">[4]</a>.
      In my codebase,
      <tt>linguist</tt>
      indentifies this code simply
      as Markdown.<a id="footnote-5-ref" href="#footnote-5">[5]</a>
      <tt>linguist</tt>
      then ignores it,
      as it does all documentation files.<a id="footnote-6-ref" href="#footnote-6">[6]</a>.
    </p>
    <p>Currently, this kind of homegrown
      literate programming may be so rare
      that it is not worth taking into account.
      But if literate programming becomes more popular,
      that trend might well slip under
      <tt>linguist</tt>'s radar.
      And even those with a lot of faith in
      <tt>linguist</tt>'s numbers should be happy to
      know they could be confirmed by more careful methods.
    </p>
    <h2>Token-by-token versus line-by-line</h2>
    <p><tt>linguist</tt> avoids reporting results based on looking at the code,
    because careful line counting for multiple languages
      cannot be done with traditional parsing methods.<a id="footnote-7-ref" href="#footnote-7">[7]</a>
      To do careful line counting,
      a parser must be able to handle ambiguity in several forms --
      ambiguous parses, ambiguous tokens, and overlapping variable-length tokens.
    </p>
    <p>
      The ability to deal with
      "overlapping variable-length tokens" may sound like a bizarre requirement,
      but it is not.
      Line-by-line languages (BASIC, FORTRAN, JSON, .ini files, Markdown)
      and token-by-token languages (C, Java, Javascript, HTML)
      are both common,
      and even today commonly occur in the same file (POD and Perl,
      Haskell's Bird notation, Knuth's CWeb).
    </p>
    <p>
      Deterministic parsing can switch back and forth,
      though at the cost of some very hack-ish code.
      But for careful line counting,
      you need to parse line-by-line and token-by-token
      simultaneously.
      Consider this example:
    </p>
    <pre><tt>
    int fn () { /* for later
\begin{code}
   */ int fn2(); int a = fn2();
   int b = 42;
   return  a + b; /* for later
\end{code}
*/ }
    </tt></pre>
    <p>A reader can imagine that this code is part of a test case using code
      pulled from a LaTeX file.
      The programmer wanted to indicate the copied portion of code,
      and did so by commenting out its original LaTeX delimiters.
      GCC compiles this code without warnings.
    </p>
    <p>It is not really the case that LaTeX is a line-by-line language.
      But in literate programming systems<a id="footnote-8-ref" href="#footnote-8">[8]</a>,
      it is usually required that the
      <tt>\begin{code}</tt>
      and
      <tt>\end{code}</tt>
      delimiters begin at column 0,
      and that the code block between them be a set of whole lines so,
      for our purposes in this post,
      we can treat LaTeX as line-by-line.
      For LaTeX, our parser finds
    </p><pre><tt>
  L1c1-L1c29 LaTeX line: "    int fn () { /* for later"
  L2c1-L2c13 \begin{code}
  L3c1-L5c31 [A CODE BLOCK]
  L6c1-L6c10 \end{code}
  L7c1-L7c5 LaTeX line: "*/ }"<a id="footnote-9-ref" href="#footnote-9">[9]</a>
</tt></pre><p>
      Note that in the LaTeX parse, line alignment is respected perfectly:
      The first and last are ordinary LaTeX lines,
      the 2nd and 6th are commands bounding the code,
      and lines 3 through 5 are a code block.
    </p>
    <p>
      The C tokenization, on the other hand,
      shows no respect for lines.
      Most tokens are a small part of their line,
      and the two comments start in the middle of
      a line and end in the middle of one.
      For example, the first comment starts at column 17
      of line 1 and ends at column 5 of line 3.<a id="footnote-10-ref" href="#footnote-10">[10]</a>
    </p>
    <p>What language is our example in?
    Our example is long enough to justify classification,
    and it compiles as C code.
    So it seems best to classify this example as C code<a id="footnote-11-ref" href="#footnote-11">[11]</a>.
    Our parses give us enough data for a heuristic
    to make a decision capturing this intuition.<a id="footnote-12-ref" href="#footnote-12">[12]</a>
    </p>
    <h2>Earley/Leo parsing and combinators</h2>
    <p>In a series of previous posts<a id="footnote-13-ref" href="#footnote-13">[13]</a>,
      I have been developing a parsing method that
      integrates
      Earley/Leo parsing and combinator parsing.
      Everything in my previous posts is available
      in <a href=
      "https://metacpan.org/pod/distribution/Marpa-R2/pod/Marpa_R2.pod"
      >Marpa::R2</a>,
      which was Debian stable as of jessie.
    </p>
    <p>
      The final piece, added in this post, is the
      ability to use variable length subparsing<a id="footnote-14-ref" href="#footnote-14">[14]</a>,
      which I have just added to Marpa::R3,
      Marpa::R2's successor.
      Releases of <a href=
      "https://metacpan.org/pod/release/JKEGL/Marpa-R3-4.001_053/pod/Marpa_R3.pod"
      >Marpa::R3</a>
      pass a full test suite,
      and the documentation is kept up to date,
      but R3 is alpha, and the usual cautions<a id="footnote-15-ref" href="#footnote-15">[15]</a>
      apply.
    </p>
    <p>Earley/Leo parsing is linear for a superset
    of the LR-regular grammars,
    which includes all other grammar classes in practical use,
    and Earley/Leo allows the equivalent of infinite lookahead.<a id="footnote-16-ref" href="#footnote-16">[16]</a>
    When the power of Earley/Leo gives out,
    Marpa allows combinators (subparsers)
    to be invoked.
    The subparsers can be anything, including
    other Earley/Leo parsers,
    and they can be called recursively<a id="footnote-17-ref" href="#footnote-17">[17]</a>.
    Rare will be the grammar of practical interest that
    cannot be parsed with this combination of methods.
    </p>
    <h2>The example</h2>
    <p>The code that ran this example is <a href=
    "https://github.com/jeffreykegler/Marpa--R3/tree/08fa873687130fcfbe199a5f573375ad11322f3a/pub/varlex"
    >available on Github</a>.
      In previous posts,
      we gave larger examples<a id="footnote-18-ref" href="#footnote-18">[18]</a>,
      and our tools and techniques have scaled.
      We expect that the variable-length subparsing
      feature will also scale -- while it was not available in
      Marpa::R2, it is not in itself new.
      Variable-length tokens have been available in other Marpa interfaces for
      years and they were described in Marpa's theory paper.<a id="footnote-19-ref" href="#footnote-19">[19]</a>.
    </p>
    <p>
      The grammars used in the example of this post are minimal.
      Only enough LaTex is implemented
      to recognize code blocks; and
      only enough C syntax is implemented to recognize comments.
    </p>
    <h2>The code, comments, etc.</h2>
    <p>To learn more about Marpa,
      a good first stop is the
      <a href="http://savage.net.au/Marpa.html">semi-official web site, maintained by Ron Savage</a>.
      The official, but more limited, Marpa website
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">is my personal one</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
    </p>
    <h2>Footnotes</h2>
<p id="footnote-1"><b>1.</b>
	This github repo for <tt>linguist</tt> is <a href=
	"https://github.com/github/linguist/"
	>https://github.com/github/linguist/</a>.
 <a href="#footnote-1-ref">&#8617;</a></p>
<p id="footnote-2"><b>2.</b>
	Their methodology is often left vague,
	but it seems safe to say the careful line-by-line counting
	discussed in this post
	goes well beyond the techniques used in
	the widely-publicized lists of "most popular programming
	languages". 
	<br><br>
	In fact, it seems likely these measures do not use line
	counts at all,
	but instead report the sum of blob sizes.
	Github's <tt>linguist</tt> does give a line count but
	Github does not vouch for its accuracy:
"if you really need to know the lines of code of an entire repo, there are much better tools for this than Linguist."
        (Quoted from
        <a href=
	"https://github.com/github/linguist/issues/3131"
	>the resolution of
	Github linguist issue #1331</a>.)
	The Github API's <tt>list-languages</tt> command reports language sizes
	in bytes.
	The <a href=
	  "https://developer.github.com/v3/repos/#list-languages"
	>API documentation</a>
	is vague, but it seems the counts are the
	sum of blob sizes,
	with each blob classed as one and only one language.
	<br><br>
	Some tallies seem even more coarsely grained than this --
	they are not even blob-by-blob,
	but assign entire repos to the "primary language".
	For more, see
        <a href="https://techcrunch.com/2018/09/30/what-the-heck-is-going-on-with-measures-of-programming-language-popularity/">
          Jon Evan's
          <cite>Techcrunch</cite>
          article</a>;
	  and <a href=
	  "https://www.benfrederickson.com/ranking-programming-languages-by-github-users/"
	  >Ben Frederickson's project</a>.
 <a href="#footnote-2-ref">&#8617;</a></p>
<p id="footnote-3"><b>3.</b>
        <tt>linguist</tt>'s methodology is described in its README.md
	(<a href=
	"https://github.com/github/linguist/blob/8cd9d744caa7bd3920c0cb8f9ca494ce7d8dc206/README.md"
	>permalink as of 30 September 2018</a>).
 <a href="#footnote-3-ref">&#8617;</a></p>
<p id="footnote-4"><b>4.</b>
        This custom literate programming system is not documented or packaged,
	but those who cannot resist taking a look can find the Markdown
	file it processes <a href=
	"https://github.com/jeffreykegler/Marpa--R3/blob/f16ef5798986da69fa8b437edc3930ce2cebd498/cpan/kollos/kollos.md"
	>here</a>,
	and its own code <a href=
	"https://github.com/jeffreykegler/Marpa--R3/blob/f16ef5798986da69fa8b437edc3930ce2cebd498/cpan/kollos/miranda">
	here</a>
	(permalinks accessed 2 October 2018).
 <a href="#footnote-4-ref">&#8617;</a></p>
<p id="footnote-5"><b>5.</b>
        For those who care about getting
        <tt>linguist</tt>
        as
        accurate as possible.
        there is a workaround:
        the
        <tt>linguist-language</tt>
        git attribute.
        This still requires that each blob be 
	reported as containing lines of only one language.
 <a href="#footnote-5-ref">&#8617;</a></p>
<p id="footnote-6"><b>6.</b>
        For the treatment of Markdown, see
        <tt>linguist</tt>
        <a href="https://github.com/github/linguist/blob/8cd9d744caa7bd3920c0cb8f9ca494ce7d8dc206/README.md#my-repository-isnt-showing-my-language">README.md</a>
        (permalink accessed as of 30 September 2018).
 <a href="#footnote-6-ref">&#8617;</a></p>
<p id="footnote-7"><b>7.</b>
        Another possibility is a multi-scan approach -- one
        pass per language.
        But that is likely to be expensive.
        At last count there were 381 langauges in
        <tt>linguist</tt>'s
        database.
        Worse, it won't solve the problem:
        "liberal" recognition even of a single language
        requires more power than available from
        traditional parsers.
 <a href="#footnote-7-ref">&#8617;</a></p>
<p id="footnote-8"><b>8.</b>
      For example, these line-alignment requirements match 
      those in
      <a href=
      "https://www.haskell.org/onlinereport/haskell2010/haskellch10.html"
      >Section 10.4</a> of the 2010 Haskell Language Report.
 <a href="#footnote-8-ref">&#8617;</a></p>
<p id="footnote-9"><b>9.</b>
  Adapted from
  <a href=
  "https://github.com/jeffreykegler/Marpa--R3/blob/08fa873687130fcfbe199a5f573375ad11322f3a/pub/varlex/idlit_ex2.t#L83"
  >test code in Github repo</a>, permalink accessed 2 October 2018.
 <a href="#footnote-9-ref">&#8617;</a></p>
<p id="footnote-10"><b>10.</b>
      See the <a href=
      "https://github.com/jeffreykegler/Marpa--R3/blob/08fa873687130fcfbe199a5f573375ad11322f3a/pub/varlex/idlit_ex2.t#L44"
      >test file</a>
      on Gihub.
 <a href="#footnote-10-ref">&#8617;</a></p>
<p id="footnote-11"><b>11.</b>
    Some might think the two LaTex lines should be counted as LaTex and,
    using subparsing of comments, that heuristic can be implemented.
 <a href="#footnote-11-ref">&#8617;</a></p>
<p id="footnote-12"><b>12.</b>
    To be sure, a useful tool would want to include considerably more of
    C's syntax.
    It is perhaps not necessary to be sure that a file compiles
    before concluding it is C.
    And we might want to class a file as C in spite of a
    fleeting failure to compile.
    But we do want to lower the probably of a false positive.
 <a href="#footnote-12-ref">&#8617;</a></p>
<p id="footnote-13"><b>13.</b>
    <a href=
    "http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/csg.html"
    >Marpa and procedural parsing</a>;
    <a href=
    "http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator.html"
    >Marpa and combinator parsing</a>;
    and <a href=
    "http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html"
    >Marpa and combinator parsing 2</a>
 <a href="#footnote-13-ref">&#8617;</a></p>
<p id="footnote-14"><b>14.</b>
      There is <a href=
      "https://metacpan.org/pod/distribution/Marpa-R2/pod/Marpa_R2.pod"
      >documentation of the interface</a>,
      but it is not a good starting point
      for a reader who has just started to look at the Marpa::R3 project.
      Once a user is familiar with Marpa::R3 standard DSL-based
      interface,
      they can start to learn about its alternatives <a href=
      "https://metacpan.org/pod/release/JKEGL/Marpa-R3-4.001_053/pod/External/Basic.pod"
      >here</a>.
 <a href="#footnote-14-ref">&#8617;</a></p>
<p id="footnote-15"><b>15.</b>
        Specifically,
	since Marpa::R3 is alpha,
	its features are subject
        to change without notice, even between micro releases,
        and changes are made without concern for backward compatibility.
        This makes R3 unsuitable for a production application.
        Add to this that,
	while R3 is tested, it has seen much less
        usage and testing than R2, which has been very stable for
        some time.
 <a href="#footnote-15-ref">&#8617;</a></p>
<p id="footnote-16"><b>16.</b>
    Technically, a grammar is LR-regular if it can be parsed
    deterministically using a regular set as its lookahead.
    A "regular set" is a set of regular expressions.
    The regular set itself must be finite,
    but the regular expressions it contains
    can match lookaheads of arbitrary length.
 <a href="#footnote-16-ref">&#8617;</a></p>
<p id="footnote-17"><b>17.</b>
    See <a href=
    "http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html"
    >Marpa and combinator parsing 2</a>
 <a href="#footnote-17-ref">&#8617;</a></p>
<p id="footnote-18"><b>18.</b>
    The largest example is in <a href=
    "http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html"
    >Marpa and combinator parsing 2</a>
 <a href="#footnote-18-ref">&#8617;</a></p>
<p id="footnote-19"><b>19.</b>
 Kegler, Jeffrey. <cite>Marpa, A Practical General Parser: The Recognizer</cite>.
 <a href=
 "http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/KEGLER,%20Jeffrey%20-%20Marpa,%20a%20practical%20general%20parser:%20the%20recognizer.pdf"
>Online version accessed of 24 April 2018</a>.
The link is to the 19 June 2013 revision of the 2012 original.
 <a href="#footnote-19-ref">&#8617;</a></p>
  </body>
</html>
<br />
<p>posted at: 20:16 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/10/popularity.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Tue, 28 Aug 2018</h3>
<br />
<center><a name="rntz"> <h2>A Haskell challenge</h2> </a>
</center>
<html>
  <head>
  </head>
  <body style="max-width:850px">
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <h2>The challenge</h2>
    <p>
    A <a href="http://www.rntz.net/post/2018-07-10-parsing-list-comprehensions.html">recent
    blog post by Michael Arntzenius</a> ended with a friendly challenge to Marpa.
    Haskell list comprehensions are something that
    Haskell's own parser handles only with difficulty.
    A point of Michael's critique of Haskell's parsing was
    that Haskell's list comprehension could be even more powerful if not
    for these syntactic limits.
    </p>
    Michael wondered aloud if Marpa could do better.
    It can.
    </p>
    <p>The problem syntax occurs with the "guards",
    a very powerful facility of
    Haskell's list comprehension.
    Haskell allows several kinds of "guards".
    Two of these "guards" can have the same prefix,
    and these ambiguous prefixes can
    be of arbitrary length.
    In other words,
    parsing Haskell's list comprehension requires
    either lookahead of arbitrary length,
    or its equivalent.
    <p>
    <p>To answer Michael's challenge,
    I extended my Haskell subset parser to deal with
    list comprehension.
    That parser, with its test examples, is online.<a id="footnote-1-ref" href="#footnote-1">[1]</a>
    I have run it for examples thousands of tokens long and,
    more to the point,
    have checked the Earley sets to ensure that Marpa
    will stay linear,
    no matter how long the ambiguous prefix gets.<a id="footnote-2-ref" href="#footnote-2">[2]</a>
    </p>
    Earley parsing, which Marpa uses,
    accomplishes the seemingly impossible here.
    It does the equivalent of infinite lookahead efficiently,
    without actually doing any lookahead or
    backtracking.
    That Earley's algorithm can do this has been a settled
    fact in the literature for some time.
    But today Earley's algorithm is little known even
    among those well acquainted with parsing,
    and to many claiming the equivalent of infinite lookahead,
    without actually doing any lookahead at all,
    sounds like a boast of magical powers.
    </p>
    <p>
    In the rest of this blog post,
    I hope to indicate how Earley parsing follows more than
    one potential parse at a time.
    I will not describe Earley's algorithm in full.<a id="footnote-3-ref" href="#footnote-3">[3]</a>
    But I will show that no magic is involved,
    and that in fact the basic ideas behind Earley's method
    are intuitive and reasonable.
    </p>
    <h2>A quick cheat sheet on list comprehension</h2>
    <p>
    List comprehension in Haskell is impressive.
    Haskell allows
    you to build a list using a series of "guards",
    which can be of several kinds.
    The parsing issue arises because two of the guard types --
    generators and boolean expressions --
    must be treated quite differently,
    but can look the same over an arbitrarily long prefix.
    </p>
    <h3>Generators</h3>
    <p>Here is one example of a Haskell generator,
    from the test case for this blog post:
    </p>
    <pre><tt>
          list = [ x | [x, 1729,
		      -- insert more here
		      99
		   ] <- xss ] </tt><a id="footnote-4-ref" href="#footnote-4">[4]</a></pre>
    <p>
    This says to build a lists of <tt>x</tt>'s
    such that the guard
    <tt>[x, 1729, 99 ] &lt;- xss</tt>
    holds.
    The clue that this guard is a generator is the
    <tt>&lt;-</tt> operator.
    The <tt>&lt;-</tt> operator
    will appear in every generator,
    and means "draw from".
    </p>
    <p>
    The LHS of the <tt>&lt;-</tt> operator is a pattern
    and the RHS is an expression.
    This generator draws all the elements from <tt>xss</tt>
    which match the pattern <tt>[x, 1729, 99 ]</tt>.
    In other words, it draws out
    all the elements of <tt>xss</tt>,
    and tests that they
    are lists of length 3
    whose last two subelements are 1729 and 99.
    </p>
    <p>The variable <tt>x</tt> is set to the 1st subelement.
    <tt>list</tt> will be a list of all those <tt>x</tt>'s.
    In the test suite, we have
    <pre><tt>
    xss = [ [ 42, 1729, 99 ] ] </tt><a id="footnote-5-ref" href="#footnote-5">[5]</a></pre>
    </p>
    so that list becomes <tt>[42]</tt> -- a list
    of one element whose value is 42.
    </p>
    <h3>Boolean guards</h3>
    <p>Generators can share very long prefixes with Boolean guards.
    <pre><tt>
	list2 = [ x | [x, 1729, 99] &lt;- xss,
               [x, 1729,
                  -- insert more here
                  99
               ] == ys,
             [ 42, 1729, 99 ] &lt;- xss
             ] </tt><a id="footnote-6-ref" href="#footnote-6">[6]</a></pre>
    </p>
    <p>The expression defining <tt>list2</tt>
    has 3 comma-separated guards:
    The first guard is a generator,
    the same one as in the previous example.
    The last guard is also a generator.
    </p>
    <p>
    The middle guard is of a new type: it is a Boolean:
    <tt>[x, 1729, 99 ] == ys</tt>.
    This guard insists that <tt>x</tt> be such that the triple
    <tt>[x, 1729, 99 ]</tt> is equal to <tt>ys</tt>.
    </p>
    <p>
    In the test suite, we have
    <pre><tt>
    ys = [ 42, 1729, 99 ] </tt><a id="footnote-7-ref" href="#footnote-7">[7]</a></pre>
    so that <tt>list2</tt> is also
    <tt>[42]</tt>.
    </p>
    <h2>Boolean guards versus generators</h2>
    <p>From the parser's point of view, Boolean guards
    and generators start out looking the same --
    in the examples above, three of our guards start out
    the same -- with the string <tt>[x, 1729, 99 ]</tt>,
    but
    <ul>
    <li>in one case (the Boolean guard),
    <tt>[x, 1729, 99 ]</tt> is the beginning of an expression; and </li>
    <li>in the other two cases (the generators),
    <tt>[x, 1729, 99 ]</tt> is a pattern.</li>
    </ul>
    Clearly patterns and expressions can look identical.
    And they can look identical for an arbitrarily long time --
    I tested the <a href="https://www.haskell.org/ghc/">Glasgow Haskell Compiler</a>
    (GHC)
    with identical expression/pattern prefixes
    thousands of tokens in length.
    My virtual memory eventually gives out,
    but GHC itself never complains.<a id="footnote-8-ref" href="#footnote-8">[8]</a>
    (The comments "<tt>insert more here</tt>" show the points at which the
    comma-separated lists of integers can be extended.)
    </p>
    <h2>The problem for parsers</h2>
    <p>So Haskell list comprehension presents a problem for parsers.
    A parser must determine whether it is parsing an expression or
    a pattern, but it cannot know this for an arbitrarily long time.
    A parser must keep track of two possibilities at once --
    something traditional parsing has refused to do.
    As I have pointed out<a id="footnote-9-ref" href="#footnote-9">[9]</a>,
    belief that traditional parsing "solves" the parsing problem is
    belief in human exceptionalism --
    that human have calculating abilities that Turing machines do not.
    Keeping two possibilites in mind for a long time is trivial for
    human beings -- in one form we call it worrying,
    and try to prevent ourselves from doing it obsessively.
    But it has been the orthodoxy that practical parsing algorithms
    cannot do this.
    </footnote>
    </p>
    <p>Arntzenius has a nice summary of the attempts to parse this
    construct while only allowing one possibility at a time --
    that is, determistically.
    Lookahead clearly cannot work -- it would have to be arbitrarily
    long.
    Backtracking can work, but can be very costly
    and is a major obstacle to quality error reporting.
    </p>
    <p>
    GHC avoids the problems with backtracking by using post-processing.
    At parsing time, GHC treats an ambiguous guard as a
    Boolean.
    Then, if it turns out that is a generator,
    it rewrites it in post-processing.
    This inelegance incurs some real technical debt --
    either a pattern must <b>always</b> be a valid expression,
    or even more trickery must be resorted to.<a id="footnote-10-ref" href="#footnote-10">[10]</a>
    <h2>The Earley solution</h2>
    </p>
    <p>Earley parsing deals with this issue by doing what 
    a human would do --
    keeping both possibilities in mind at once.
    Jay Earley's innovation was to discover a way for a computer
    to track multiple possible parses
    that is compact,
    efficient to create,
    and efficient to read.
    </p>
    <p>
    Earley's algorithm maintains an "Earley table"
    which contains "Earley sets",
    one for each token.
    Each Earley set contains "Earley items".
    Here are some Earley items from Earley set 25 
    in one of our test cases:<br>
    <pre><tt>
	origin = 22; &lt;atomic expression&gt; ::=   '[' &ltexpression&gt; '|' . &ltguards&gt; ']'
	origin = 25; &lt;guards&gt; ::= . &lt;guard<&gt;
	origin = 25; &lt;guards&gt; ::= . &lt;guards&gt; ',' &lt;guard<&gt;
	origin = 25; &lt;guard<&gt;  ::= . &lt;pattern&gt; '&lt; &lt;expression&gt;
	origin = 25; &lt;guard<&gt;  ::= . &lt;expression&gt; </tt><a id="footnote-11-ref" href="#footnote-11">[11]</a></pre>
     <p>
     In the code, these represent the state of the parse just after
     the pipe symbol ("<tt>|</tt>") on line 4 of our test code.
    </p>
    Each Earley item describes progress in one rule of the grammar.
    There is a dot ("<tt>.</tt>") in each rule,
    which indicates how far the parse
    has progressed inside the rule.
    One of the rules has the dot just after the pipe symbol,
    as you would expect, since we have just seen a pipe symbol.
    </p>
    <p>
    The other four rules have the dot at the beginning of the RHS.
    These four rules are "predictions" -- none of their symbols
    have been parsed yet, but we know that these rules might occur,
    starting at the location of this Earley set.
    </p>
    <p>
    Each item also records an "origin": the location in the input where
    the rule described in the item began.
    For predictions the origin is always the same as the Earley set.
    For the first Earley item, the origin is 3 tokens earlier,
    in Earley set 22.
    </p>
    <p>
    <h2>The "secret" of non-determinism</h2>
    <p>
    And now we have come to the secret of efficient non-deterministic parsing --
    a "secret"
    which I hope to convince the reader is not magic,
    or even much of a mystery.
    Here, again, are two of the items from Earley set 25:</p>
    <pre><tt>
	origin = 25; &lt;guard<&gt;  ::= . &lt;pattern&gt; '&lt; &lt;expression&gt;
	origin = 25; &lt;guard<&gt;  ::= . &lt;expression&gt; </tt> <a id="footnote-12-ref" href="#footnote-12">[12]</a></pre>
    </p>
    <p>At this point there are two possibilities going forward --
    a generator guard or a Boolean expression guard.
    And there is an Earley item for each of these possibilities in the Earley set.
    </p>
    <p>
    That is the basic idea -- that is all there is to it.
    Going forward in the parse, for as long as both possibilities stay
    live, Earley items for both will appear in the Earley sets.
    </p>
    <p>From this point of view,
    it should now be clear why the Earley algorithm can keep track
    of several possibilities without lookahead or backtracking.
    No lookahead is needed because all possibilities are in the
    Earley set, and selection among them will take place as the
    rest of the input is read.
    And no backtracking is needed because every possibility
    was already recorded -- there is nothing new to be found
    by backtracking.
    </p>
    <p>It may also be clearer why I claim that Marpa is left-eidetic,
    and how the Ruby Slippers work.<a id="footnote-13-ref" href="#footnote-13">[13]</a>
    Marpa has perfect knowledge of everything in the parse so far,
    because it is all in the Earley tables.
    And, given left-eidetic knowledge, Marpa also knows what
    terminals are expected at the current location,
    and can "wish" them into existence as necessary.
    </p>
    <h2>The code, comments, etc.</h2>
    <p>A permalink to the
    full code and a test suite for this prototype,
    as described in this blog post,
    is
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell">
    on Github</a>.
    In particular,
    the permalink of the
    the test suite file for list comprehension is
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp.t">
    here</a>.
    I expect to update this code,
    and the latest commit can be found
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/haskell">
    here</a>.
    </p>
    <p>
      To learn more about Marpa,
      a good first stop is the
      <a href="http://savage.net.au/Marpa.html">semi-official web site, maintained by Ron Savage</a>.
      The official, but more limited, Marpa website
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">is my personal one</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
    </p>
    <h2>Footnotes</h2>
<p id="footnote-1"><b>1.</b>
    If you are interested in my Marpa-driven Haskell subset parser,
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html">
    this blog post</a>
    may be the best introduction.
    The code is
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/haskell">
    on Github</a>.
 <a href="#footnote-1-ref">&#8617;</a></p>
<p id="footnote-2"><b>2.</b>
    The Earley sets for the ambigious prefix immediately reach a size
    of 46 items, and then stay at that level.
    This is experimental evidence that the Earley set
    sizes stay constant.
    <br><br>
    And, if the Earley items are examined,
    and their derivations traced,
    it can be seen that
    they must repeat the same Earley item count
    for as long as the ambiguous prefix continues.
    The traces I examined are
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp_trace.out">here</a>,
    and the code which generated them is
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp_ex.pl">here</a>,
    for the
    reader who wants to convince himself.
    <br><br>
    The guard prefixes of Haskell are ambiguous,
    but (modulo mistakes in the standards)
    the overall Haskell grammar is not.
    In the literature on Earley's,
    it has been shown that for an unambiguous grammar,
    each Earley item has an constant amortized cost in time.
    Therefore,
    if a parse produces
    a Earley sets that are all of less than a constant size,
    it must have linear time complexity.
 <a href="#footnote-2-ref">&#8617;</a></p>
<p id="footnote-3"><b>3.</b>
    There are many descriptions of Earley's algorithm out there.
    <a href="https://en.wikipedia.org/wiki/Earley_parser">The
    Wikipedia page on Earley's algorithm</a>
    (accessed 27 August 2018)
    is one good place to start.
    I did
    another very simple introduction to Earley's in
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2010/06/jay-earleys-idea.html">an
    earlier blog post</a>,
    which may be worth looking at.
    Note that Marpa contains
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2011/11/what-is-the-marpa-algorithm.html">
    improvements to Earley's algorithm</a>.
    Particularly, to fulfill Marpa's claim of linear time for all
    LR-regular grammars, Marpa uses Joop Leo's speed-up.
    But Joop's improvement is <b>not</b> necessary or useful
    for parsing
    Haskell list comprehension,
    is not used in this example,
    and will not be described in this post.
 <a href="#footnote-3-ref">&#8617;</a></p>
<p id="footnote-4"><b>4.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp.t#L30">
    Permalink to this code</a>,
    accessed 27 August 2018.
 <a href="#footnote-4-ref">&#8617;</a></p>
<p id="footnote-5"><b>5.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp.t#L25">
    Permalink to this code</a>,
    accessed 27 August 2018.
 <a href="#footnote-5-ref">&#8617;</a></p>
<p id="footnote-6"><b>6.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp.t#L35">
    Permalink to this code</a>,
    accessed 27 August 2018.
 <a href="#footnote-6-ref">&#8617;</a></p>
<p id="footnote-7"><b>7.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp.t#L28">
    Permalink to this code</a>,
    accessed 27 August 2018.
 <a href="#footnote-7-ref">&#8617;</a></p>
<p id="footnote-8"><b>8.</b>
    Note that if the list is extended, the patterns matches and Boolean
    tests fail, so that 42 is no longer the answer.
    From the parsing point of view, this is immaterial.
 <a href="#footnote-8-ref">&#8617;</a></p>
<p id="footnote-9"><b>9.</b>
    In several places, including
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/07/knuth_1965_2.html">
    this blog post</a>.
 <a href="#footnote-9-ref">&#8617;</a></p>
<p id="footnote-10"><b>10.</b>
    This account of the state of the art summarizes
    <a href="http://www.rntz.net/post/2018-07-10-parsing-list-comprehensions.html">
    Arntzenius's recent post</a>,
    which should be consulted for the details.
 <a href="#footnote-10-ref">&#8617;</a></p>
<p id="footnote-11"><b>11.</b>
     Adapted from
     <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp_trace.out#L811">
     this trace output</a>,
     accessed 27 August 2018.
 <a href="#footnote-11-ref">&#8617;</a></p>
<p id="footnote-12"><b>12.</b>
     Adapted from
     <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/0df0aef7d6cb8590d3a33f857619e75f84786dd7/code/haskell/listcomp_trace.out#L811">
     this trace output</a>,
     accessed 27 August 2018.
 <a href="#footnote-12-ref">&#8617;</a></p>
<p id="footnote-13"><b>13.</b>
    For more on the Ruby Slippers see
    my <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html">
    just previous blog post</a>,
 <a href="#footnote-13-ref">&#8617;</a></p>
  </body>
</html>
<br />
<p>posted at: 07:30 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/08/rntz.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Tue, 21 Aug 2018</h3>
<br />
<center><a name="combinator2"> <h2>Marpa and combinator parsing 2</h2> </a>
</center>
<html>
  <head>
  </head>
  <body style="max-width:850px">
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <p>
    In
    <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/combinator.html">
    a previous post</a>,
    I outlined a method for using the Marpa algorithm as the basis for
    better combinator parsing.
    This post follows up
    with a trial implementation.
    </p>
    <p>For this trial,
    I choose the most complex example from the classic 1996 tutorial
    on combinator parsing by 
    Hutton and Meijer<a id="footnote-1-ref" href="#footnote-1">[1]</a>.
    Their example implements the offside-rule parsing of a functional language --
    parsing where whitespace is part of the syntax.<a id="footnote-2-ref" href="#footnote-2">[2]</a>
    The Hutton and Meijer example is for Gofer,
    a now obsolete implementation of Haskell.
    To make the example more relevant,
    I wrote a parser for Haskell layout
    according to the Haskell 2010 Language Report<a id="footnote-3-ref" href="#footnote-3">[3]</a>.
    </p>
    <p>For tests,
    I used the five examples (2 long, 3 short) provided
    in the 2010 Report<a id="footnote-4-ref" href="#footnote-4">[4]</a>,
    and the four examples given in the "Gentle Introduction" to Haskell<a id="footnote-5-ref" href="#footnote-5">[5]</a>.
    I implemented only enough of the Haskell syntax to run
    these examples,
    but this was enough to include a substantial subset of Haskell's
    syntax.
    </p>
    <p>This description of the implementation includes many extracts from
    the code.
    For those looking for more detail,
    the full code and test suite for this example are
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/haskell">
    on Github</a>.
    While the comments in the code do not amount to a tutorial, they are
    extensive.
    Readers who like to "peek ahead" are encouraged to do so.
    </p>
    <h2>Layout parsing and the off-side rule</h2>
    <p>It won't be necessary to know Haskell to follow this post.
    This section will describe Haskell's layout informally.
    Briefly, these two code snippets should have the same effect:
    <pre><tt>
       let y   = a*b
	   f x = (x+y)/y
       in f c + f d </tt><a id="footnote-6-ref" href="#footnote-6">[6]</a>
     </pre>
    <pre><tt>
       let { y   = a*b
	   ; f x = (x+y)/y
	   } </tt><a id="footnote-7-ref" href="#footnote-7">[7]</a>
    </pre>
    <p>
    In my test suite, both code snippets produce the same AST.
    The first code display uses Haskell's implicit layout parsing,
    and the second code display uses explicit layout.
    In each, the "<tt>let</tt>" is followed by a block
    of declarations
    (symbol <tt>&lt;decls&gt;</tt>).
    Each decls contains one or more 
    declarations
    (symbol <tt>&lt;decl&gt;</tt>).
    For the purposes of determining layout,
    Haskell regards
    <tt>&lt;decls&gt;</tt> as a "block",
    and each
    <tt>&lt;decl&gt;</tt> as a block "item".
    In both displays, there are two items in
    the block.
    The first item is
    <tt>y = a*b</tt>,
    and the second
    <tt>&lt;decl&gt;</tt> item
    is <tt>f x = (x+y)/y</tt>.
    </p>
    <p>
    In explicit layout, curly braces surround the block,
    and semicolons separate each
    item.
    Implicit layout follows the "offside rule":
    The first element of the laid out block
    determines the "block indent".
    The first non-whitespace character of every subsequent non-empty line
    determines the line indent.
    The line indent is compared to the block indent.
    <ul>
    <li>If the line indent is deeper than the block indent,
    then the line continues the current block item.
    </li>
    <li>If the line indent is equal to the block indent,
    then the line starts a new block item.
    </li>
    <li>If the line indent is less than the block indent
    (an "outdent"),
    then the line ends the block.
    An end of file also ends the block.
    </li>
    </ul>
    Lines containing only whitespace are ignored.
    Comments count as whitespace.
    </p>
    <p>
    Explicit semicolons can be used
    in implicit layout:
    If a semicolon occurs in implicit layout,
    it separates block items.
    In our test suite,
    the example
    <pre><tt>
       let y   = a*b;  z = a/b
	   f x = (x+y)/z
       in f c + f d </tt><a id="footnote-8-ref" href="#footnote-8">[8]</a>
    </pre>
    contains three 
    <tt>&lt;decl&gt;</tt> items.
    </p>
    <p>The examples in the displays above are simple.
    The two long examples from the 2010 Report are
    more complicated:
    6 blocks of 4 different kinds,
    with nesting twice reaching
    a depth of 4.
    The two long examples in the 2010 Report are the same,
    except that one uses implicit layout and the other uses
    explicit layout.
    In the test of my Haskell subset parser,
    both examples produce identical ASTs.
    </p>
    <p>There are additional rules,
    including for tabs, Unicode characters and
    multi-line comments.
    These rules are not relevant in the examples I took from the Haskell literature;
    they present no theoretical challenge to this parsing method;
    and they are not implemented in this prototype Haskell parser.
    </p>
    <h2>The strategy</h2>
    <p>To tackle Haskell layout parsing, I use a separate
    combinator for each layout block.
    Every combinator, therefore, has its own block and item symbols,
    and its own block indent;
    and each combinator implements exactly one method of layout -- explicit or implicit.
    </p>
    <p>From the point of view of its parent combinator,
    a child combinator is a lexeme,
    and the parse tree it produces is the
    value of the lexeme.
    Marpa can automatically produce an AST,
    and it adds lexeme values to the AST as leaves.
    The effect is that Marpa automatically assembles
    a parse tree for us from the tree segments returned by the
    combinators.
    </p>
    <h2>Ruby Slippers semicolons</h2>
    <p>In outlining this algorithm, I will start by explaining
    where the "missing" semicolons come from in the implicit layout.
    Marpa allows various kinds of "events",
    including on discarded tokens.
    ("Discards" are tokens thrown away, and not used in the parse.
    The typical use of token discarding in Marpa is for the handling of whitespace
    and comments.)
    </p>
    The following code sets an event named 'indent', which
    happens when Marpa finds a newline followed by zero or more
    whitespace characters.<a id="footnote-9-ref" href="#footnote-9">[9]</a>
    This does not capture the indent of the first line of a file,
    but that is not an issue --
    the 2010 Report requires that the first indent be treated as a
    special case anyway.
    <pre><tt>
      :discard ~ indent event => indent=off
      indent ~ newline whitechars </tt><a id="footnote-10-ref" href="#footnote-10">[10]</a>
      </pre>
    <p>
    Indent events, like others, occur in the main read loop
    of each combinator.  Outdents and EOFs are dealt with by terminating
    the read loop.<a id="footnote-11-ref" href="#footnote-11">[11]</a>
    Line indents deeper than the current block indent are dealt with by
    resuming the read loop.  <a id="footnote-12-ref" href="#footnote-12">[12]</a>
    Line indents equal to the block indent trigger the reading of a
    Ruby Slippers semicolon as shown in the following:
    <pre><tt>
	$recce->lexeme_read( 'ruby_semicolon', $indent_start,
	    $indent_length, ';' ) </tt><a id="footnote-13-ref" href="#footnote-13">[13]</a>
    </footnote>
    </pre>
    </p>
    <h2>Ruby Slippers</h2>
    <p>
    In Marpa, a "Ruby Slippers" symbol is one which does not actually occur
    in the input.
    Ruby Slippers parsing is new with Marpa,
    and made possible because Marpa is left-eidetic.
    By left-eidetic, I mean that Marpa knows, in full
    detail, about the parse to the left of its current position,
    and can provide that information to the parsing app.
    This implies that Marpa also knows which tokens are acceptable
    to the parser at the current location,
    and which are not.
    </p>
    Ruby Slippers parsing enables a very important trick which
    is useful in "liberal"
    parsing -- parsing where certain elements might be in some sense
    "missing".
    With the Ruby Slippers you can design a "liberal" parser with
    a "fascist" grammar.
    This is, in fact, how the Haskell 2010 Report's
    context-free grammar is designed --
    the official syntax requires explicit layout,
    but Haskell programmers are encouraged to omit most of the explicit
    layout symbols,
    and Haskell implementations are required to "dummy up" those
    symbols in some way.
    Marpa's method for doing this is left-eideticism and Ruby Slippers
    parsing.
    <p>The term "Ruby Slippers" refers to a widely-known scene in the "Wizard of Oz" movie.
    Dorothy is in the fantasy world of Oz, desperate to return to Kansas.
    But, particularly after a shocking incident in which orthodox Oz wizardry
    is exposed as an affable fakery,
    she is completely at a loss as to how to escape.
    The "good witch" Glenda appears and tells Dorothy that in fact she's always
    had what she's been wishing for.
    The Ruby Slippers, which she had been wearing all through the movie,
    can return her to Kansas.
    All Dorothy needs to do is wish.
    </p>
    <p>In Ruby Slippers parsing,
    the "fascist" grammar "wishes" for lots of things that may not be in
    the actual input.
    Procedural logic here plays the part of a "good witch" -- it tells
    the "fascist" grammar that what it wants has been there all along,
    and supplies it.
    To do this,
    the procedural logic has to have a reliable way of knowing what the parser
    wants.
    Marpa's left-eideticism provides this.
    </p>
    <h2>Ruby Slippers combinators</h2>
    <p>This brings us to a question
    I've postponed -- how do we know which combinator
    to call when?
    The answer is Ruby Slippers parsing.
    First, here are some lexer rules for "unicorn" symbols.
    We use unicorns when symbols need to appear in Marpa's lexer,
    but must never be found in actual input.
    </p>
    <pre><tt>
      :lexeme ~ L0_unicorn
      L0_unicorn ~ unicorn
      unicorn ~ [^\d\D]
      ruby_i_decls ~ unicorn
      ruby_x_decls ~ unicorn </tt><a id="footnote-14-ref" href="#footnote-14">[14]</a>
    </footnote>
    </pre>
    <p>
    <tt>&lt;unicorn&gt;</tt> is defined to match 
    <tt>[^\d\D]</tt>.
    This pattern is all the symbols which are not digits
    and not non-digits -- in other words, it's impossible that this
    pattern will ever match any character.
    The rest of the statements declare other unicorn lexemes
    that we will need.
    <tt>&lt;unicorn&gt;</tt> and
    <tt>&lt;L0_unicorn&gt;</tt> are separate,
    because we need to use
    <tt>&lt;unicorn&gt;</tt> on the RHS of some lexer rules,
    and a Marpa lexeme can never occur
    on the RHS of a lexer rule.<a id="footnote-15-ref" href="#footnote-15">[15]</a>
    </p>
    <p>In the above Marpa rule,
    <ul>
    <li>
    <tt>&lt;decls&gt;</tt> is the symbol from the 2010 Report;
    </li>
    <li>
    <tt>&lt;ruby_i_decls&gt;</tt> is a Ruby Slippers symbol for
    a block of declarations with implicit layout.
    </li>
    <li>
    <tt>&lt;ruby_x_decls&gt;</tt> is a Ruby Slippers symbol for
    a block of declarations with explicit layout.
    </li>
    <li>
    <tt>&lt;laidout_decls&gt;</tt> is a symbol (not in the 2010 Report)
    for a block of declarations covering all the possibilities for
    a block of declarations.
    </li>
    </ul>
    <pre><tt>
      laidout_decls ::= ('{') ruby_x_decls ('}')
	       | ruby_i_decls
	       | L0_unicorn decls L0_unicorn </tt><a id="footnote-16-ref" href="#footnote-16">[16]</a>
    </pre>
    </p>
    <p>It is the expectation of a 
    <tt>&lt;laidout_decls&gt;</tt> symbol that causes child
    combinators to be invoked.
    Because <tt>&lt;L0_unicorn&gt;</tt> will never be found
    in the input,
    the 
    <tt>&lt;decls&gt;</tt> alternative will never match --
    it is there for documentation and debugging reasons.<a id="footnote-17-ref" href="#footnote-17">[17]</a>
    Therefore Marpa, when it wants a
    <tt>&lt;laidout_decls&gt;</tt>,
    will look for a
    <tt>&lt;ruby_x_decls&gt;</tt> 
    if a open curly brace is read;
    and a
    <tt>&lt;ruby_i_decls&gt;</tt> otherwise.
    Neither <tt>&lt;ruby_x_decls&gt;</tt> 
    or
    <tt>&lt;ruby_i_decls&gt;</tt> will ever be found in the
    input,
    and Marpa will reject the input,
    causing a "rejected" event.
    <h2>Rejected events</h2>
    <p>In this code, as often,
    the "good witch" of Ruby Slippers does her work through
    "rejected" events.
    These events can be set up to happen when, at some parse
    location, none of the tokens that Marpa's internal lexer
    finds are acceptable.
    </p>
    <p>
    In the "rejected" event handler,
    we can use Marpa's left eideticism to find out what
    lexemes Marpa <b>would</b> consider acceptable.
    Specifically, there is a <tt>terminals_expected()</tt>
    method which returns a list of the symbols acceptable
    at the current location.
    </p>
    <pre><tt>
            my @expected =
              grep { /^ruby_/xms; } @{ $recce->terminals_expected() }; </tt><a id="footnote-18-ref" href="#footnote-18">[18]</a>
    </footnote></pre>
    <p>Once we "grep" out all but the symbols with the "<tt>ruby_</tt>" prefix,
    there are only 4 non-overlapping possibilities:
    </p>
    <ul>
    <li>Marpa expects a 
    <tt>&lt;ruby_i_decls&gt;</tt>
    lexeme;
    </li>
    <li>Marpa expects a 
    <tt>&lt;ruby_x_decls&gt;</tt>
    lexeme;
    </li>
    <li>Marpa expects a 
    <tt>&lt;ruby_semicolon&gt;</tt>
    lexeme;
    </li>
    <li>Marpa does not expect
    any of the Ruby Slippers lexemes;
    </li>
    </ul>
    <p>If Marpa does not expect any of the Ruby Slippers
    lexemes, there was a syntax error in the Haskell code.<a id="footnote-19-ref" href="#footnote-19">[19]</a>
    <p>If a <tt>&lt;ruby_i_decls&gt;</tt>
    or a <tt>&lt;ruby_x_decls&gt;</tt>
    lexeme is expected, a child combinator is invoked.
    The Ruby Slippers symbol determines
    whether the child combinator looks for implicit
    or explicit layout.
    In the case of implicit layout, the location of
    the rejection determines the block indent.<a id="footnote-20-ref" href="#footnote-20">[20]</a>
    </footnote>
    </p>
    <p>If a 
    <tt>&lt;ruby_semicolon&gt;</tt>
    is expected, then the parser is at the point where a
    new block item could start,
    but none was found.
    Whether the block was implicit or explicit,
    this indicates we have reached the end of the block,
    and should return control to the parent combinator.<a id="footnote-21-ref" href="#footnote-21">[21]</a>
    </footnote>
    </p>
    <p>
    To explain why
    <tt>&lt;ruby_semicolon&gt;</tt>
    indicates end-of-block,
    we look at both cases.
    In the case of an explicit layout combinator,
    the rejection should have been caused by a closing
    curly brace, and
    we return to the parent combinator
    and retry it.
    In the parent combinator, the closing curly brace
    will be acceptable.
    </p>
    <p>If we experience a "rejected" event while
    expecting a
    <tt>&lt;ruby_semicolon&gt;</tt> in an implicit layout
    combinator,
    it means we did not find an explicit semicolon;
    and we also never found the right indent for creating a Ruby semicolon.
    In other words, the indentation is telling us that we are at the end
    of the block.
    We therefore return control to the parent combinator.
    </p>
    <h2>Conclusion</h2>
    <p>
    With this, we've covered the major points of this Haskell prototype
    parser.
    It produces an AST whose structure and node names are those of
    the 2010 Report.
    (The Marpa grammar introduces non-standard node names and rules,
    but these are pruned from the AST in post-processing.)
    </p>
    <p>
    In the code, the grammars from the 2010 Report are included for
    comparison, so a reader can easily determine what syntax we left out.
    It might be tedious to add the rest,
    but I believe it would be unproblematic, with one interesting exception:
    fixity.
    To deal with fixity, we may haul out the Ruby Slippers again.
    </p>
    <h2>The code, comments, etc.</h2>
    <p>A permalink to the
    full code and a test suite for this prototype,
    as described in this blog post,
    is
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell">
    on Github</a>.
    I expect to update this code,
    and the latest commit can be found
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/haskell">
    here</a>.
    Links for specific lines of code in this post are usually
    static permalinks to earlier commits.
    </p>
    <p>
      To learn more about Marpa,
      a good first stop is the
      <a href="http://savage.net.au/Marpa.html">semi-official web site, maintained by Ron Savage</a>.
      The official, but more limited, Marpa website
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">is my personal one</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
    </p>
    <h2>Footnotes</h2>
<p id="footnote-1"><b>1.</b>
    Graham Hutton and Erik Meijer,
    <cite>Monadic parser combinators</cite>, Technical Report NOTTCS-TR-96-4.
    Department of Computer Science, University of Nottingham, 1996,
    pp 30-35.
    <a href="http://eprints.nottingham.ac.uk/237/1/monparsing.pdf">
    http://eprints.nottingham.ac.uk/237/1/monparsing.pdf</a>.
    Accessed 19 August 2018.
 <a href="#footnote-1-ref">&#8617;</a></p>
<p id="footnote-2"><b>2.</b>
    I use
    whitespace-significant parsing as a convenient example
    for this post,
    for historical reasons and
    for reasons of level of complexity.
    This should not be taken to indicate that I recommend it
    as a language feature.
 <a href="#footnote-2-ref">&#8617;</a></p>
<p id="footnote-3"><b>3.</b>
    Simon Marlow,
    <cite>Haskell 2010 Language Report</cite>,
    2010.
    <a href="https://www.haskell.org/onlinereport/haskell2010/haskell.html#haskellpa1.html">
    Online version accessed
    21 August 2018.</a>
    For layout, see in particular
    section 2.7 (pp. 12-14)
    and section 10.3 (pp. 131-134).
 <a href="#footnote-3-ref">&#8617;</a></p>
<p id="footnote-4"><b>4.</b>
    2010 Report.
    The short examples are on p. 13 and p. 134.
    The long examples are on p. 14.
 <a href="#footnote-4-ref">&#8617;</a></p>
<p id="footnote-5"><b>5.</b>
    Paul Hudak, John Peterson and Joseph Fasel
    <cite>Gentle Introduction To Haskell</cite>, version 98.
    Revised June, 2000 by Reuben Thomas.
    <a href="https://www.haskell.org/tutorial/index.html">
    Online version accessed
    21 August 2018.</a>
    The examples are in section 4.6,
    which is on pp. 20-21 of
    <a href="https://www.haskell.org/tutorial/haskell-98-tutorial.pdf">
    the October 1999 PDF</a>.
 <a href="#footnote-5-ref">&#8617;</a></p>
<p id="footnote-6"><b>6.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/short.t#L21">
      Github Permalink.</a>
 <a href="#footnote-6-ref">&#8617;</a></p>
<p id="footnote-7"><b>7.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/short.t#L28">
      Github Permalink.</a>
 <a href="#footnote-7-ref">&#8617;</a></p>
<p id="footnote-8"><b>8.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/short.t#L43">
      Github Permalink.</a>
 <a href="#footnote-8-ref">&#8617;</a></p>
<p id="footnote-9"><b>9.</b>
    Single-line comments are dealt with properly by lexing them
    as a different token and discarding them separately.
    Handling multi-line comments is not yet implemented --
    it is easy in principle but
    tedious in practice and the examples drawn from the
    Haskell literature did not provide any test cases.
 <a href="#footnote-9-ref">&#8617;</a></p>
<p id="footnote-10"><b>10.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L608">
      Github Permalink.</a>
 <a href="#footnote-10-ref">&#8617;</a></p>
<p id="footnote-11"><b>11.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1007">
    Github Permalink.</a>
 <a href="#footnote-11-ref">&#8617;</a></p>
<p id="footnote-12"><b>12.</b>
    <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1028">
    Github Permalink.</a>
 <a href="#footnote-12-ref">&#8617;</a></p>
<p id="footnote-13"><b>13.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1101">
      Github Permalink.</a>
 <a href="#footnote-13-ref">&#8617;</a></p>
<p id="footnote-14"><b>14.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L550">
      Github Permalink.</a>
 <a href="#footnote-14-ref">&#8617;</a></p>
<p id="footnote-15"><b>15.</b>
    The reason for this is that by default a Marpa grammar determines
    which of its symbols are lexemes using the presence of those
    symbol on the LHS and RHS
    of the rules
    in its lexical and context-free grammars.
    A typical Marpa grammar
    requires a minimum of explicit lexeme declarations.
    (Lexeme declarations are statements with the <tt>:lexeme</tt>
    pseudo-symbol on their LHS.)
    As an aside,
    the Haskell 2010 Report is not always careful about the lexer/context-free
    boundary,
    and adopting its grammar
    required more use of Marpa's explicit lexeme declarations
    than usual.
 <a href="#footnote-15-ref">&#8617;</a></p>
<p id="footnote-16"><b>16.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L361">
      Github Permalink.</a>
 <a href="#footnote-16-ref">&#8617;</a></p>
<p id="footnote-17"><b>17.</b>
    Specifically, the presense of a 
    <tt>&lt;decls&gt;</tt> alternative silences the usual warnings about
    symbols inaccessible from the start symbol.
    These warnings can be silenced in other ways,
    but at the prototype stage it is convenient to check that
    all symbols supposed to be accessible through
    <tt>&lt;decls&gt;</tt> are in fact accessible.
    There is a small startup cost to allowing the extra symbols
    in the grammars,
    but the runtime cost is probably not measureable.
 <a href="#footnote-17-ref">&#8617;</a></p>
<p id="footnote-18"><b>18.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1055">
      Github Permalink.</a>
 <a href="#footnote-18-ref">&#8617;</a></p>
<p id="footnote-19"><b>19.</b>
    Currently the handling of these is simplistic.
    A practical implementation of this method would want better reporting.
    In fact, Marpa's left eideticism allows some interesting things
    to be done in this respect.
 <a href="#footnote-19-ref">&#8617;</a></p>
<p id="footnote-20"><b>20.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1081">
      Github Permalink.</a>
 <a href="#footnote-20-ref">&#8617;</a></p>
<p id="footnote-21"><b>21.</b>
      <a href="https://github.com/jeffreykegler/Ocean-of-Awareness-blog/blob/6c76ffc791d24f4515edea376ac31ad7264a420c/code/haskell/haskell.pm#L1072">
      Github Permalink.</a>
 <a href="#footnote-21-ref">&#8617;</a></p>
  </body>
</html>
<br />
<p>posted at: 10:24 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/combinator2.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 08 Jul 2018</h3>
<br />
<center><a name="knuth_1965_2"> <h2>Undershoot: Parsing theory in 1965</h2> </a>
</center>
<html>
  <head>
  </head>
  <body style="max-width:850px">
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <blockquote>The difference between theory and practice is
      that in theory there is no difference between
      theory and practice,
      but in practice, there is.<a id="footnote-1-ref" href="#footnote-1">[1]</a>
    </blockquote>
    <p>
      Once it was taken seriously that humans might have the power to, for
      example, "read" a chessboard in a way that computers could not beat.
      This kind of "computational mysticism" has taken a beating.
      But it survives in one last stronghold -- parsing theory.
    </p><p>
      In
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html">
        a previous post</a>,
      I asked "Why is parsing considered solved?"
      If the state of the art of computer parsing is taken as anything close to its ultimate solution,
      then it is a case of "human exceptionalism" --
      the human brain has some
      power that makes it much better at parsing than computers can be.
      It is very unlikely resorting to human exceptionalism as an explanation
      would be accepted
      for any other problem in computer science.
      Why is it accepted for parsing theory?<a id="footnote-2-ref" href="#footnote-2">[2]</a>
    </p>
    <p>
      The question really requires two separate answers:
    </p><ul>
      <li>"Why do practitioners accept the current state of the art as the solution?" and
      </li><li>"Why do the theoreticians accept the current state of the art as the solution?"
      </li></ul>
    <p>
    </p><p>In one sense, the answer to both questions is the same --
      because of the consensus created by Knuth's 1965 paper
      "On the translation of languages from left to right".
      In
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html">a previous post</a>,
      I looked at Knuth 1965
      and I answered the practitioner question in detail.
      But, for the sake of brevity,
      I answered the question about the theoreticians in outline.
      This post expands on that outline.
    </p>
    <h2>The Practitioners</h2>
    <p>
      To summarize, in 1965,
      <b>practitioners</b>
      accepted the parsing problem as solved
      for the following reasons.
    </p>
    <ul>
      <li>In 1965, every practical parser was stack-driven.</li>
      <li>As of 1965, stacks themselves were quite leading edge.
        As recently as 1961,
        a leading edge article<a id="footnote-3-ref" href="#footnote-3">[3]</a>
        could not assume that its readers knew what "pop" and "push" operations
        were.
      </li>
      <li>An algorithm that combined state transitions and stack operations was
        already a challenge to existing machines.
        In 1965, any more complicated algorithm was likely to be unuseable
        in practice.
      </li>
      <li>Last, but not least, the theoreticians assured the
        practitioners that
        <tt>LR</tt>-parsing was either state-of-the-art
        or beyond,
        so making more agressive use of hardware
        would be futile.
      </li>
    </ul>
    <h2>What about the theorists?</h2>
    <p>The practitioners of 1965, then,
      were quite reasonable in feeling that
      <tt>LR</tt>-parsing was as good as anything they were likely to be able
      to implement any time soon.
      And they were being told by the theorists that,
      in fact,
      it never would get any better --
      there were theoretical limits on parsers that faster
      hardware could not overcome.
    </p>
    <p>We now know that the theorists were wrong --
      there are non-<tt>LR</tt>
      parsers which are better than the
      <tt>LR</tt>
      parsers are at
      <tt>LR</tt>
      grammars.
      What made the theorists go astray?
    </p>
    <h2>How theorists work</h2>
    <p>As the epigraph for this post reminds us,
      theorists who hope to guide practitioners have to confront a big problem --
      theory is practice only in theory.
      Theoreticians
      (or at least the better ones, like Knuth)
      know this,
      but they try to make theory as reliable a guide to
      practice as possible.
    </p>
    <p>One of the most important examples of the theoretician's successes
      is asymptotic notation, which we owe to Knuth<a id="footnote-4-ref" href="#footnote-4">[4]</a>.
      Asymptotic notation is
      more commonly referred to as big-O notation.
      The term "asymptotic notation"
      emphasizes its most dangerous aspect
      from a practical point of view:
      Asymptotic notation assumes
      that the behavior of most interest
      is the behavior for arbitrarily large inputs.
    </p>
    <p>
      Practical inputs can be very large but,
      by definition,
      they are never arbitrarily large.
      Results in asymptotic terms
      might be what is called "galactic" --
      they might have
      relevance only in situations which cannot possibly occur in practice.
    </p>
    <p>
      Fortunately for computer science,
      asymptotic results usually are
      not "galactic".
      Most often asymptotic results are not only
      relevant to practice --
      they are extremely relevant.
      Wikipedia pages for algorithms put
      the asymptotic complexities in special displays,
      and these displays are one of the first
      things that some practitioners look at.
    </p>
    <h2>Bracketing</h2>
    <p>Since coming up with a theoretical model that is equivalent
      to "practical" is impossible,
      theoreticians often work like artillerists.
      Artillerists often deliberately overshoot and undershoot,
      before they "fire for effect".
      "Bracketing" their target in this way has disadvantages --
      it reduces the element of surprise,
      and can even allow the enemy to get their counter-fire in first.
      But, nasty as these consequences could be,
      the advantage in accuracy is usually held to outweigh them.
    </p>
    <p>The practice of theoretical computer science is
      less risky,
      which makes "bracketing" a very attractive approach to
      tricky problems.
      Theoreticians often
      try to "bracket" practice between an "undershoot"
      and an "overshoot".
      The undershoots are models simple and efficient enough to be practical,
      but too weak to capture all the needs of practice.
      The overshoots are models which capture everything
      a practitioner needs,
      but which are too complicated and/or too resource-intensive
      for practice.
    </p><p>The P vs. NP problem is an active example of a bracketing technique.
      You will sometimes read that
      the P/NP boundary is expected to be
      that between practical and impractical,
      but this is an extreme simplification.
      P includes complexities like
      <tt>O(n^1000000)</tt>,
      where the complexity for even
      <tt>n == 2</tt>
      is
      a nunber which, in decimal form,
      fills many pages.
      Modulo bold advances in quantum computing,
      I cannot imagine that
      <tt>O(n^1000000)</tt>
      will ever be
      practical.
      And you can make the complexities much harder
      than
      <tt>O(n^1000000)</tt>
      without ever reaching P-hard.
    </p>
    <p>
      So P-hard is beyond any reasonable definition of "practical" --
      it is an "overshoot".
      But the P vs. NP question is almost certainly very relevant to what is "practical".
      Resolving the P vs. NP question is likely
      to be an important or even necessary step.
      It is a mystery that such a seemingly obvious
      question has resisted the best efforts of the theoreticians
      for so long,
      and the solution of P vs. NP is likely
      to bring
      new insights
      into asymptotic complexity.
    </p>
    <h2>Bracketing practical parsing</h2>
    <p>When Knuth published his 1965,
      "practical parsing" was already bracketed.
      On the overshoot side, Irons had already published a parser for
      context-free grammars.
      Worst case, this ran in exponential time,
      and it was, and remains, expected that general context-free parsing
      was not going to be practical.<a id="footnote-5-ref" href="#footnote-5">[5]</a>
    </p>
    <p>On the undershoot side,
      there were regular expressions and recursive descent.
      Regular expressions are fast and very practical,
      but parse a very limited set of grammars.
      Recursive descent is also fast and,
      since it parses a larger set of grammars,
      was the closest undershoot.
    </p>
    <h2>Mistake 1: The misdefinition of "language"</h2>
    <p>To curry respect from the behaviourists,
      American linguistics for many years banned any reference
      to meaning.
      Behaviorists looked down on
      hypothesized mental states as not worthy of "science",
      and it's hard to have a theory of meaning
      without conjectures about mental states.
      Without mental states,
      language was just a set of utterances.
      So in 1926 the linguist Leonard Bloomfield
      dutifully
      defined a "language" as a set of "utterances"
      (for our purposes, "strings"),
      and through the 30s and 40s most American
      linguists followed him.
    </p>
    <p>After a brief nod to this tradition,
      Noam Chomsky restored sanity to linguistics.
      But it was too late for computer science.
      Automata theory adopted the semantics-free definition.
      In 1965, Knuth inherited a lot of prior work,
      almost all of which ignored,
      not just meaning or semantics,
      but even syntax and structure.<a id="footnote-6-ref" href="#footnote-6">[6]</a>
    </p>
    <h2>Language extension versus language intension</h2>
    <p>Knuth, of course, wanted to make contact with prior art.
      The definition he had inherited seemed to work well enough
      and Knuth's 1965 defines a language as a set of strings.
      Most subsequent work has refused to breach this tradition.
    </p>
    <p>In most people's idea of what a language is,
      the utterances/strings mean something --
      you cannot take just
      any set of meaningless strings and call it a language.
      So the parsing theorists and everybody else had
      two different definitions of language.
    </p>
    <p>But parsing theory also hoped to produce results relevant
      to practice,
      and few people are interested in recognizing meaningless strings --
      almost everybody who parses is interested in (at a minimum)
      finding some kind of structure in what they parse,
      in order to do something with the result of the parse.
      Parsing theorists ended up using the word "language" in one
      sense, but implying that results they found worked
      for the word "language" in the usual sense.
    </p>
    <p>
      At this point both senses of the word "language"
      have gotten entrenched in parsing theory.
      Instead of making up a new terminology for this blog post,
      I will borrow a distinction from linguistics
      and speak of
      <b>the extension of a language</b>
      and
      <b>the intension of a language</b>.
      The extension of a language is the Bloomfieldian defintion --
      the set of utterances/strings in the language.
      The intension of a language, for our purposes here,
      can be regarded as its BNF grammar.
      Each language intension will have (if it is well-defined)
      exactly one extension.
      But multiple language intensions can have the same extension.
    </p>
    <h2>Red Herring 1: The stack machine model as a natural boundary</h2>
    <p>The temptation to use language extensions as
      a proxy for
      <tt>LR</tt>-grammars must have been overwhelming.
      It turns out that the language extension of
      deterministic stack machines
      is
      <b>exactly</b>
      that of the
      <tt>LR</tt>
      grammars.
      Further,
      the language extension of the context-free grammars is
      exactly that of the non-deterministic stack machines.
      (Non-deterministic stack machines are
      stack machines which can "fork" new instances of themselves on the fly.)
    </p>
    <p>
      If you take language extensions as the proxy for grammars,
      things fall into place very neatly:
      the
      <tt>LR</tt>-parsers are the deterministic subset of the
      context-free parsers.
      And "deterministic" seemed like a very good approximation
      of practical.
      Certainly non-deterministic parsing is probably not practical.
      And the best practical parsers in 1965 were
      deterministic stack parsers.
    </p><p>
      Viewed this way,
      <tt>LR</tt>-parsing looked like the equivalent
      of practical parsing.
      It was a "direct hit",
      or as close to a exact equivalent of practical parsing
      as theory was going to get.
    </p>
    <p>As we shall see,
      with this red herring,
      the reasoning went astray.
      But disaster was not inevitable.
      The whole point of bracketing, after all,
      is that it allows you to correct errors.
      Another red herring, however, resulted in
      parsing theory going on a decades-long
      wrong turn.
    </p>
    <h2>Red Herring 2:
      <tt>LR</tt>
      parsers are not good at
      <tt>LR</tt>
      grammars</h2>
    <p>The second red herring led to the mis-bracketing of practical
      parsing.
      Having seemingly established that
      <tt>LR</tt>-parsing is a natural boundary
      in the hierarchy of languages,
      Knuth discovered that general
      <tt>LR</tt>-parsers were very far from practical.
      <tt>LR</tt>
      parsing goes out to
      <tt>LR(k)</tt>
      for arbitrary
      <tt>k</tt>,
      but even
      <tt>LR(1)</tt>
      parsing was impractical in 1965 --
      in fact, it is rare in practical use today.
      As the
      <tt>k</tt>
      in
      <tt>LR(k)</tt>
      grows, the size of the tables grows exponentially,
      while the value of the additional lookahead rapidly diminishes.
      It is not likely that
      <tt>LR(2)</tt>
      parsing will ever see much practical use,
      never mind
      <tt>LR(k)</tt> for any <tt>k</tt>
      greater than 2.
    </p>
    <p>
      From this it was concluded that
      <tt>LR</tt>-parsing is an overshoot.
      In reality,
      as Joop Leo was to show,
      it is an
      <b>undershoot</b>,
      and in practical terms a very large one.
      If you mistake an undershoot for an overshoot,
      bracketing no longer works,
      and you are not likely to hit your target.
    </p>
    <h2>The Wrong Turn</h2>
    <p>
      Summing up,
      parsing theorists concluded,
      based on the results of Knuth 1965,
      that
    </p><ul>
      <li>LR-parsing is a good approximation to practical parsing -- it brackets
        it closely.</li>
      <li>LR-parsing is an overshoot.</li>
      <li>A subset of
        <tt>LR</tt>-parsing will be the solution to the parsing problem.</li>
    </ul>
    <h2>Signs of trouble ignored</h2>
    <p>There were, in hindsight, clear signs
      that
      <tt>LR</tt>
      language extensions were not a good proxy for
      <tt>LR</tt>
      grammars.
      <tt>LR</tt>
      grammars form a hierarchy --
      for every
      <tt>k&#8805;0</tt>,
      there is an
      <tt>LR</tt>
      grammar which
      is
      <tt>LR(k+1)</tt>, but which is not
      <tt>LR(k)</tt>.
    </p>
    <p>
      But if you look at extensions
      instead of grammars,
      the hierarchy immediately
      collapses --
      every
      <tt>LR(k)</tt>
      language extension is also
      an
      <tt>LR(1)</tt>
      language extension,
      as long as
      <tt>k&#8805;1</tt>.
      Only
      <tt>LR(0)</tt>
      remains distinct.
    </p>
    <p>It gets worse.
      In most practical applications,
      you can add an end-of-input marker to a grammar.
      If you do this the
      <tt>LR</tt>
      extension hierarchy collapses totally --
      every
      <tt>LR(k)</tt>
      language extension is also an
      <tt>LR(0)</tt>
      language extension.
    </p>
    <p>In short, it seems that,
      as a proxy for
      <tt>LR</tt>
      grammars,
      <tt>LR</tt>
      language extensions are likely to be completely worthless.
    </p>
    <h2>Why didn't Knuth see the problem?</h2>
    <p>Why didn't Knuth see the problem?
      Knuth certainly noted the strange behavior of the
      <tt>LR</tt>
      hierarchy
      in extensional terms -- he discovered it,
      and devoted several dense pages of his 1965 to laying
      out the complicated mathematics involved.
    </p>
    <p>
      So why did
      Knuth expect to get away with punning
      intension and extension,
      even in the face of some very unsettling results?
      Here, the answer is very simple --
      "punning" had always worked before.
    </p>
    <p>
      Regular expressions are easily turned into parsers<a id="footnote-7-ref" href="#footnote-7">[7]</a>,
      so the language extension of a regular grammar is an adequate approximation
      to its intension.
      Context-free recognition has the same complexity,
      and in practice uses the same algorithms,
      as context-free parsing,
      so here again,
      language extension is a good approximation
      of language intension.
    </p>
    <p>
      And the
      <tt>LL</tt>
      language extensions follow a strict hierarchy --
      for every
      <tt>k&#8805;0</tt>,
      <tt>LL(k+1)</tt>
      is a proper superset of
      <tt>LL(k)</tt>.
      This fact forces
      <tt>LL</tt>
      grammars to follow the same
      hierarchy<a id="footnote-8-ref" href="#footnote-8">[8]</a>.
      So, when studying complexity,
      <tt>LL</tt>
      language extensions are an excellent proxy for
      <tt>LL</tt>
      grammars.
    </p>
    <p>
      Based on past experience,
      Knuth had reason to believe
      he could use language extensions as a proxy
      for grammars,
      and that the result would be
      a theory that was a reliable
      guide to practice.
    </p>
    <h2>Aftermath</h2>
    <p>In
      <a href="https://jeffreykegler.github.io/personal/timeline_v3">
        my timeline of parsing</a>,
      I describe what happened next.
      Briefly,
      theory focused on finding a useful subset of
      <tt>LR(1)</tt>.
      One,
      <tt>LALR</tt>, became the favorite and
      the basis of the
      <tt>yacc</tt>
      and
      <tt>bison</tt>
      tools.
    </p>
    <p>
      Research into parsing of supersets of
      <tt>LR</tt>
      became rare.
      The theorists were convinced the
      <tt>LR</tt>
      parsing
      was the solution.
      These were so convinced that when,
      in 1991, Joop Leo discovered a practical way to
      parse an
      <tt>LR</tt> superset,
      the result went unimplemented for decades.
    </p>
    <p>In 1965, the theoreticians gave a lot of weight
      to the evidence from the world of practice,
      but probably not undue weight.
      Going forward, it was a different story.
    </p>
    <p>
      Leo had,
      in essence,
      disproved the implied conjecture of Knuth 1965.
      But the question is
      not an explicit mathematical question,
      like that of P vs. NP.
      It is a slipprier one -- capturing practice.
      Practitioners left it to the theoreticians to keep up with
      the literature.
      But theoreticians, as long as
      <tt>LR</tt>-superset methods did not
      come into use in the world of practice,
      felt no need to revisit their conclusions.
    </p>
    <h2>Comments, etc.</h2>
    <p>
      I encourage
      those who want to know more about the story of Parsing Theory
      to look at my
      <a href="https://jeffreykegler.github.io/personal/timeline_v3">
        Parsing: a timeline 3.0</a>.
      To learn about Marpa,
      my Earley/Leo-based parsing project,
      there is the
      <a href="http://savage.net.au/Marpa.html">semi-official web site, maintained by Ron Savage</a>.
      The official, but more limited, Marpa website
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">is my personal one</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel:
      <tt>#marpa</tt> at <tt>freenode.net</tt>.
    </p>
    <h2>Footnotes</h2>
<p id="footnote-1">1.
        Attributed to Jan L. A. van de Snepscheut and Yogi Berra.
        See
        <a href="https://en.wikiquote.org/wiki/Jan_L._A._van_de_Snepscheut">
          https://en.wikiquote.org/wiki/Jan_L._A._van_de_Snepscheut</a>,
        accessed 1 July 2018.
        I quote my preferred form  of this --
        the one it takes in
        Doug Rosenberg and Matt Stephens,
        <cite>Use Case Driven Object Modeling with UML: Theory and Practice</cite>,
        2007,
        p. xxvii.
        Rosenberg and Stephens is also the accepted authority for its attribution.
 <a href="#footnote-1-ref">&#8617;</a></p>
<p id="footnote-2">2.
        As an aside, I am open to the idea that
        the human mind has abilities that Turing machines cannot improve on
        or even duplicate.
        When it comes to
        survival heuristics tied to the needs of human bodies, for example,
        it seems very reasonable to at least entertain the conjecture
        that the human mind might be near-optimal,
        particularly in big-O terms.
        But when it comes to ability to solve problems which can be formalized
        as "puzzles" -- and syntactic analysis is one of these --
        I think that resort to human exceptionalism
        is a sign of desperation.
 <a href="#footnote-2-ref">&#8617;</a></p>
<p id="footnote-3">3.
          Oettinger, Anthony. "Automatic Syntactic Analysis and the Pushdown
          Store",
          <cite>Proceedings of Symposia in Applied Mathematics</cite>,
          Volume 12,
          American Mathematical Society, 1961.
          Oettinger describes "push" and "pop"
          stack operations in "Iversion notation" -- what
          later became APL.
          See the discussion of Oettinger in
          my
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html">
            "Why is parsing considered solved?" post</a>.
 <a href="#footnote-3-ref">&#8617;</a></p>
<p id="footnote-4">4.
        Knuth did not invent asymptotic notation --
        it comes from calculus --
        but he introduced it to computer science
        and motivated its use.
 <a href="#footnote-4-ref">&#8617;</a></p>
<p id="footnote-5">5.
        The best lower bound for context-free parsing is still
        <tt>O(n)</tt>.
        So it is even possible that there is a practical
        linear-time general context-free
        parser.
        But its discovery would be a big surprise.
 <a href="#footnote-5-ref">&#8617;</a></p>
<p id="footnote-6">6.
        In
        <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/chomsky_1956.html">
          another blog post</a>,
        I talk about the use of the word
        "language" in parsing theory
        in much more detail.
 <a href="#footnote-6-ref">&#8617;</a></p>
<p id="footnote-7">7.
        For example,
        regular expressions can be extended with "captures".
        Captures cannot handle recursion, but neither can regular expressions,
        so captures are usually sufficient to provide all the structure
        an application wants.
 <a href="#footnote-7-ref">&#8617;</a></p>
<p id="footnote-8">8.
        The discussion of the
        <tt>LL(k)</tt>
        hierarchy is in a sense anachronistic --
        the
        <tt>LL(k)</tt>
        hierachy was not studied until after 1965.
        But Knuth certainly was aware of recursive descent,
        and it seems reasonable to suppose that,
        even in 1965,
        he had a sense of what
        the
        <tt>LL</tt>
        hierarchy would look like.
 <a href="#footnote-8-ref">&#8617;</a></p>
  </body>
</html>
<br />
<p>posted at: 21:02 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/07/knuth_1965_2.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Wed, 20 Jun 2018</h3>
<br />
<center><a name="lrecursion"> <h2>Parsing left recursions</h2> </a>
</center>
<html>
  <head>
  </head>
  <body style="max-width:850px">
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <h2>Left recursion</h2>
    <p>A lot has been written about parsing left recursion.
    Unfortunately, much of it simply adds to the mystery.
    In this post, I hope to frame the subject clearly and briefly.
    <p>
    </p>I expect the reader has some idea of what left recursion is,
    and perhaps some experience of it as an issue.
    Informally, left recursion occurs when a symbol expands to something
    with itself on the left.
    This can happen directly, for example, if
    production <tt>(1)</tt> is in a grammar.
    </p>
    <pre><tt>
    (1) A ::= A B
    </tt></pre>
    Indirect left recursion happens when,
    for example,
    <tt>(2)</tt> and
    <tt>(3)</tt>
    are productions in a grammar.
    <pre><tt>
    (2) A ::= B C
    (3) B ::= A D
    </tt></pre>
    A grammar with productions
    <tt>(4)</tt> and
    <tt>(5)</tt>
    has a "hidden" left recursion.
    <pre><tt>
    (4) A ::= B A C
    (5) B ::= # empty
    </tt></pre>
    This is because
    <tt>&lt;A&gt;</tt>
    ends up leftmost in derivations like:
    <pre><tt>
    (6) A  &#10230; B A C &#10230 A C
    </tt></pre>
    In derivation <tt>(6)</tt>,
    production <tt>(4)</tt> was applied,
    then production <tt>(5)</tt>.
    <p>For those into notation,
    a grammar is left recursive if and only if it allows a derivation of the
    form
    <pre><tt>
    (7) A  &#10230;<sup>+</sup> &beta; A &gamma; </tt> where <tt> &beta; = &epsilon;
    </tt></pre>
    In <tt>(7)</tt> <tt>&epsilon;</tt> is the empty string,
    and 
    <tt> &alpha; &#10230;<sup>+</sup> &beta;</tt>
    indicates that <tt>&alpha;</tt> derives <tt>&beta;</tt>
    in one or more rule applications.
    <h2>So, OK, what is the problem?</h2>
    <p>The problem with parsing left recursions is that if you are parsing
    using a derivation like
    <pre><tt>
    (8) A  &#10230; A B </tt>
    </tt></pre>
    then you have defined
    <tt>&lt;A&gt;</tt>
    in terms of 
    <tt>&lt;A&gt;</tt>.
    All recursions can be a problem,
    but left recursions are a particular problem because almost all practical
    parsing methods<a id="footnote-1-ref" href="#footnote-1">[1]</a>
    proceed left to right,
    and derivations like <tt>(8)</tt> will lead many of
    the most popular algorithms straight into
    an infinite regress.
    <h2>Why do some algorithms not have a problem?</h2>
    <p>In a sense,
    all algorithms which solve the left recursion problem do
    it in the same way.
    It is just that in some,
    the solution appears in a much simpler form.
    </p>
    <p>
    The solution is at most simple in Earley's algorithm.
    That is no coincidence -- as Pingali and Bilardi<a id="footnote-2-ref" href="#footnote-2">[2]</a>
    show,
    Earley's, despite its daunting reputation,
    is actually the most basic Chomskyan context-free parsing algorithm,
    the one from which all others derive.
    </p>
    <p>Earley's builds a table.
    The Earley table contains an initial Earley set
    and an Earley set for each token.
    The Earley set for each token
    describes the state of the parse after consuming that token.
    The basic idea is not dissimilar
    to that of the Might/Darais/Spiewak (MDS) idea of parsing by derivatives,
    and the logic for building the Earley sets resembles
    that of MDS.<a id="footnote-3-ref" href="#footnote-3">[3]</a>
    <p>
    For the purpose of studying left recursion,
    what matters is that
    each Earley set contains Earley "items".
    Some of the items are called predictions
    because they predict the occurrence of a symbol
    at that location in the input.
    </p>
    To record a left recursion in an Earley set,
    the program adds
    a prediction item for the left recursive symbol.
    It is that simple.<a id="footnote-4-ref" href="#footnote-4">[4]</a>
    </p>
    Multiple occurrences of a prediction item would be identical,
    and therefore useless.
    Therefore subsequent attempts
    to add the same prediction item are ignored,
    and recursion does not occur.
    </p>
    <h2>If some have no problem, why do others?</h2>
    <p>Besides Earley's,
    a number of other algorithms handle left recursion without
    any issue -- notably LALR 
    (aka <tt>yacc</tt> or <tt>bison</tt>) and LR.
    This re-raises the original question:
    why do some algorithms have a left recursion problem?
    </p>
    <p>The worst afflicted algorithms are the "top-down"
    parsers.
    The best known of these is recursive descent --
    a parsing methodology which, essentially, does parsing
    by calling a subroutine to handle each symbol.
    In the traditional implementation of recursive descent,
    left recursion is very problematic.
    Suppose that, as part of a recursive descent implementation,
    you are writing the function to parse the
    symbol <tt>&lt;A&gt;</tt>,
    which you are calling
    <tt>parse_A()</tt>.
    If your grammar has a rule
    <pre><tt>
    (9) A ::= A B
    </tt></pre>
    the first thing you need to do in a naive
    implementation of
    <tt>parse_A()</tt>
    is to call <tt>parse_A()</tt>.
    And <tt>parse_A()</tt> will
    then call <tt>parse_A()</tt>.
    And so, in the naive implementation, on and on forever.
    <h2>The fixed-point solution to left recursion</h2>
    <p>Over the years,
    many ways to solve the top-down left recursion issue have been
    announced.
    The MDS solution is one of the more interesting --
    interesting because it actually works<a id="footnote-5-ref" href="#footnote-5">[5]</a>,
    and because it describes all the others,
    including the Earley algorithm solution.
    MDS reduces the problem to
    the more general one of finding a "fixed point" of the recursion.
    </p>
    <p>In math, the "fixed point" of a function is an argument of
    the function which is equal to its value for that argument --
    that is, an <tt>x</tt> such that <tt>f(x)&nbsp;=&nbsp;x</tt>.
    MDS describes an algorithm which "solves" the left recursion
    for its fixed point.
    That "fixed point" can then be memoized.
    For example the value of <tt>parse_A</tt>
    can be the memoized "fixed point" value of
    <tt>&lt;A&gt;</tt>.
    </p>
    <p>The Earley solution of left recursion was, in fact, an optimized
    "fixed point".
    The computation of an Earley is the application of a set
    of rules for adding Earley items.
    This continues until no more Earley items can be added.
    In other words, the rules for building an Earley set
    are applied until they find
    their "fixed point".<a id="footnote-6-ref" href="#footnote-6">[6]</a>
    </p>
    <h2>Other top-down solutions</h2>
    <p>The MDS fixed point solution <b>does</b>
    the job,
    but as described in their paper it requires a functional
    programming language to implement,
    and it is expensive.
    In the worst case, the MDS approach is exponential,
    although they conjecture that it is linear for a large
    class of practical grammars.
    </p>
    <p>Top-down algorithms can take an "in-between strategy" --
    they can tackle those left recursions that are cheap to
    find, without computing the full "fixed point".
    Here a well-defined boundary is crucial:
    A programmer wants to know if their particular grammar will
    work,
    and whether small tweaks to their grammar will break it.
    </p>
    <p>
    Top-down can be seen as
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2015/12/topdown.html">
    a "guessing" strategy with hacks</a>.
    Hacks are always needed in top-down, because the input is at the bottom,
    not the top, and a useful top-down algorithm needs to look at the input.
    But the hacks can be as simple as lookahead,
    and lookahead can be implemented without seriously compromising
    the simplicity and flexibility of the original top-down approach.
    </p>
    <p>With detection and fixing of left-recursion,
    the "hack" part of the top-down strategy becomes very complicated.
    The attraction of top-down is its simplicity,
    and its resulting adapability to procedural logic.
    The point can be reached where the original strategy
    comes into question.
    </p>
    <p>
    After all,
    a recursive descent parser can straightforwardly take care of left recursion
    issues by calling an Earley parser.
    But in that case,
    why not simply use Earley's?
    </p>
    <h2>Comments, etc.</h2>
      Marpa is my own implementation of an Earley parser.<a id="footnote-7-ref" href="#footnote-7">[7]</a>
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on its IRC channel: #marpa at freenode.net.
    </p>
    <h2>Footnotes</h2>
<p id="footnote-1"><b>1.</b>
    I probably could have said "all practical parsing methods"
    instead of "almost all".
    Right-to-left parsing methods exist,
    but they see little use.
    In any case, they only reverse the problem.
    Parsing in both directions is certainly possible but,
    as I will show,
    we do not have to go to quite that much trouble.
 <a href="#footnote-1-ref">&#8617;</a></p>
<p id="footnote-2"><b>2.</b>
        Keshav Pingali and Gianfranco Bilardi, UTCS tech report TR-2012.
        2012.
        <a href="https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2102.pdf">
          PDF accessed 9 Junk 2018</a>.
        <a href="https://www.youtube.com/watch?v=eeZ3URxd8Wc">
          Video accessed 9 June 2018</a>.
        Less accessible is
        Keshav Pingali and Gianfranco Bilardi,
        "A graphical model for context-free grammar parsing."
        Compiler Construction - 24th International Conference, CC 2015.
        Lecture Notes in Computer Science,
        Vol. 9031, pp. 3-27, Springer Verlag, 2015.
        <a href="https://www.researchgate.net/publication/286479583_A_Graphical_Model_for_Context-Free_Grammar_Parsing">
          PDF accessed 9 June 2018</a>.
 <a href="#footnote-2-ref">&#8617;</a></p>
<p id="footnote-3"><b>3.</b>
        Matthew Might, David Darais and Daniel Spiewak.
	"Functional Pearl: Parsing with Derivatives."
	International Conference on Functional Programming 2011 (ICFP 2011).
	Tokyo, Japan. September, 2011. pages 189-195.
        <a href="http://matt.might.net/papers/might2011derivatives.pdf">
          PDF accessed 9 Jun 2018</a>.
        <a href="http://matt.might.net/papers/might2011derivatives-icfp-talk.pdf">
          Slides accessed 9 June 2018</a>.
        <a href="http://matt.might.net/media/mattmight-icfp2011-derivatives.mp4">
          Video accessed 9 June 2018</a>.
 <a href="#footnote-3-ref">&#8617;</a></p>
<p id="footnote-4"><b>4.</b>
    Those familiar with Earley's algorithm may note that
    Earley items are traditionally in terms of productions,
    not symbols.
    Symbol predictions are therefore recorded indirectly.
    <br><br>
    Specifically, Earley items are traditionally duples
    of <tt>(dr, origin)</tt>,
    where <tt>dr</tt> is a dotted production -- a production
    with a "dot location" marked;
    and <tt>origin</tt> is a location in the input.
    In all predictions <tt>origin</tt> is the current location,
    and the dot location is at the start of the production,
    so there can be at most one prediction per rule.
    A prediction of a symbol 
    <tt>&lt;A&gt;</tt>
    is recorded as a prediction of every
    production which has 
    <tt>&lt;A&gt;</tt> on its LHS.
    <br><br>
    The argument in the main text is made the way it is
    because it is simpler to speak
    of "predicted symbols" than
    to repeatedly refer to "sets of predictions
    of productions sharing a common LHS".
 <a href="#footnote-4-ref">&#8617;</a></p>
<p id="footnote-5"><b>5.</b>
    There have been many more attempts than implementations
    over the years,
    and even some of the most-widely used
    implementations <a href="https://www.youtube.com/watch?v=lFBEf0o-4sY&feature=youtu.be&t=6m29s">
    have
    their issues.</a>
 <a href="#footnote-5-ref">&#8617;</a></p>
<p id="footnote-6"><b>6.</b>
    Recall that potential left recursions are 
    recorded as "predictions" in Earley's algorithm.
    Predictions recurse,
    but since they do not depend on the input,
    they can be precomputed.
    This means that Earley implementations can
    bring each Earley set to its fixed point
    very quickly.
 <a href="#footnote-6-ref">&#8617;</a></p>
<p id="footnote-7"><b>7.</b>
        Marpa has a stable implementation.
        For it, and for more information on Marpa, there are these resources:<br>
        <a href="http://savage.net.au/Marpa.html">
          Marpa website, accessed 25 April 2018</a>.</br>
        <a href="https://jeffreykegler.github.io/Marpa-web-site/">
          Kegler's website, accessed 25 April 2018</a>.</br>
        <a href="https://github.com/jeffreykegler/Marpa--R2">
          Github repo, accessed 25 April 2018.</a></br>
        <a href="https://metacpan.org/pod/Marpa::R2">
          MetaCPAN, accessed 30 April 2018.</a>.</br>
	  There is also a theory paper for Marpa:
        Kegler, Jeffrey.
        "Marpa, A Practical General Parser: The Recognizer.", 2013.
        <a href="http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/KEGLER,%20Jeffrey%20-%20Marpa,%20a%20practical%20general%20parser:%20the%20recognizer.pdf">
          PDF accessed 24 April 2018</a>.
 <a href="#footnote-7-ref">&#8617;</a></p>
  </body>
</html>
<br />
<p>posted at: 09:15 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/lrecursion.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
