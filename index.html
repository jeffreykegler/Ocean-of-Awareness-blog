<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Thu, 23 May 2013</h3>
<br />
<center><a name="table"> <h2>Why Marpa works: table parsing</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      Marpa works very differently from the parsers
      in wide use today.
      Marpa is a table parser.
      And Marpa is unusual among table parsers --
      its focus is on speed.
    </p>
    <p>
      The currently favored parsers (recursive descent and,
      decreasing, LALR parsers like bison)
      use stacks and/or state machines.
      These have the advantage that it is easy
      to see how they can be made
      to run fast.
      They have the disadvantage of severely limiting
      what the parser can do and how much it can know.
    </p>
    <h3>What is table parsing</h3>
    <p>
      Table parsing means parsing by constructing a table of all the possible parses.
      This is pretty clearly something you want -- anything less means
      not completely knowing what you're doing.
      It's like walking across the yard blindfolded.
      It's fine if you can make sure there are
      no walls, open pits, or other dangerous obstacles.
      But for the general case,
      it's a bad idea.
    </p>
    <p>
    Where the analogy between walking blindfolded and parsing breaks
    down is that while taking off the blindfold has no cost,
    building a table of everything that is happening while you parse
    <b>does</b> have a cost.
    If you limit your parser to a stack and a state machine,
    you may be parsing with a blindfold on,
    but it is clear that your parser can be fast.
    How to make a table parser run fast
    is not so clear.
    </p>
    <h3>The advantages of table parsing</h3>
    <p>
      What are the advantages of taking off the blindfold?
      First, your parser can be completely general --
      anything you can write in BNF it can parse.
      And second,
      you always know exactly what is going on -- what rules
      are possible, what rules have been recognized,
      how far into a rule you have recognized it,
      what symbols you expect next, etc. etc.
    <p>
    </p>
      We programmers have gotten used to parsers which run blindfolded.
      Just like when you hit something blindfolded you don't know
      what it was, whether you could get around it or how,
      when these parsers fail, they don't know why.
      They can only guess.
      If you have a full parse table
      built from left to right,
      you know what you were looking for and what you already think you
      found.
      This means that you can pinpoint and identify errors precisely.
    </p>
    <p>
       Knowing where you are in a parse also allows certain tricks,
       like the one I call the Ruby Slippers.
       In this, you parse with an over-simplified grammar and,
       when it fails, you ask the parser what it was looking for.
       Then -- poof! -- you provide it.
    </p>
    <p>
       The Ruby Slippers work beautifully when dealing with
       missing tags in HTML.
       You can define a simplified HTML grammar,
       one that lives in a non-existent world --
       an ideal world where all start
       and end tags are always where they belong.
       Then you parse away.
       If, as will happen with real-world input, a tag is missing,
       you ask the table parser what it was looking for,
       and give it a virtual tag.
    </p>
    <h3>And as for fast ...</h3>
    <p>When I decided to write Marpa in 2007 my goal was to create a table parser
    that was as fast as possible.
    I was surprised to find that the academic literature contained a
    major improvement to table parsing by Joop Leo,
    one which nobody had ever made a serious attempt to implement.
    Marpa is the first implementation of Joop Leo's 1991 improvement to table parsing which,
    as far as theory goes,
    makes Marpa as fast any parser
    in practical use today.
    Any class of grammar that
    recursive descent, bison, etc. will parse,
    Marpa will parse in linear time.
    </p>
    <p>
    Table parsing has had a reputation for being slow due to a
    bad "constant factor".
    Theoreticians, when looking at speed as time complexity,
    throw away constant factors.
    What's left once the constant factor is ignored is always more
    important,
    and surprisingly often time complexity results which ignore
    constant factors are also practical.
    </p>
    But not 100% of the time.
    Sometimes the constant factor makes all the difference.
    And deciding when a constant factor does make a difference,
    and when it does not,
    is a tricky matter,
    one that lies in that murky zone between practice and theory,
    where neither practitioner or theorist feels fully at home.
    <p>
    </p>
    <p>
    It's time to look again, for two reasons.
    First, Aycock and Horspool did a lot of careful work on
    reducing
    the constant factor, work which Marpa incorporates
    and builds on.
    Second,
    the judgement about the constant factor dates from 1968,
    when computers were literally a billion
    times slower then they are now.
    <p>
    </p>
    Why has nobody re-examined this judgment as the years and the order
    of magnitude speed-ups marched by?
    When a judgement crosses sub-disciplines, it can be "sticky"
    beyond all reason,
    and this one is a good example of why.
    The decision that its "constant factor" made table parsing
    too slow for many practical applications
    is in part a practical take on a theoretical issue,
    and in part a theoretical call on a practical matter.
    <p>
    </p>
    Since 1968,
    the theoretical results have changed.
    But the theoreticians did not change
    their mind about the speed of table parsing
    because it was a judgement about the practical application
    of the theory.
    The practitioners were actually out there writing compilers.
    When it comes down to practice,
    you have to assume that practitioners know what they
    are talking about, right?
    <p>
    </p>
    Meanwhile the practice of writing software underwent
    revolution after revolution.
    But the practitioners continued to write off table parsing
    as impractical.
    Talking about the speed of table parsers quickly got you
    into some very heavy math.
    And some of the algorithms
    did not even exist except as mathematical
    notation on the pages
    of the journals and textbooks.
    When it comes down to theory about things
    that don't exist outside of theory,
    who do you listen to if not
    the theoreticians?
    </p>
    <p>
    I look carefully at the issue
    of the "constant factor" in
    <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/04/fast_enough.html">
    a previous post</a>.
    But summarizing,
    forty-five years have passed and
    cost of CPU has fallen
    nine orders of magnitude.
    (Others say the cost of CPU has dropped by 50% a year,
    in which case it's over 14 orders of magnitude.
    But why quibble?)
    It's reasonable to suspect that
    the constant factor that practitioners
    and theoreticians were worried about in 1968
    stopped being a
    major obstacle many years ago.
    </p>
    <h3>For more about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      A list of my Marpa tutorials can be found
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL">
      here</a>.
      There is
      <a href="http://marpa-guide.github.io/chapter1.html">
      a new tutorial by Peter Stuifzand</a>.
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        This blog</a> focuses on Marpa,
	and it has
	<a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">an annotated guide</a>.
	Marpa also has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>.
      For questions, support and discussion, there is a
      Google Group:
      <code>marpa-parser@googlegroups.com</code>.
      Comments on this post can be made there.
    </p>
<br />
<p>posted at: 10:52 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/05/table.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 29 Apr 2013</h3>
<br />
<center><a name="fast_enough"> <h2>Is Earley parsing fast enough?</h2> </a>
</center>
  <blockquote>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      "First we ask, what impact will our algorithm have on the parsing
      done in production compilers for existing programming languages?
      The answer is, practically none." -- Jay Earley's Ph.D thesis, p. 122.
    </blockquote>
    <p>In the above quote, the inventor of the Earley parsing
      algorithm poses a question.
      Is his algorithm fast enough for a production compiler?  His answer is a
      stark "no".
    </p>
    <p>
      This is the verdict on Earley's that you often
      hear repeated today, 45 years later.
      Earley's, it is said, has a too high a "constant factor".
      Verdicts tends to be repeated more often than examined.
      This particular verdict originates with the inventor himself.
      So perhaps it is not astonishing
      that many treat the dismissal
      of Earley's on grounds of speed to be as valid today as it
      was in 1968.
    </p>
    <p>But in the past 45 years,
      computer technology has changed beyond recognition
      and researchers
      have made several significant improvements to Earley's.
      It is time to reopen this case.
    </p><h3>What is a "constant factor"</h3>
    <p>The term "constant factor" here has a special meaning,
      one worth looking at carefully.
      Programmers talk about time efficiency in two ways:
      time complexity and speed.
    </p>
    <p>
      Speed is simple:
      It's how fast the algorithm is against the clock.
      To make comparison easy,
      the clock can be an abstraction.
      The clock ticks could be, for example, weighted instructions
      on some convenient and mutually-agreed architecture.
    </p>
    <p>
      By the time Earley was writing, programmers had discovered that simply comparing
      speeds,
      even on well-chosen abstract clocks, was not enough.
      Computers were improving very quickly.
      A speed result
      that was clearly significant when the comparison was made
      could quickly become unimportant.
      Researchers needed to
      talk about time efficiency in a way that made what they said as true
      decades later as on the day they said it.
      To do this, researchers created the idea of time complexity.
    </p>
    <p>Time complexity is measured using several notations, but the most
      common is
      <a href="http://en.wikipedia.org/wiki/Big_O_notation">big-O
        notation</a>.
      Here's the idea:
      Assume we are comparing two algorithms, Algorithm A and Algorithm B.
      Assume that algorithm A uses 42 weighted instructions for each input symbol.
      Assume that algorithm B uses 1792 weighted instructions for each input symbol.
      Where the count of input symbols is N,
      A's speed is 42*N, and B's is 1792*N.
      But the time complexity of both is the same: O(N).
      The big-O notation throws away the two "constant factors", 42 and 1792.
      Both are said to be "linear in N".
      (Or more often, just "linear".)
    </p>
    <p>It often happens that algorithms we need to compare for time efficiency
      have different speeds,
      but the same time complexity.
      In practice,
      this usually this means we can treat them as having essentially
      the same time efficiency.
      But not always.
      It sometimes happens that this difference is relevant.
      When this happens, the rap against the slower algorithm is that it
      has a "high constant factor".
    </p>
    <h3>OK, about that high constant factor</h3>
    <p>What is the "constant factor" between Earley and the current favorite
      parsing algorithm, as a number?
      (My interest is practical, not historic,
      so I will be talking about Earley's
      as modernized by Aycock, Horspool, Leo and myself.
      But much of what I say applies to Earley's algorithm in general.)
    </p>
    <p>What the current favorite parsing algorithm is
      can be an interesting question.
      When Earley wrote, it was hand-written recursive descent.
      The next year (1969) LALR parsing was invented,
      and the year after (1970) a tool that used it was introduced -- yacc.
      At points over the next decades,
      yacc chased both Earley's
      and recursive descent almost completely out of the textbooks.
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2010/09/perl-and-parsing-6-rewind.html">
        But as I have detailed elsewhere</a>,
          yacc had serious problems.
          In 2006 things went full circle -- the industry's standard C
          compiler, GCC, replaced LALR with recursive descent.
        </p>
    <p>So back to 1970.
    That year, Jay Earley wrote up his algorithm for
    "Communications of the ACM",
      and put a rough number on his "constant factor".
      He said that his algorithm was an "order of magnitude" slower
      than the current favorites -- a factor of 10.
      Earley suggested ways to lower this 10-handicap,
      and modern implementations have followed up on them
      and found others.
      But for this post,
      let's concede the factor of ten and throw
      in another.
      Let's say Earley's is 100 times slower than the current favorite,
      whatever that happens to be.
    </p>
    <h3>Moore's Law and beyond</h3>
    <p>Let's look at the handicap of 100
      in the light of Moore's Law.
      Since 1968, computers have gotten a billion times faster -- nine orders
      of magnitude. Nine factors of ten.
      This means that today Earley's runs
      seven factors of ten faster than
      the current favorite algorithm did in
      1968.
      Earley's is 10 million times as fast as the algorithm that was
      then considered practical.
    </p>
    <p>
      Of course, our standard of "fast enough to be practical" also evolves.
      But it evolves a lot more slowly.
      Let's exaggerate
      and say that "practical" meant "takes an hour" in 1968,
      but that today we would demand that the same program take only a second.
      Do the arithmetic and you find that Earley's is now
      more than 2,000 times faster than it needs to be to be practical.
    </p>
    <p>Bringing in Moore's Law is just the beginning.
      The handicap Jay Earley gave his algorithm
      is based on a straight comparison of CPU speeds.
      But parsing, in practical cases, involves I/O.
      And the "current favorite" needs to do as much I/O as Earley's.
      I/O overheads, and the accompanying context switches,
      swamp considerations of CPU speed,
      and that is more true today
      that it was in 1968.
      When an application is I/O bound, CPU is in effect free.
      Parsing may not be I/O bound in this sense, but neither
      is it one of those applications where the comparison can be made
      in raw CPU terms.
    </p>
    <p>Finally, pipelining has changed
      the nature of the CPU overhead itself radically.
      In 1968, the time to run a series of CPU
      instructions varied linearly with the number of instructions.
      Today, that is no longer true,
      and the change favors strategies like Earley's,
      which require a higher instruction count,
      but achieve efficiency in other ways.
    </p>
    <h3>Achievable speed</h3>
    <p>
      So far, I've spoken in terms of theoretical speeds, not achievable ones.
      That is, I've assumed that both Earley's
      and the current favorite are producing their best speed, unimpeded by
      implementation considerations.
    </p>
    <p>
      Earley, writing in 1968 and thinking of hand-written recursive descent,
      assumed that production compilers
      could be, and in practice usually would be,
      written by
      programmers with plenty of time to do
      careful and well-thought-out hand-optimization.
      After forty-five years of real-life experience,
      we know better.
    </p>
    <p>
      In those widely used practical compilers and interpreters
      that rely on lots of procedural logic --
      and these days that is almost all of them --
      it is usually all the maintainers can do to keep the procedural logic correct.
      In all but a few cases, optimization is opportunistic,
      not systematic.
      Programmers have been exposed to
      the realities of parsing with
      large amounts of complex procedural logic,
      and hand-written recursive descent has acquired a
      reputation for being slow.
    </p>
    <p>
      In theory,
      LALR based compilers are less dependent on procedural
      parsing and therefore easier to keep optimal.
      In practice they are as bad or worse.
      LALR parsers usually still need a considerable amount of procedural logic,
      but procedural logic is harder to write for LALR than it
      is for recursive descent.
    </p>
    <p>Modern Earley parsing
      has a much easier time actually delivering
      its theoretical best speed in practice.
      Earley's is powerful enough,
      and in its modern version well-enough aware of the state of the parse,
      that procedural logic can be kept to minimum or eliminated.
      Most of the parsing is done by the mathematics at its core.
    </p>
    <p>
      The math at Earley's core can be heavily optimized,
      and any optimization benefits all applications.
      Optimization of special-purpose procedural logic benefits
      only the application that uses that logic.
    </p>
    <h3>Other considerations</h3>
    <p>But you might say,
    </p><blockquote>
      "A lot of interesting points, Jeffrey, but all things being
      equal, a factor of 10,
      or even what's left from a factor of ten once I/O,
      pipelining and implementation inefficiencies have all nibbled away at it,
      is still worth having.
      It may in a lot of instances not even be measurable, but why not grab
      it for the sake of the cases where it is?"
    </blockquote><p>
      Which is a good point.
      The "implementation inefficiences" can be nasty enough that Earley's is in
      fact faster in raw terms,
      but let's assume
      that some cost in speed is still being paid for the use of Earley's.
      Why incur that cost?
    </p><h4>Error diagnosis</h4><p>
      The parsing algorithms currently favored,
      in their quest for efficiency,
      do not maintain full
      information about the state of the parse.
      This is fine when the source is 100% correct,
      but in practice an important function of a parser is to find and
      diagnose errors.
      When the parse fails, the current favorites
      often have little idea of why.
      An Earley parser knows the full state of the parse.
      This added knowledge can save a lot of
      programmer time.
    </p><h4>Readability</h4>
    <p>
      The more that a parser does from the grammar,
      and the less procedural logic it uses,
      the more readable the code will be.
      This has a determining effect on maintainance costs
      and the software's ability to evolve over time.
    </p><h4>Accuracy</h4>
    <p>Procedural logic can produce inaccuracy -- inability
      to describe or control the actual language begin parsed.
      Some parsers, particularly LALR and PEG,
      have a second major source of inaccuracy -- they use
      a precedence scheme for conflict resolution.
      In specific cases, this can work, but
      precedence-driven conflict resolution
      produces a language without
      a "clean" theoretical description.
    </p>
    <p>
      The obvious problem with not knowing what language you
      are parsing is failure to parse correct source code.
      But another, more subtle, problem can be worse over the
      life cycle of a language ...
    </p>
    <h4>False positives</h4>
    <p>False positives are cases
      where the input is in error,
      and should be reported as such, but instead
      the result is what you wanted.
      This may sound like unexpected good news,
      but when a false positive does surface,
      it is quite possible that it cannot be fixed
      without breaking code that, while incorrect, does work.
      Over the life of a language, false positives are deadly.
      False positives produce buggy and poorly understood code
      which must be preserved and maintained forever.
    </p>
    <h4>Power</h4>
    <p>
      The modern Earley implementation can parse vast classes
      of grammar in linear time.
      These classes include all those currently in practical use.
    </p><h4>Flexibility</h4>
    <p>Modern Earley implementations
      parse all context-free grammars in times that are, in practice,
      considered optimal.
      With other parsers,
      the class of grammars parsed is highly restricted,
      and there is usually a real danger that a new change
      will violate those restrictions.
      As mentioned,
      the favorite alternatives to Earley's
      make it hard to know exactly what language you are,
      in fact, parsing.
      A change can break one of these parsers
      without there being any indication.
      By comparison,
      syntax changes and extensions to Earley's grammars
      are carefree.
    </p>
    <h3>For more about Marpa</h3>
    <p>
      Above I've spoken of "modern Earley parsing",
      by which I've meant Earley parsing as amended and improved
      by the efforts of Aho, Horspool, Leo and myself.
      At the moment, the only implementation that contains
      all of these modernizations is Marpa.
    </p>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      Marpa's
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.052000/pod/Scanless/DSL.pod">SLIF
        is
        a new interface</a>,
      which represents a major increase
      in Marpa's "whipitupitude".
      The SLIF has tutorials
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">here
      </a>
      and
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">
        here</a>.
      Marpa has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>,
      and of course it is the focus of
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        my "Ocean of Awareness" blog</a>.
    </p>
    <p>
      Comments on this post
      can be sent to the Marpa's Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 11:12 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/04/fast_enough.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 22 Apr 2013</h3>
<br />
<center><a name="procedural"> <h2>Marpa's SLIF now allows procedural parsing</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>
      Marpa's SLIF (scanless interface)
      allows an application to parse directly from any BNF grammar.
      Marpa parses vast classes of grammars in linear time,
      including all those classes currently in practical use.
      With
      <a href="https://metacpan.org/release/Marpa-R2">
        its latest release</a>,
      Marpa::R2's SLIF
      also allows an application to intermix
      its own custom lexing and parsing logic
      with Marpa's,
      and to switch back and forth between them.
      This means,
      among other things,
      that Marpa's SLIF can now
      do procedural parsing.
    </p>
    <p>
      What is procedural parsing?
      Procedural parsing is parsing using
      ad hoc code in a procedural language.
      The opposite of procedural parsing is declarative parsing
      -- parsing driven by some kind of formal description
      of the grammar.
      Procedural parsing
      may be described as what you do when you've given up
      on your parsing algorithm.
      Dissatisfaction with parsing theory
      has left modern programmers accustomed to procedural parsing.
      And in fact some problems are best tackled with procedural parsing.
    </p>
    <h3>An example</h3>
    <p>
      One such problem is parsing Perl-style here-documents.
      Peter Stuifzand has tackled this using
      <a href="https://metacpan.org/release/JKEGL/Marpa-R2-2.052000">
        the
        just-released version of Marpa::R2</a>.
      For those unfamiliar, Perl allows documents to be incorporated
      into its source files in line-oriented fashion as "here-documents".
      Here-documents can be used in expressions.
      The syntax to do this is very handy, if a little strange.
      For example,
    </p>
    <blockquote><pre>
say &lt;&lt;ENDA, &lt;&lt;ENDB, &lt;&lt;ENDC; say &lt;&lt;ENDD;
a
ENDA
b
ENDB
c
ENDC
d
ENDD</pre></blockquote>
    <p>
      starts with a single line declaring four here-documents spread out
      over two
      <tt>say</tt>
      statements.
      The expressions of the form
    </p><blockquote><pre>&lt;&lt;ENDX</pre></blockquote><p>
      are here-document expressions.
      <tt>&lt;&lt;</tt>
      is the heredoc operator.
      The string which follows it (in this example,
      <tt>ENDA</tt>,
      <tt>ENDB</tt>, etc.) is the heredoc terminator string --
      the string that will signal end
      of body of the here-document.
      The body of the here-documents follow, in order, over the next eight lines.
      More details of here-document syntax, with examples, can be found
      in
      <a href="http://perldoc.perl.org/perlop.html#Quote-Like-Operators">the
        Perl documentation</a>.
    </p>
    <p>All of this poses quite a challenge to a parser-lexer combination,
      which is one reason I chose it as an example --
      to illustrate that the Marpa's SLIF support for procedural parsing can
      handle genuinely difficult cases.
      There are a few ways Marpa could approach this.
      The one
      Peter Stuifzand chose was to
      to read the
      here-document's body as the value of the terminator in
      each
      <tt>&lt;&lt;ENDX</tt>
      expression.
    </p>
    <p>
      The strategy works this way:
      Marpa allows the application to mark certain lexemes as "pause" lexemes.
      Whenever a "pause" lexeme is encountered, Marpa's internal scanning stops,
      and control is handed over to the application.
      In this case, the application is set up to pause after every newline,
      and before the terminator in every here-document expression.
    </p>
    <p>
      While reading the line containing the four here-document expressions,
      Marpa's SLIF pauses and resumes five times -- once for each here-document expression,
      then once for the final newline.
      Details can be found in compact form in the heavily commented code
      in
      <a href="https://gist.github.com/jeffreykegler/5431739">this
        Github gist</a>.
    </p>
    <h3>Marpa as a better procedural parser</h3>
    <p>So far I've talked in terms of Marpa "allowing" procedural parsing.
      In fact, there can be much more to it.
      Marpa can make procedural parsing easier and more accurate.
    </p>
    <p>Marpa knows, at every point, which rules it is recognizing, and how far it
      is into them.
      Marpa also knows which new rules the grammar expects, and which terminals.
      The procedural parsing logic can consult this information to guide its decisions.
      Marpa can provide your procedural parsing logic with radar,
      as well as the option to use a very smart autopilot.
    </p>
    <h3>For more about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      Marpa's
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.052000/pod/Scanless/DSL.pod">SLIF
        is
        a new interface</a>,
      which represents a major increase
      in Marpa's "whipitupitude".
      The SLIF has tutorials
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">here
      </a>
      and
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">
        here</a>.
      Marpa has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>,
      and of course it is the focus of
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        my "Ocean of Awareness" blog</a>.
    </p>
    <p>
      Comments on this post
      can be sent to the Marpa's Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 00:03 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/04/procedural.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sat, 23 Mar 2013</h3>
<br />
<center><a name="what_if_free"> <h2>What if languages were free?</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>In 1980, George Copeland wrote
      <a href="http://dl.acm.org/citation.cfm?id=802685">
    an article</a>
    titled "What if Mass Storage were Free?".
      Costs of mass storage were showing signs
      that they might fall dramatically.
      Copeland, as a thought exercise, took this trend to its extreme.
      Among other things, he predicted that deletion would become
      unnecessary, and in fact, undesirable.
    </p>
    <p>Copeland's
      thought experiment has proved prophetic.
      For many purposes, mass storage is treated as if it were free.
      For example, you probably retrieved this blog post from a server
      provided to me at no charge, in the hope
      that I might write and upload something interesting.
    </p>
    <p>
      Until now languages were high-cost efforts.
      Worse, language projects ran a high risk of disappointment,
      up to and including total failure.
      I believe those days are coming to an end.
    </p>
    <h3>Small languages, shaped to the problem domain</h3>
    <p>What if whenever you needed a new language, poof, it was there?
      You would be encouraged to tackle each problem domain with
      a new language dedicated to dealing with that domain.
      Since each language is no larger than its problem domain,
      learning a language would be essentially the same as learning
      the problem domain.
      The incremental effort required to learn the language
      itself would head toward zero.
    </p>
    <h3>No more language bloat</h3>
    <p>Language bloat would end.
      Currently, the risk and cost of developing languages
      make it imperative to extend the ones we have.
      Free languages mean fewer reasons to add features
      to existing languages.
    </p>
    <h3>No more search for THE perfect language</h3>
    <p>
      No language is perfect for all tasks.
      But because the high cost of languages favors
      large, general-purpose languages,
      we are compelled to try for perfection anyway.
      Ironically, we are often making the language worse,
      and we know it.
    </p>
    <h3>A world full of perfect languages</h3>
    <p>An older sense of the word perfect is
      "having all the properties or qualities requisite to its nature and kind".
      The C language might be called perfect in this sense.
      C lacks a lot of features that are highly desirable in most contexts.
      But for programming that is portable
      and close to the hardware,
      the C language is perfect or close to it.
      If languages were free, this is the kind of perfection
      that we would seek --
      languages precisely fitted to their domain,
      so that adding to them cannot make them better.
    </p>
    <h3>Moving toward free</h3>
    <p>
      My own effort to contribute to 
      a fall in the cost of languages is the Marpa parser.
      Marpa produces a reasonable parser
      for every language you can write in BNF.
      If the BNF is for a grammar in any of the classes currently in practical
      use, the parser Marpa produces will have linear speed.
      In one case, using Marpa,
      <a href="https://gist.github.com/4447349">a targeted language</a>
      was written
      in less than an hour.
      <a href="http://blogs.perl.org/users/jeffrey_kegler/2013/01/a-language-for-writing-languages.html">
        More typically</a>, Marpa reduce the time needed to create new languages to hours.
    </p>
    <p>As one example of going from "impossible" to "easy",
      I have written a drop-in solution to an example in the
      <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang
        of Four book</a>.
      The Gang of Four described a language
      and its interpretation,
      but they did not include a parser.
      Creating a parser
      to fit their example would have been
      impossibly hard when the Gang of Four wrote.
      Using Marpa, it is easy.
      The parser can be found in
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/03/bnf_to_ast.html">this
        earlier blog post</a>.
    </p>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      Recently, it has gained immensely in "whipitupitude" with
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.048000/pod/Scanless/DSL.pod">
        a new interface</a>,
      which has tutorials
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">here
      </a>
      and
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">
        here</a>.
      Marpa has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>,
      and of course it is the focus of
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        my "Ocean of Awareness" blog</a>.
    </p>
    <p>
      Comments on this post
      can be sent to the Marpa's Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 10:16 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/03/what_if_free.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Wed, 20 Mar 2013</h3>
<br />
<center><a name="interpreter"> <h2>The Interpreter Design Pattern</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>The influential
      <a href="http://en.wikipedia.org/wiki/Design_Patterns">
        <em>Design Patterns</em>
        book</a>
      lays out 23 patterns for programming.
      One of them, the Interpreter Pattern, is rarely used.
      Steve Yegge puts it a bit more strikingly -- he says
      that the book contains
      <a href="https://sites.google.com/site/steveyegge2/ten-great-books">22
        patterns and a practical joke</a>.
    </p>
    <p>That sounds (and in fact is) negative, but
      <a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html">
        elsewhere</a>
      Yegge says that
      "[t]ragically, the only [Go4] pattern that can help code get smaller
      (Interpreter) is utterly ignored by programmers".
      (The
      <i>Design Patterns</i>
      book has four authors,
      and is often called the Gang of Four book, or Go4.)
    </p>
    <p>
      In fact, under various names and definitions, the
      Interpreter Pattern and its close relatives and/or identical twins
      are widely cited,
      much argued and highly praised<a href="#NOTE1">[1]</a>.
          As they should be.
          Languages are the most powerful and flexible design pattern of all.
          A language can include all, and only, the concepts relevent
          to your domain.
          A language can allow you to relate them in all, and only, the appropriate ways.
          A language can identify errors with pinpoint precision,
          hide implementation details,
          allow invisible "drop-in" enhancements, etc., etc., etc.
        </p>
    <p>
      In fact languages are so powerful and flexible,
      that their use is pretty much universal.
      The choice is not whether or not to use a language to solve
      the problem,
      but whether to use
      a general-purpose language,
      or a domain-specific language.
      Put another way,
      if you decide not to use a language targeted
      to your domain,
      it almost always means that you
      are choosing to use another language that is not specifically
      fitted to your domain.
    </p>
    <p>
      Why then, is the Interpreter Pattern so little used?
      Why does Yegge call it a practical joke?
    </p>
    <h3>There's a problem</h3>
    <p>The problem with the Interpreter Pattern is that you must
      turn your language into an AST --
      that is,
      you must parse it somehow.
      Simplifying the language can help here.
      But if the point is to be simple at the expense of power
      and flexibility,
      you might as well
      stick with the other 22 design patterns.
    </p>
    <p>
      On the other hand,
      creating a parser for anything but the simplest languages
      has been a time-consuming effort,
      and one of a kind known for disappointing results.
      In fact,
      language development efforts run
      a real risk of total failure.
    </p>
    <p>How did the Go4 deal with this?
      They defined the problem away.
      They stated that the parsing issue was separate from the
      Interpreter Pattern, which was limited to what you did with the AST
      once you'd somehow come up with one.
    </p>
    <p>
      But AST's don't (so to speak) grow on trees.
      You have to get one from somewhere.
      In their example, the Go4 simply built an AST in their code,
      node by node.
      In doing this, they bypassed the BNF and the problem of parsing.
      But they also bypassed their language and the whole point
      of the Interpreter Pattern.
    </p>
    <p>
      Which is why Yegge characterized the chapter as a practical joke.
      And why other programming techniques and patterns are almost
      always preferred to the Interpreter Pattern.
    </p>
    <h3>Finding that one missing piece</h3>
    <p>So that's how the Go4 left things.
      A potentially great programming technique,
      made almost useless because
      of a missing piece.
      There was no easy, general, and practical way to generate AST's.
    </p>
    <p>
      Few expected that to change.
      I was more optimistic than most.
      In 2007 I embarked on a full-time project:
      to create a parser based on Earley's algorithm.
      I was sure that it would fulfill two of the criteria --
      it would be easy to use, and it would be general.
      As for practical -- well, a lot of parsing problems
      are small, and a lot of applications don't require a lot
      of speed, and for these I expected the result to be good enough.
    </p>
    <p>What I didn't realize was that
      all of the problems preventing
      Earley's from seeing real, practical use
      has already been solved in the academic literature.
      I was not alone in not having put the picture together.
      The people who had solved the problems
      had focused on two disjoint sets of issues,
      and were unaware of each other's
      work.
      In 1991, in the Netherlands,
      the mathematican Joop Leo had
      arrived at an astounding result --
      he showed how to make Earley's run in linear time for LR-regular grammars.
      LR-regular is a vast class of grammars.
      It easily includes, as a proper subset, every class of grammar now
      in practical use -- regular expressions, PEG, recursive descent,
      the LALR on which yacc and bison are based, you name it.
      (For those into the math,
      LR-regular includes LR(k)
      for all <i>k</i>,
      and therefore LL(k),
      also for all <i>k</i>.)
      </p>
      <p>
      Leo's mathematical approach did not address some nagging practical issues,
      foremost among them the handling of nullable rules and symbols.
      But ten years later in Canada,
      Aycock and Horspool focused on exactly these issues,
      and solved them.
      Aycock-Horspool
      seem to have been unaware of Leo's earlier result.
      The time complexity of the Aycock-Horspool
      algorithm was essentially that of
      Earley's original algorithm.
    </p>
    <p>
      Because of Leo's work,
      for any grammar in any class currently in practical use,
      an Earley's parser could be fast.
      If only it could be combined with the approach
      of Aycock and Horspool, I realized,
      Leo's speeds could be available in an everyday programming tool.
    </p>
    <p>
      In changing the Earley parse engine,
      Aycock-Horspool and Leo had branched off in different directions.
      It was not obvious that their approaches could be combined, much less how.
      And in fact, the combination of the two is not a simple algorithm.
      But it is fast,
      and the new Marpa parse engine makes full information
      about the state of the parse (rules recognized, symbols expected, etc.)
      available as it proceeds.
      This is very convenient for, among other things, error reporting.
    </p>
    <h3>Eureka and all that</h3>
    <p>The result is an algorithm which parses anything
      you can write in BNF and
      does it in times considered optimal in practice.
      Unlike recursive descent, you don't have to write out the parser --
      Marpa generates a parser for you, from the BNF.
      It's the easy, "drop-in" solution that the Go4 needed and did not have.
      A reworking of the Go4 example, with the missing parser added,
      is in
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/03/bnf_to_ast.html">a
        previous blog post</a>, and the code for the reworking is in
      <a href="https://gist.github.com/jeffreykegler/5121769">
        a Github gist</a>.
    </p>
    <h3>More about Marpa</h3>
    <p>
      Marpa's latest version is
      <a href="https://metacpan.org/module/Marpa::R2">Marpa::R2,
        which is available on CPAN</a>.
      Recently, it has gained immensely in "whipitupitude" with
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.048000/pod/Scanless/DSL.pod">
        a new interface</a>,
      which has tutorials
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">here
      </a>
      and
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">
        here</a>.
      Marpa has
      <a href="http://jeffreykegler.github.com/Marpa-web-site/">a web page</a>,
      and of course it is the focus of
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        my "Ocean of Awareness" blog</a>.
    </p>
    <p>
      Comments on this post
      can be sent to the Marpa's Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
    <h3>Notes</h3>
    <p><a name="NOTE1">Note 1</a>:
      For example,
      <a href="http://en.wikipedia.org/wiki/Domain-specific_language">the Wikipedia article on DSL's</a>;
      <a href="http://www.faqs.org/docs/artu/minilanguageschapter.html">Eric Raymond discussing mini-languages</a>;
      <a href="http://www.dmst.aueb.gr/dds/pubs/jrnl/2000-JSS-DSLPatterns/html/dslpat.html">
        "Notable Design Patterns for Domain-Specific Languages"</a>, Diomidis Spinellis; and
      <a href="http://www.c2.com/cgi/wiki?DomainSpecificLanguage">the c2.com wiki</a>.
    </p>
<br />
<p>posted at: 10:16 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/03/interpreter.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
