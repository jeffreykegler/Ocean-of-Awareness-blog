<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 08 Oct 2012</h3>
<br />
<center><a name="config_html"> <h2>A Configurable HTML Parser</h2> </a>
</center>
    <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment
      -->
      This post introduces an HTML parser which is both liberal and configurable.
      Marpa::R2::HTML allows detailed
      configuration of new tags
      and reconfiguration of existing tags,
    </p><p>
      In this post, I'd like to start simple.
      Let's suppose we have a new tag, call it
      <code>
        &lt;acme&gt;</code>.
      Already, the non-configurable version of Marpa, like most browsers,
      would recognize this tag.
      But they'd simply give it a default configuration,
      one which is usually very liberal --
      liberal meaning it allowed the tag to contain just about anything,
      and go just about anywhere.
      Let's try to be more restrictive.
    </p><h3>
      Block vs. inline</h3><p>
      In this post
      I am going to assume that the reader knows,
      or will look up what he needs to know,
      about HTML.
      But block vs. inline is a essential HTML concept
      which is often ignored -- even the excellent Wikipedia page on HTML
      does not define "inline", although it uses the term in the technical
      sense twice.
      Since the concept is also central to this post,
      let me briefly summarize it.
    </p><p>
      Quoting from the
      <a href="http://www.w3.org/TR/1999/PR-html40-19990824/sgml/dtd.html#inline">
        HTML 4.01 Strict DTD</a>,
    </p><blockquote>
      <pre>
      HTML has two basic content models:

        %inline;     character level elements and text strings
        %block;      block-like elements e.g. paragraphs and lists
</pre>
    </blockquote>
    <p>
      There is also what I will call a "mixed flow",
      which can contain anything that
      can appear in either a block or inline flow.
      (What I call a mixed flow is
      simply called a "flow"
      in the HTML 4.01 DTD.)
    </p><p>
      Archetypal elements are
      <code>
        &lt;p&gt;</code>,
      which is a block element that contains an inline flow;
      <code>
        &lt;span&gt;</code>,
      which is an inline element that contains an inline flow;
      and
      <code>
        &lt;div&gt;</code>,
      which is an block element that contains an mixed flow.
    </p>
    <h3>
      Controlling element context</h3>
    <p>
      Let's define the
      <code>
        &lt;acme&gt;</code>
      tag
      to be an inline tag with inline contents.
      This is done by adding the following line to the
      Marpa::R2::HTML grammar configuration file:
    </p>
<blockquote><pre>
ELE_marpa is a FLO_inline included in GRP_inline
</pre></blockquote><p>
      Let's take as our HTML, the following:
    </p>
<blockquote><pre>
&lt;marpa&gt;-during-&lt;span&gt;-more inline stuff-&lt;p&gt;-new block-
</pre></blockquote><p>
      Here's the result,
      with tags added to show the structure
      in detail.
    </p>
<!-- examples/acme-inline-inline.out -->
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;
      &lt;acme&gt;
        -during-&lt;span&gt;
          -more inline stuff-&lt;/span&gt;&lt;/acme&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<!-- examples/acme-block-inline.out -->
<blockquote><pre>
ELE_acme is a FLO_x included in GRP_y
</pre></blockquote>
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/acme&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<!-- examples/acme-block-mixed.out -->
<blockquote><pre>
ELE_acme is a FLO_x included in GRP_y
</pre></blockquote>
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;p&gt;
        -new block-
      &lt;/p&gt;&lt;/acme&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<!-- examples/acme-block-block.out -->
<blockquote><pre>
ELE_acme is a FLO_x included in GRP_y
</pre></blockquote>
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      &lt;p&gt;
        -during-&lt;span&gt;
          -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
        -new block-
      &lt;/p&gt;&lt;/acme&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<!-- examples/acme-block-pcdata.out -->
<blockquote><pre>
ELE_acme is a FLO_x included in GRP_y
</pre></blockquote>
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
      -during-&lt;/acme&gt;&lt;p&gt;
      &lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<!-- examples/acme-block-empty.out -->
<blockquote><pre>
ELE_acme is a FLO_x included in GRP_y
</pre></blockquote>
<blockquote><pre>
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;acme&gt;
    &lt;/acme&gt;&lt;p&gt;
      -during-&lt;span&gt;
        -more inline stuff-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
      -new block-
    &lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>
<br />
<p>posted at: 17:46 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Fri, 14 Sep 2012</h3>
<br />
<center><a name="quantum"> <h2>Parsing on your new hyper-quantum computer</h2> </a>
</center>
    <blockquote>
      <!--
      perl ./marpa_r2_html_fmt
      -->
      <i>
        If you want to build a ship, don't drum up the men to gather wood,
        divide the work and give orders. Instead, teach them to yearn for
        the vast and endless sea.</i>
      -- Antoine de Saint-Exupery
    </blockquote>
    <p>
      Imagine that, the day the new machine arrives,
      you are maintaining a parser.
      Your parser
      is the current state of the art
      -- hand-written recursive descent.
    </p><p>
    </p>
    The new computer will
    replace your staid old von Neumann box is not
    just a quantum computer.
    It's fully non-deterministic.
    You can superposition any time you'd like,
    and then "unsuperposition" to restart.
    And when superpositioning, you can can examine
    <strong>
      all</strong>
    the possibilities, not just one.
    <p>
      How would you rewrite your
      recursive descent logic to take advantage of this new hyper-quantum computer?
      Actually, this is exactly the same question that
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>
      poses
      to you today.
      Because for all classes of grammar in practical use, including
      the LL(k) grammars parseable by recursive descent,
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>
      is efficient non-determinism.
    </p>
    <p>
      Your new hyper-quantum computer
      might seem at first to make your work as a programmer harder.
      On the hyper-quantum computer,
      many things are happening at once.
      On the deterministic box,
      you were dealing with a single procedural thread.
    </p>
    <p>
      But as you get used to the new non-deterministic computer,
      you find ways in which it makes things easier.
      On the deterministic box,
      you only needed to follow a single thread,
      but you often needed to make that thread
      deal with multiple alternatives.
      To do this, you had to create
      state information and keep track of it yourself
      while backtracking.
      The complexity of dealing with
      all this roll-your-own state
      information severely limited the kinds of grammar that you could parse,
      and even the extent to which you understood exactly what your parser
      would and would not accept.
      Since much of the time on your old parser was spent
      backtracking,
      you no longer had a real handle on the
      time complexity in many sections of your code.
      In a couple of previous releases,
      minor changes had let the backtracking get out of hand.
    </p>
    <p>
      The hyper-quantum computer
      now comes up with the parsing
      alternatives for you.
      True, you have to retrain yourself to think in terms of the alternatives
      available at any point.
      But you don't even have to know which alternatives are there --
      if you need to ask the hyper-quantum computer (or
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa</a>),
      <a href="https://metacpan.org/module/Marpa::R2::Progress">
        it can tell you</a>.
    </p>
    <p>
      You do have to learn to ask the right questions
      at the right places.
      Once you do this,
      you have a simpler and more cleanly written parser,
      running at comparable or faster speeds.
      And you begin to think about a few changes to
      the language,
      changes that will make your language more
      natural and expressive,
      but one which
      you could not have parsed before.
    </p>
<br />
<p>posted at: 21:38 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/quantum.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Thu, 13 Sep 2012</h3>
<br />
<center><a name="html_fmt"> <h2>A Marpa-based HTML reformatter</h2> </a>
</center>
    <p>
      <!--
      perl ./marpa_r2_html_fmt
      -->
      This post is about
      <tt>
        html_fmt</tt>,
      a
      <a href="http://jeffreykegler.github.com/Marpa/">
        Marpa-</a>based
      reformatter ("tidier") for liberal HTML.
      <tt>
        html_fmt</tt>
      indents HTML according to the structure of the document,
      which makes the HTML a lot easier to read.
      In the process
      <tt>
        html_fmt</tt>
      adds missing start and end tags and identifies "cruft".
    </p>
    <p>
      <tt>
        html_fmt</tt>
      is ultra-liberal about its input.
      Like a browser's rendering engine,
      <tt>
        html_fmt</tt>
      never rejects a file,
      no matter how defective it is as an HTML document.
      An interesting experiment would be to compare what your
      favorite browser does with a random text file feed to
      it directly,
      with what it does to the same file
      after it has been passed through
      <tt>
        html_fmt</tt>.
    </p>
    <p>
      <tt>
        html_fmt</tt>
      is a by-product of moving
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
        this blog to Github</a>.
      In the course of bringing over
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">
        my old posts</a>,
      I wanted a filter that would tidy them up,
      so I turned to an old demo script I'd written.
      The old demo's usefulness was a pleasant surprise,
      but it lacked two features.
      First, it wouldn't read from standard input.
      Second, in formatting the HTML, it introduced new whitespace.
      The first problem was easy to fix.
      Fixing the second involved coming up with a
      "lowest common denominator" for whitespace treatment
      among browsers and HTML variants.
    </p>
    <p>
      The result,
      <tt>
        html_fmt</tt>,
      works very well as the first step in dealing with HTML
      that you are rewriting by hand.
      One quick pass-through and your file is much easier to read,
      has all the proper tags,
      and has comments pointing out any "cruft" that's there.
    </p>
    <p>
      A production quality "tidier" would need to be something like
      <tt>
        gnuindent</tt>
      --
      bristling with options.
      <tt>
        html_fmt</tt>
      so far has only two options,
      one dealing with whitespace before end tags,
      the other allowing
      a choice of strategies for avoiding added whitespace.
      (One strategy uses comments, while the other simply leaves
      the whitespace-sensitive locations as-is.)
      These two options are not nearly
      sufficient to deal with the full
      range of whitespace issues,
      never mind anything else.
    </p>
    <p>
      But from a
      <a href="http://blog.plover.com/oops/blosxom-sux.html">
        "Worse is Better"</a>
      point of view,
      <tt>
        html_fmt</tt>
      is a good start.
      It is 600 lines,
      short enough to find your
      way around in,
      particularly once you've deleted the parts you don't like.
      And its underlying Marpa-based interface is documented:
      <a href="https://metacpan.org/module/Marpa::R2::HTML">
        Marpa::R2::HTML</a>.
      Marpa::R2::HTML is beta, but has been stable for some time.
    </p>
    <p>
      <a href="https://gist.github.com/3725639">
      <tt>
        html_fmt</tt>
      is now available as a gist.</a>
      In a future release of
      <a href="https://metacpan.org/release/Marpa-R2">
        Marpa::R2</a>,
      it will be available as the
      <tt>
        marpa_r2_html_fmt</tt> script.
      But why wait until then to fork it?
    </p>
<br />
<p>posted at: 20:08 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/html_fmt.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 03 Sep 2012</h3>
<br />
<center><a name="r2_is_beta"> <h2>Marpa::R2 is beta</h2> </a>
</center>
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
is now beta.
Marpa is a new parsing algorithm,
based on decades of prior art.
It is a practical and efficient solution
targeted at all parsing problems that are too
complex for regular expressions.
<p>
The
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
module is the most recent Marpa module.
Marpa is also available as the
<a href="https://metacpan.org/release/Marpa-XS">
Marpa::XS</a>
module,
which is stable and bug-fix only.
Both Marpa modules:
<ol>
<li><p>Parse everything you can write in BNF.
<li><p>
Parse all
classes of grammar in practical use today in linear time.
<li><p>Parse all BNF grammars
in times considered theoretically optimal.
For unambiguous grammars, Marpa is never worse than
O(n<sup>2</sup>).
For ambiguous grammars, Marpa is never worse than
O(n<sup>3</sup>).
Marpa never goes exponential.
<li><p>
Are fully aware, at every point in the parse, of
all the rules they are parsing,
how far into them they have proceeded,
and of what tokens they expect next.
Especially with Marpa::R2,
this information is available
to the application
conveniently and efficiently.
<li><p>
Do not need to be handwritten.
Marpa is available as a open-source library.
It is written in C,
and the C library can be used
<a href="http://jeffreykegler.github.com/Marpa/libmarpa.html">
directly</a>
or via
<a href="https://metacpan.org/release/Marpa-R2">
a Perl interface</a>.
<li><p>
For general BNF parsing,
do not require
the user to craft
a lookahead or backtracking strategy -- Marpa
does not use lookahead and never backtracks.
<li><p>
Come
with the traditional theoretical apparatus of
proofs based on prior literature.
</ol>
<p>
<a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>
is a major rewrite of the Marpa internals.
The most visible of these changes:
<ol>
<li><p>Marpa::R2 is faster.
<li><p>Marpa::R2 is easier to install.
In particular the dependency on Glib has been removed.
Marpa::R2 now has no non-core CPAN dependencies.
<li><p>Marpa::R2's internal symbols are now invisible
to the user, even when tracing and debugging.
<li><p>
<a href="http://jeffreykegler.github.com/Marpa/libmarpa">
Libmarpa, the C library which is at the core of Marpa</a>,
is now documented
and separately installable.
(Libmarpa remains alpha at this point.)
<li><p>Another new documented interface,
<a href="https://metacpan.org/module/Marpa::R2::Advanced::Thin">
Marpa::R2::Thin</a>,
is a "thin" interface to Libmarpa from Perl.
(Marpa::R2::Thin remains alpha at this point.)
</ol>
<br />
<p>posted at: 17:16 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/r2_is_beta.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 26 Aug 2012</h3>
<br />
<center><a name="dsl"> <h2>Domain-Specific Languages made simpler</h2> </a>
</center>
<h2>Writing your own language</h2>
<p>Creating your own language has been A Big Deal (tm).
What if you could create a simple language in hours or minutes?
There's been a serious obstacle up to now.
No practical parser "just parsed" BNF.
With
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>,
that restriction is lifted.
<p>
In this post, I will describe
a small, sample
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>
domain-specific language (DSL).
In designing it I am inspired by
<a href="http://blog.plover.com/oops/blosxom-sux.html">
Mark Dominus's description</a>
of the
<a href="http://en.wikipedia.org/wiki/Worse_is_better">
"Worse is Better" philosophy</a>,
and its implementation in the form of
<a href="http://en.wikipedia.org/wiki/Blosxom">
Blosxom</a>.
This DSL is feature-poor,
but short, simple and extensible.
<h2>A calculator</h2>
<p>
This DSL is a calculator.
Calculators are familiar and,
after all, whatever tool you build this
DSL into, it will probably be useful
to have a calculator as part of it.
What follows contains only the parts of the code
relevant to the discussion,
not necessarily in lexical order.
If you find the following interesting,
you'll almost certainly want the full code,
which is available as
<a href="https://gist.github.com/3521836">
a Github gist</a>.
<p>
<h2>The grammar</h2>
<p>
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>
allows you to build your DSL as a clean modular
structure,
with a separate grammar, tokenizer and semantics.
If you're used to doing parsing with regexes or recursive descent,
you expect to see things mixed together,
and much as you might like modularity in other contexts,
this cleaner approach may make you uneasy.
And not without reason.
Traditionally, parsing tools that
took a modular approach
were painful to use and,
for practical grammars,
often rewarded the extra effort
they required by failing to work.
<p>Here's the grammar for our calculator.

<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my $rules = Marpa::Demo::OP2::parse_rules(
    <<'END_OF_GRAMMAR'
reduce_op ::=
    '+'                   => do_arg0
  | '-'                   => do_arg0
  | '/'                   => do_arg0
  | '*'                   => do_arg0
script ::= e              => do_arg0
script ::= script ';' e   => do_arg2
e ::=
     NUM                  => do_arg0
   | VAR                  => do_is_var
   | :group '(' e ')'     => do_arg1
  || '-' e                => do_negate
  || :right e '^' e       => do_binop
  || e '*' e              => do_binop
   | e '/' e              => do_binop
  || e '+' e              => do_binop
   | e '-' e              => do_binop
  || e ',' e              => do_array
  || reduce_op 'reduce' e => do_reduce
  || VAR '=' e            => do_set_var
END_OF_GRAMMAR
);
</div>

<p>This is a simple language, but it's already an advance over,
<a href="http://blog.plover.com/prog/bash-expr.html">
say, shell arithmetic</a>.
And the <tt>reduce</tt> operator is even a bit
of fanciness.
It's a second-order binary operator,
whose left operand is another operator.
<p>The grammar is written in another DSL, <tt>Marpa::Demo::OP2</tt>,
which is bundled into the same file.
(OP2's grammar is defined directly in
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>.)
Together, these two quite useable DSL's require 600 lines,
self-testing included.
<p>
I'm using OP2 in this post, as it presents the <strong>idea</strong>
of a grammar more clearly.
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>'s
lower level syntax, while more stable, flexible and efficient,
is more cluttered.
OP2 itself is interesting as an extension and generalization of
precedence parsing,
as I described in
<a href="http://blogs.perl.org/users/jeffrey_kegler/2012/08/precedence-parsing-made-simpler.html">
a previous post</a>.
Here's its syntax:
<dl>
<dt><strong><tt>::=</tt></strong><dd>A BNF rule in LHS <tt>::=</tt> RHS form
<dt><strong><tt>'abc'</tt></strong><dd>A literal token.
<dt><strong><tt>|</tt></strong><dd>Separates alternative RHS's at the <strong>same</strong> precedence level
<dt><strong><tt>||</tt></strong><dd>Separates alternative RHS's at the <strong>different</strong> precedence levels.
  The tighter ("higher") precedence alternative is first, the
  looser ("lower") precedence alternative is second.
<dt><strong><tt>=&gt;</tt></strong><dd><tt>rule =&gt; semantics</tt>, where <tt>semantics</tt>
is a Perl closure.
<dt><strong><tt>:left</tt></strong><dd>The alternative is left-associative (the default)
<dt><strong><tt>:right</tt></strong><dd>The alternative is right-associative
<dt><strong><tt>:group</tt></strong><dd>The alternative is grouping-associative -- that is, its
operator(s), regardless of their own precedence,
group expressions of the loosest precedence
</dl>

<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my $grammar = Marpa::R2::Grammar->new(
    {   start          => 'script',
        actions        => __PACKAGE__,
        rules          => $rules,
    }
);
$grammar->precompute;
</div>

<p>The code just above creates a new grammar from the OP2-generated rules.
The only other information needed to fully define
the grammar is the name of the start symbol
("<tt>script</tt>") and the name of the package where
the semantics can be found
(the current one, <tt>__PACKAGE__</tt>).
<p>
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>
does a lot of precomputation to its grammars.
Once a grammar is fully defined,
and before a recognizer can be created from it,
the <tt>precompute()</tt> method must be called.
<h2>The semantics</h2>
<p>
Those curious about the semantics of this calculator
can look at
<a href="https://gist.github.com/3521836">
the Github gist</a>.
They are somewhat interesting.
But this post is about how to get <strong>your</strong> interesting
semantics out easily and quickly,
in the form of a powerful
language specifically designed for them.
<h2>The lexer</h2>
<h3>The token table</h3>
<p>The calculator's lexer is table-driven.
The table is quite simple -- it's an array
of two element arrays.
In the inner arrays, the first element is the symbol name,
as specified in the grammar,
and the second is a regex which matches it.

<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my @terminals = (
    [ q{'reduce'}, qr/reduce\b/xms ],
    [ 'NUM',       qr/\d+/xms ],
    [ 'VAR',       qr/\w+/xms ],
    [ q{'='},      qr/[=]/xms ],
    [ q{';'},      qr/[;]/xms ],
    [ q{'*'},      qr/[*]/xms ],
    [ q{'/'},      qr/[\/]/xms ],
    [ q{'+'},      qr/[+]/xms ],
    [ q{'-'},      qr/[-]/xms ],
    [ q{'^'},      qr/[\^]/xms ],
    [ q{'('},      qr/[(]/xms ],
    [ q{')'},      qr/[)]/xms ],
    [ q{','},      qr/[,]/xms ],
);
</div>

<p>
Order in the above table matters when you have
terminals, one of which can prefix another.
An example would be the operators
<tt>==</tt> and <tt>=</tt>.
There is no such pair here,
however,
so that
in this application,
the order makes no difference.
<p>
As you can see,
I am one of those who specify <tt>xms</tt> for every
regex.
The symbol names preserve the surrounding single quotes.
This is convenient for processing,
and it also makes diagnostic messages involving
those symbols more comprehensible.
Finally, note that the <tt>reduce</tt> operator is required to end on a word boundary.
<h3>The tokenizing engine</h3>

<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
    my $rec = Marpa::R2::Recognizer->new( { grammar => $grammar } );

    my $length = length $string;
    pos $string = 0;
    TOKEN: while ( pos $string < $length ) {

        # skip whitespace
        next TOKEN if $string =~ m/\G\s+/gcxms;

        # read other tokens
        TOKEN_TYPE: for my $t (@terminals) {
            next TOKEN_TYPE if not $string =~ m/\G($t->[1])/gcxms;
            if ( not defined $rec->read( $t->[0], $1 ) ) {
                die_on_read_problem( $rec, $t, $1, $string, pos $string );
            }
            next TOKEN;
        } ## end TOKEN_TYPE: for my $t (@terminals)

        die q{No token at "}, ( substr $string, pos $string, 40 ),
            q{", position }, pos $string;
    } ## end TOKEN: while ( pos $string < $length )
</div>
<p>The calculator's token engine creates a
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>
recognizer
with the <tt>new()</tt> constructor,
and feeds it tokens with the <tt>read()</tt> method.
In this token engine,
I use Perl's progressive matching capabilities:
the
<tt>g</tt> and
<tt>c</tt> modifiers, the
<tt>\G</tt> assertion and the
<tt>pos</tt> function.
When writing a token engine,
there is, as the expression goes, more than one way
to do it,
many of them somewhat easier than this approach.
But progressive matching is powerful, efficient,
very flexible,
and it has the advantage that
it leaves the original string intact.
<p>
Those who go on to look at the
<a href="https://gist.github.com/3521836">
code in the gist</a>
may find
<tt>die_on_read_problem()</tt>,
the DSL's function for handling <tt>read()</tt> errors,
helpful.
It produces a very specific and comprehensive error message.
One of
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>'s
greatest improvements over previous
parsers is that, when a parse fails,
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>
can explain why in considerable detail.
It makes sense to take full advantage of that ability.

<h2>Evaluating the parse</h2>
<p>
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">

    my $value_ref = $rec->value;

    if ( !defined $value_ref ) {
        say $rec->show_progress() or die "say failed: $ERRNO";
        die 'Parse failed';
    }
    return ${$value_ref};

</div>
<p>Evaluation of the parse is done with the <tt>value()</tt> method.
This can return all the parse results of an ambiguous parse.
We want only one parse here,
so we call <tt>value()</tt> only once.
<tt>value()</tt> returns a reference to the value of the parse,
and a Perl <tt>undef</tt> if the parse failed.
The error handling is worth noticing.
One of
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>'s
strengths is that it is fully aware of which rules
are being tried at any point,
and of how far into those rules recognition has progressed.
The <tt>show_progress()</tt> method reports that information.

<h2>OP2</h2>
<p>
This ends our description of the calculator code.
In
<a href="https://gist.github.com/3521836">
the Github gist</a>
a second DSL immediately follows the
calculator DSL.
This second DSL is OP2,
which is used to define the grammar for the calculator.
OP2 is more complicated than the calculator,
but its design is similar,
and it can be used as a second DSL example.
<h2>Alernatives</h2>
<h3>Marpa::R2 verus Marpa::XS</h3>
<p>This calculator uses
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>.
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>
is beta,
while
<a href="https://metacpan.org/module/Marpa::XS">
Marpa::XS</a>
is in a stable, bug-fix only release.
On the other hand
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>
is somewhat faster,
and its reporting of parse-time problems is better.
<h3>Specifying the grammar</h3>
The grammar of the calculator is specified in OP2,
which is a clear and elegant way to do it.
But OP2 is an experimental DSL created just for this
one use.
<p>
A more robust way to 
specify grammars is to do it directly in
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>.
OP2's grammar is specified directly in
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>.
A compromise between elegance and stability would be
to use OP2 (or a derivative)
to generate the rules (or some of them).
The OP2-generated rules can be used
as is, or edited to taste.
When you are happy with them,
Data::Dumper can turn the OP2-generated rules
into code,
which you can
then incorporate into your DSL program.
<h3>Error messages</h3>
It is hard to compare
the quality of the
messages from these DSL's,
unfamiliar programs which explore new ground,
against, for example,
the comprehensibility of a C compiler's
error messages.
With the C compiler, I have the advantage of
over 40 years of Pavlovian training in guessing what
they really mean.
<p>
I believe that this DSL's error messages
are already, on average, up to the level
of typical production languages.
My main reason for this bold assertion is that
production parsers have set the bar,
frankly, extremely low.
I hasten to add,
this is often not because of lack of care or effort
by the implementers.
The traditional parsing technologies simply
do not provide enough information to support
accurate and helpful error reporting.
<p>
Much more could be done in error message handling
than is done by this calculator DSL.
<a href="http://jeffreykegler.github.com/Marpa/">
Marpa</a>'s
situational awareness
makes much easier to write usefully
accurate error messages than has been the case.
And I find better error messages often repay a high priority,
even in programs that are strictly for personal use.
<br />
<p>posted at: 09:20 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
