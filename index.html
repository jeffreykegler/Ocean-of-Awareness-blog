<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Sat, 15 Nov 2014</h3>
<br />
<center><a name="ll"> <h2>Parsing: Top-down versus bottom-up</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>Why did the invention of bottom-up parsing bring
    with it such hope?
    Indeed, despite bottom-up parsing's
     near-total abandonment by practitioners,
     among theoreticians bottom-up still has not lost its hold.
     Even today,
    in parsing texts and courses,
    bottom-up parsing frequently gets as much or more
    attention than
    the more widely used top-down parsing.
    Why?
    <p>Many treatments of these two approaches
    are either too high-level or two low-level.
    Overly high-level treatments reduce the two approaches to buzzwords,
    and the comparision to a recitation of received wisdom.
    Overly low-level treatments get immersed in the minutiae of implementation,
    so that the comparison ends up no more helpful than placing
    two unrelated code listings placed side by side.
    In this post I hope to clarify why the two advocates of each
    parsing approach took that positions
    they did,
    and to suggest a way forward.
    </p>
    <h3>Top-down parsing</h3>
    <p>The basic idea of top-down parsing is
      as brutally simple as anything in programming:
      you look at the next token and decide then and there
      where it fits into the parse tree.
      Starting at the top, you add pieces and once
      you've looked at every token,
      you have your parse tree.
      <p>
      Since this idea, in its purest form,
      is too simple to get anything done,
      top-down parsing is almost
      always combined with with lookahead.
      Lookahead of one token helps a lot.
      But longer lookaheads
      are very sparsely used.
      They just aren't that helpful,
      and since
      the number of possible lookaheads grows exponentially,
      they get very expensive very fast.
    </p><p>Top-down parsing has an issue with left recursion.
      It's straightforward to see why.
      If we have an open-ended expression like
    </p><blockquote><pre>
    a + b + c + d + e + f + [....]</pre></blockquote>
    <p>
      where the plus signs continue off to the right,
      we cannot make the final parsing decision at the first plus sign unless
      we know how many more plus signs are to come.
      And there is no way of counting plus signs
      without looking to the right.
      For anything but the simplest expressions,
      this rightward-looking has to be
      rather sophisticated
      There are a lot of approaches to dealing with this difficulty,
      but all of them involve trying to make top-down parsing into
      something it is not.
    </p><h3>Advantages of top-down parsing</h3>
    <p>In the 1970's it was hard to believe that an approach
      that as as good as we can do.
      But before looking at alternatives,
      I want to emphasize that its extreme simplicity
      is also top-down parsing's great strength.
      Because a top-down parsing is extremely simple,
      it is very easy to figure out what it is doing.
      And easy to figure out means easy to customize.
    </p><p>
      Take another of the many constructs incomprehensible to
      a top-down parser:
    </p><blockquote><pre>
    2 * 3 * 4 + 5 * 6
    </pre></blockquote><p>
      How do top-down parsers typically handle this?
      Simple: as soon as they realize they are faced
      with an expression, they give up on top-down
      parsing and switch to a special-purpose algorithm.
    </p><p>These two properties -- easy to understand
      and easy to customize --
      have catapulted top-down parsing
      to the top of the heap.
      Behind their different presentations,
      combinator parsing, PEG, and recursive descent are
      all top-down parsers.
    </p><h3>Bottom-up parsing</h3>
    <p>Few theoreticians of the 1970's imagined that top-down parsing would
      be the end of the story.
      They thought there had to be some systematic way to
      to exploit the right context.
      For example,
      when reading sentences like these, you'd think
      a human must be using the right context.
    </p><p>Don Knuth in 19xx found a way to use
      right context.
      Knuth's LR algorithm was,
      like top-down parsing as I have described it,
      deterministic.
      Determinism was thought to be essential because determinism
      allowing more than one choice easily leads to an explosion in the
      number possibilities being considered at once.
      Preventing an explosion in the number of possibilities
      guaranteed that the parse can be done in linear time.
    </p><p>Simplistically, Knuth's suggestion was to,
      instead of fully deciding the
      parse at every location, to make what I will call "subdecisions" --
      decisions as to how the
      piece at that location is used, but which allow the subdecision
      to be put into a larger context,
      to be decided later.
      Don proposed a stack of subdecisions -- if we have a subdecision
      but we cannot decide its full context, we push it onto a stack ("shift").
      When you encounter the context, you pop it off the stack
      and make the full decision ("reduce").
    </p><p>Like top-down parsing, bottom-up parsing is usually combined with lookahead.
      For the same lookahead, a bottom-up parser parses not everything that a
      top-down parser can handle,
      and more.
    </p><p>
      To preserve determinism,
      you have to know whether to shift or reduce,
      and if reducing, what reduction to make,
      at every location.
      But the problem with left recursion disappeared.
      In the example from above
    </p><blockquote><pre>
    a + b + c + d + e + f + [....]</pre></blockquote>
    <p>
      you reduce until you run out of plus signs.
      Each reduced addition becomes the left hand side of the next addition,
      and this continues until you run out of plus signs.
    </p><p>For a bottom-up parser, right recursion is harder, but not much
      harder.
    </p><blockquote><pre>
    a = b = c = d = e = f = [....]</pre></blockquote>
  <p>
      At every equal sign you "shift" the subdecision onto the stack.
      When you hit the end, you pop the subdecisions off the stack
      one by one and "reduce" them.
      Essentially, you do the same thing you did for left recursion,
      only in reverse.
      <p>
      Arithmetic expressions like
    </p><blockquote><pre>
    2 * 3 * 4 + 5 * 6</pre></blockquote>
    <p>
      are solved by combining the approaches.
      For this one
      you "reduce" all the multiplications,
      at which point you "shift" the result onto the stack.
      Then you "reduce" the next set of multiplications.
      At the end you pop the addition off the stack and "reduce" it.
    </p><p>
      To preserve determinism,
      we have to know,
      at every location,
      whether to shift or reduce,
      and when reducing, what reduction to make.
      Above, we assumed that we had a way to figure this out.
      In fact,
      finding what seemed a practical way to make these shift/reduce and
      reduce/reduce decisions took some doing.
      By the 197-, it was thought a practical way had been found,
      and around 19-- a parser generator based on it was released as yacc.
      (Readers today may be more familiar with yacc's successor, bison.)
    </p><p>
      With yacc, theoreticians thought they'd found the Holy Grail.
      When the textbooks focused on bottom-up parsing came out,
      they were not always able to restrain the urge
      to portray parser writers as knights in armor.
    </p><p>But not every medieval romance has a happy ending.
      As I've
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html">described
      elsewhere</a>,
      this story ended badly.
      Bottom-up parsing was driven by tables which made the algorithm fast
      for correct inputs, but unable to accurately diagnose faulty ones.
      The subset of grammars parsed was still not quite large enough,
      even for conservative language designers.
      And bottom-up parsing was very unfriendly to custom hacks,
      which made its shortcomings loom large.
      It is much harder to work around a problem in a bottom-up
      parser than than it was to deal with a similar problem
      in a top-down parser.
      After years of experience,
      top-down parsing has re-emerged as the
      algorithm of choice.
    </p><h3>Table parsing</h3>
    <p>For many, the return to top-down parsing
      answers the question that we posed earlier:
      "Is there any systematic way to exploit right context when parsing?"
      This answer turns out to be a rather startling "No".
      But is this really the end of the story?
    </p><p>Assumed in all of this was that,
      for an algorithm to be linear,
      in practice it would also have to be deterministic.
      But is this actually the case?
    </p><p>It's not, in fact.
      To keep bottom-up parsing deterministic, we restricted ourselves to a stack.
      But what if we keep all possible subdecisions linked and in tables,
      and make the final decisions in another pass,
      once the tables are complete.
      (The second pass replaces the stack based
      see-sawing back and forth of the deterministic algorithm,
      so it's not an inefficiency.)
      Jay Earley in 19-- came up with an algorithm to do this,
      and in 1991 Joop Leo added a memoization to Earley's
      algorithm which makes it linear for all deterministic grammars.
    </p><p>The "deterministic grammars"
      are exactly the bottom-up parseable grammars
      with lookahead.
      So that means the Earley/Leo algorithm parses,
      in linear time,
      everything that a deterministic bottom-up parser can parse,
      and therefore every grammar that
      a deterministic top-down parser can parse.
      (In fact, the Earley/Leo algorithm is linear for a lot of
      ambiguous grammars as well.)
    </p><p>Top-down parsing had the advantage that it was easy to know where
      you are.  But the Earley/Leo algorithm has an equivalent advantage -- its
      tables know where it is, and it is easy to query them programmatically.
      In 2010, this blogger added to the Earley/Leo algorithm
      the other big advantage of top-down parsing:
      The Marpa algorithm rearranges the Earley/Leo parse engine so that you can
      stop it, perform your own logic, and restart where you left off.
      <a href=http://savage.net.au/Marpa.html">A quite useable parser based on the Marpa algorithm</a>
      is available as open source.
    </p><h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 17:53 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/ll.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Tue, 04 Nov 2014</h3>
<br />
<center><a name="successful"> <h2>What makes a parsing algorithm successful?</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>What makes a parsing algorithm successful?
      Two factors, I think.
      First, does the algorithm parse a workably-defined set of grammars in linear time?
      Second, does it allow the application to intervene in the parse
      with custom code?
      When parsing algorithms are compared,
      typically neither of these gets much attention.
      But the successful algorithms do one or the other.
    </p>
    <h3>Does the algorithm parse a workably-defined set of grammars in linear time?</h3>
    <p>"Workably-defined" means more than well-defined
      in the mathematical sense --
      the definition has to be <b>workable</b>.
      That is, the
      definition must be something that,
      with reasonable effort,
      a programmer can use in practice.
    </p><p>
      The algorithms in regular expression engines are workably-defined.
      A regular expression, in the pure sense consists of a sequence of symbols,
      usually shown by concatenation:
    </p><blockquote><pre>a b c</pre></blockquote><p>
      or a choice among sequences, usually shown by a vertical bar:
    </p><blockquote><pre>a | b | c</pre></blockquote><p>
      or a repetition of any of the above, typically shown with a star:
    </p><blockquote><pre>a*</pre></blockquote><p>
      or any recursive combination of these.
      True, if this definition is new to you, it can take time to get
      used to.
      But vast numbers of working programming are very much "used to it",
      can think in terms of regular expressions,
      and can determine if a particular problem will yield to treatment
      as a regular expression, or not.
      <p>
      Parsers in the LALR family (yacc, bison, etc.)
      do <b>not</b>
      have a workably defined set of grammars.
      LALR is perfectly well-defined mathematically,
      but even experts in parsing theory are hard put to decide
      if a particular grammar is LALR.
    </p><p>
      Recursive descent also does not have a workably defined
      set of grammars.
      Recursive descent doesn't even have a precise mathematical description --
      you can say that recursive descent is LL,
      but in practice LL tables are rarely used.
      Also in practice, the LL logic is extended with every other trick
      imaginable, up to and including switching to other parsing algorithms.
    </p>
    <h3>Does it allow the user to intervene in the parse?</h3>
    <p>It is not easy for users to intervene in the processing
      of a regular expression, though some implementations attempt to
      allow such efforts.
      LALR parsers are notoriously opaque.
      Those who maintain the LALR-driven Perl parser have tried
      to supplement its abilities with
      custom code, with results that will not encourage
      others making the same attempt.
    </p><p>Recursive descent, on the other hand, has no parse engine --
      it is 100% custom code.
      You don't get much friendlier than that.
    </p><h3>Conclusions</h3><p>
      Regular expressions are a success,
      and will remain so,
      because the set of grammars
      they handle is very workably-defined.
      Applications using regular expressions have to take what the algorithm
      gives them, but what it gives them is very predictable.
      <p>
      For example, an application can write regular expressions on the fly, and
      the programmer can be confident they will run as long as they are well-formed.
      And it is easy to determine if the regular expression is well-formed.
      (Whether it actually does what you want is a separate issue.)
      <p>
      Recursive descent does not handle a workably-defined set of grammars,
      and it also has to be hand-written.
      But it makes up for this by allowing the user to step into the parsing process
      anywhere, and "get his hands dirty".
      Recursive descent does nothing for you, but it does allow you complete control.
      This is enough to make recursive descent the current algorithm of choice
      for major parsing projects.
      <p>
      As I have
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html">chronicled
      elsewhere</a>,
      LALR was once,
      on highly convincing theoretical grounds,
      seen as
      <b>the</b> solution to the parsing problem.
      But while mathematically well-defined,
      LALR was not workably defined.
      And it was very hostile to applications that tried to alter,
      or even examine, its syntax-driven workings.
      After decades of trying to make it work,
      the profession has abandoned LALR almost totally.
    </p>
    <h3>What about Marpa?</h3>
    <p>Marpa has both properties:
      its set of grammars is workably-defined.
      And, while Marpa is syntax-driven like LALR and regular expressions,
      it also allows the user to stop the parse engine,
      communicate with it about the state of the parse,
      do her own parsing for a while,
      and restart the parse engine at any point she wants.
    </p>
    <p>Marpa's workable definition has a nuance that the one
    for regular expressions does not.
    For regular expressions, linearity is a given --
    they parse in linear time or fail.
      Marpa parses a much larger class of grammars, the context-free grammars --
      anything that can be written in BNF.
      BNF is used to describe languages in standards,
      and is therefore itself a kind of "gold standard"
      for a workable definition of a
      set of grammars.
      However, Marpa does <b>not</b>
      parse everything that can be written in BNF in linear time.
    </p>
    <p>Marpa linearly-parsed set of grammars is smaller than the context-free
    grammars, but it is still very large, and it is still workably-defined.
      Marpa will parse any unambiguous language in linear time,
      unless it contains unmarked middle recursions.
      An example of a "marked" middle recursion is the language described
      by
    </p><blockquote><pre>S ::= a S a | x</pre></blockquote><p>
    a string of which is "<tt>aaaxaaa</tt>",
      where the "<tt>x</tt>" marks the middle.
      An example of an "unmarked" middle recursion is the language described
      by
    </p><blockquote><pre>S ::= a S a | a</pre></blockquote><p>
    a string of which is "<tt>aaaaaaa</tt>",
      where nothing marks the middle, so that you don't know until the end where the
      middle of the recursion is.
      If a human can reliably find the middle by eyeball, the middle recursion is marked.
      If a human can't, then the middle recursion might be unmarked.
    </p>
    <p>Marpa also parses a large set of unambiguous grammars linearly,
      and this set of grammars is also workably-defined.
      Marpa parses an ambiguous grammar in linear time if
    </p><ul>
      <li>It has no unmarked middle recursions.
      </li>
      <li>All right recursions are unambiguous.
      </li>
      <li>There are no cycles.
      A cycle occurs, for example, if there is a rule <tt>A ::= A</tt>
      in the grammar.
      </li>
      <li>Marpa's level of ambiguity at any location is bounded by a constant.
      </li>
      </ul>
      <p>The term "level of ambiguity" requires a bit of explanation.
	At any given location,
        there can be as many rules "in play" as you like,
	without affecting the level of ambiguity.
        The key question: What is the maximum number of different origins
	that a rule might have?
	(The "origin" of a rule is the location where it begins.)
        That is, can a rule currently in play
	have at most 20 different origins?
        Or could it have its origin at every location so far?
        If the maximum number of origins is 20 or any other fixed constant, the level of
        ambiguity is "bounded".
	But if the maximum number of origins keeps growing as the length of the input
	grows, the level of ambiguity is unbounded.
    <p>For the unambiguous case, Marpa's workable definition encompasses
    a much larger class of grammars, but is no more
      complex than that for regular expressions.
      If you want to extend even further,
      and work with ambiguous grammars,
      the definition remains quite workable.
      Of the four restrictions needed to ensure linearity,
      the one requiring a bounded level of ambiguity is the only one
      that might force you to exercise real vigliance --
      once you get into ambiguity, unboundedness is easy to slip into.
      <p>
      As for the other three,
      cycles never occur in a practical grammars,
      and Marpa reports them,
      so that you simply fix them when they happen.
      Most recursions will be left recursions,
      which are unrestricted.
      My experience has been that, in practical grammars,
      unmarked middle recursions
      and ambiguous right recursions are not especially
      tempting features.
      If you note
      whenever you use a right recursion,
      checking that it is not ambiguous,
      and if you note whenever you use a middle recursion,
      checking that it is marked,
      then you will stay linear.
    </p>
      To learn more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p><h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
    </p>
  </body>
</html>
<br />
<p>posted at: 21:10 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/successful.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<br />
<center><a name="backpan"> <h2>Removing obsolete versions of Marpa from CPAN</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>Marpa::XS, Marpa::PP, and Marpa::HTML are obsolete versions of
      Marpa, which I have been keeping on CPAN for the convenience of legacy
      users.
      All new users should look only at
      <a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>.
    </p><p>
      I plan to delete the obsolete releases from CPAN soon.
      For legacy users who need copies, they will still be available on backPAN.
    </p><p>
      I do this because their placement on CPAN placement makes them "attractive nuisances" --
      they show up in searches and generally make it harder to find
      <a href="https://metacpan.org/release/Marpa-R2">Marpa::R2</a>,
      which is the version that new users should be interested in.
      There is also some danger a new user could, by mistake, use the
      obsolete versions instead of Marpa::R2.
    </p><p>
      It's been some time since someone has reported a bug in their code,
      so they should be stable for legacy applications.
      I would usually promise to fix serious bugs that affect legacy users,
      but unfortunately, especially in the case of Marpa::XS,
      it is a promise I would have trouble keeping.
      Marpa::XS depends on Glib, and uses a complex build which I last performed
      on a machine I no longer use for development.
    </p><p>
      For this reason, a re-release to CPAN with deprecatory language is also not an option.
      I probably would not want to do so anyway -- the CPAN infrastructure by default
      pushes legacy
      users into upgrading, which always carries some risk.
      New deprecatory language would add no
      value for the legacy users,
      and they are the only audience these releases exist to serve.
    </p>
    <h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 10:53 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/backpan.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sat, 01 Nov 2014</h3>
<br />
<center><a name="delimiter"> <h2>Reporting mismatched delimiters</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>In many contexts, programs need to identify
      non-overlapping pieces of a text.
      One very direct way to do this
      is to use a pair of delimiters.
      One delimiter of the pair marks the start
      and the other marks the end.
      Delimiters can take many forms:
      Quote marks, parentheses, curly braces, square brackets,
      XML tags, and HTML tags
      are all delimiters in this sense.
    </p>
    <p>
      Mismatching delimiters is easy to do.
      Traditional parsers are often poor at reporting these errors:
      hopeless after the first mismatch,
      and for that matter none too precise about the first one.
      This post outlines a scaleable method for the accurate
      reporting of mismatched delimiters.
      I will illustrate the method with a simple
      but useable tool --
      a utility which reports mismatched brackets.
    </p>
    <h3>The example script</h3>
    <p>The
      <a href="https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519">example
      script</a>,
      <tt>bracket.pl</tt>,
      reports mismatched brackets in the set:
    </p>
    <blockquote><pre>() {} []</pre></blockquote>
      <p>
      They are expected to nest without overlaps.
      Other text is treated as filler.
      <tt>bracket.pl</tt>
      is not smart about things
      like strings or comments.
      This does have the advantage of making
      <tt>bracket.pl</tt>
      mostly language-agnostic.
    </p>
    <p>
      Because it's intended primarily to be read
      as an illustration of the technique,
      <tt>bracket.pl</tt>'s grammar
      is a basic one.
      The grammar that
      <tt>bracket.pl</tt>
      uses is so simple that
      an emulator of <tt>bracket.pl</tt>
      could be written using recursive descent.
      I hope the reader who goes on to look into the details
      will see that this technique scales to more
      complex situations,
      in a way that a solution based on a traditional parser
      will not.
    </p>
    <h3>Error reports</h3>
    <p>The description of how the method works will make more
      sense after we've looked at some examples of the diagnostics
      <tt>bracket.pl</tt>
      produces.
      To be truly useful,
      <tt>bracket.pl</tt>
      must report mismatches that span
      many lines,
      and it can do this.
      But single-line examples are easier to follow.
      All the examples in this post will be contained in a one line.
      Consider the string '<tt>((([))</tt>'.
      <tt>bracket.pl</tt>'s diagnostics are:
    </p><blockquote><pre>
* Line 1, column 1: Opening '(' never closed, problem detected at end of string
((([))
^
====================
* Line 1, column 4: Missing close ], problem detected at line 1, column 5
((([))
   ^^
</pre></blockquote>
    <p>
      In the next example
      <tt>bracket.pl</tt>
      realizes that it
      cannot accept the ')' at column 16, without first closing the set of curly braces started at column 5.
      It identifies the problem, along with both of the locations involved.
    </p>
    <blockquote><pre>
* Line 1, column 5: Missing close }, problem detected at line 1, column 16
[({({x[]x{}x()x)})]
    ^          ^
</pre></blockquote>
    <p>
      So far, so good.
      But an important advantage of
      <tt>bracket.pl</tt>
      has yet to be seen.
      Most compilers,
      once they report a first mismatched delimiter,
      produce error messages that are
      unreliable --
      so unreliable that they are useless in practice.
      <tt>bracket.pl</tt>
      repairs a mismatched bracket before continuing,
      so that it can do a reasonable job of analyzing the text
      that follows.
      Consider the text
      '<tt>({]-[(}-[{)</tt>'.
      The output of
      <tt>bracket.pl</tt>
      is
    </p><blockquote><pre>
* Line 1, column 1: Missing close ), problem detected at line 1, column 3
({]-[(}-[{)
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
({]-[(}-[{)
 ^^
====================
* Line 1, column 3: Missing open [
({]-[(}-[{)
  ^
====================
* Line 1, column 5: Missing close ], problem detected at line 1, column 7
({]-[(}-[{)
    ^ ^
====================
* Line 1, column 6: Missing close ), problem detected at line 1, column 7
({]-[(}-[{)
     ^^
====================
* Line 1, column 7: Missing open {
({]-[(}-[{)
      ^
====================
* Line 1, column 9: Missing close ], problem detected at line 1, column 11
({]-[(}-[{)
        ^ ^
====================
* Line 1, column 10: Missing close }, problem detected at line 1, column 11
({]-[(}-[{)
         ^^
====================
* Line 1, column 11: Missing open (
({]-[(}-[{)
          ^
</pre></blockquote>
    <p>Each time,
      <tt>bracket.pl</tt>
      corrects itself,
      and accurately reports the next set of problems.
    </p><h3>A difficult error report</h3>
    <p>
      To be 100% accurate,
      <tt>bracket.pl</tt>
      would have to guess the programmer's intent.
      This is, of course, not possible.
      Let's look at a text where
      <tt>bracket.pl</tt>'s guesses are not so good:
      <tt>{{]}</tt>.
      Here we will assume the closing square bracket is a typo for a closing parenthesis.
      Here's the result:
    </p><blockquote><pre>
* Line 1, column 1: Missing close }, problem detected at line 1, column 3
{{]}
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
{{]}
 ^^
====================
* Line 1, column 3: Missing open [
{{]}
  ^
====================
* Line 1, column 4: Missing open {
{{]}
   ^
</pre></blockquote><p>
      Instead of one error,
      <tt>bracket.pl</tt>
      finds four.
    </p><p>
      But even in this case, the method is fairly good, especially when
      compared with current practice.
      The problem is at line 1, column 3,
      and the first three messages all identify this as one of their
      potential problem locations.
      It is reasonable to believe that a programmer, especially once
      he becomes used to this kind of mismatch reporting,
      will quickly find the first mismatch and fix it.
      For this difficult case,
      <tt>bracket.pl</tt> may not be much better than the state of the art,
      but it is certainly no worse.
    </p>
    <h3>How it works</h3>
    <p>
      For full details of the workings of
      <tt>bracket.pl</tt>
      there is
      <a href="https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519">the code</a>,
      which is heavily commented.
      This section provides a conceptual overview.
    </p><p>
      <tt>bracket.pl</tt>
      uses two features of Marpa:
      left-eideticism and the Ruby Slippers.
      By left-eidetic, I mean that Marpa knows everything there is to know
      about the parse at, and to left of, the current position.
      As a consequence,
      Marpa
      also knows exactly which of its input symbols
      can lead to a successful parse,
      and is able to stop as soon as it knows that the parse cannot succeed.
    </p>
    <p>
      In the Ruby Slippers technique, we arrange for parsing to stop
      whenever we encounter an input which
      would cause parsing to fail.
      The application then
      asks Marpa, "OK.  What input would allow the
      parse to continue?"
      The application takes Marpa's answer to this
      question, and uses it to concoct
      an input that Marpa will accept.
    </p>
    <p>
      In this case,
      <tt>bracket.pl</tt>
      creates a virtual token which fixes the mismatch
      of brackets.
      Whatever the missing bracket may be,
      <tt>bracket.pl</tt>
      invents a bracket of that kind,
      and adds it to the virtual input.
      This done,
      parsing and error detection
      can proceed as if there was no problem.
      Of course,
      the error which made the Ruby Slippers token necessary
      is recorded, and those records are the source of the
      error reports we saw above.
    </p>
    <p>
      To make its error messages as informative as possible
      in the case of missing closing brackets,
      <tt>bracket.pl</tt>
      needs to report the exact location of
      the opening bracket.
      Left-eideticism again comes in handy here.
      Once the virtual closing bracket is supplied to Marpa,
      <tt>bracket.pl</tt>
      asks, "That bracketed text that I just closed -- where did it begin?"
      The Marpa parser tracks the start location
      of all symbol and rule instances,
      so it is able to provide the application
      with the exact location of
      the starting bracket.
    </p><p>
      When
      <tt>bracket.pl</tt>
      encounters a problem at a point where there are unclosed opening
      brackets, it has two choices.
      It can be optimistic or it can be pessimistic.
      "Optimistic" means it can hope that something later in the input will close
      the opening bracket.
      "Pessimistic" means it can decide that "all bets are off" and use
      Ruby Slippers tokens to close all the currently active open brackets.
    </p>
    <p>
      <tt>bracket.pl</tt>
      uses the pessimistic strategy.
      While the optimistic strategy sounds better, in practice
      the pessimistic one seems to provide better diagnostics.
      The pessimistic strategy does report some fixable problems
      as errors.
      But the optimistic one can introduce spurious fixes.
      These hide the real errors,
      and it is worse to miss errors
      than it is to overreport them.
      Even when the pessimistic strategy overreports,
      its first error message will always accurately identify
      the first problem location.
    </p>
    <p>
      While
      <tt>bracket.pl</tt>
      is already useable,
      I think of it as a prototype.
      Beyond that,
      the problem of matching delimiters
      is in fact very general, and I believe these techniques may have very wide application.
    </p>
    <h3>For more</h3>
    <p>
      The example script of this post is
      <a href="https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519">a Github gist</a>.
      For more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 11:11 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/delimiter.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 07 Sep 2014</h3>
<br />
<center><a name="chron"> <h2>Parsing: a timeline</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>[ Revised 22 Oct 2014 ]
    </p>
    <p><b>1960</b>:
      The ALGOL 60 spec comes out.
      It specifies, for the first time, a block structured
      language.
      The ALGOL committee is well aware
      that
      nobody knows how to parse such a language.
      But they believe that,
      if they specify a block-structured
      language, a parser for it will be invented.
      Risky as this approach is, it pays off ...
    </p>
    <p><b>1961</b>: Ned Irons publishes his ALGOL parser.
      In fact, the Irons parser
      is the first parser of any kind to be described
      in print.
      Ned's algorithm is a left parser --
      a form of recursive descent.
      Unlike modern
      recursive descent,
      the Irons algorithm
      is general and syntax-driven.
      "General" means it can parse anything written in BNF.
      "Syntax-driven" (aka declarative) means that parser is
      actually created from the BNF --
      the parser does not need
      to be hand-written.
    </p>
    <p><b>1961</b>:
      Almost simultaneously, hand-coded approaches to left parsing
      appear.
      These we would now recognize as recursive descent.
      Over the following years, hand-coding approaches
      will become more popular for left parsers
      than syntax-driven algorithms.
      Three factors are at work:
      <ul>
      <li>
      In 1960's, memory and CPU are both extremely limited.
      Hand-coding pays off, even when the gains are small.
      <li>
      Pure left parsing is a very weak parsing technique.
      Hand-coding is often necessary
      to overcome its limits.
      This is
      as true today as it is in 1961.
      <li>
      Left parsing works well in combination with hand-coding --
      they are a very good fit.
      </ul>
    </p>
    <p><b>1965</b>:
    Don Knuth invents LR parsing.
      Knuth is primarily interested
      in the mathematics.
      Knuth describes a parsing algorithm,
      but it is not thought practical.
    </p>
    <p><b>1968</b>: Jay Earley invents the algorithm named after him.
      Like the Irons algorithm,
      Earley's algorithm is syntax-driven and fully general.
      Unlike the Irons algorithm, it does not backtrack.
      Earley's core idea is to
      track everything about the parse in tables.
      Earley's algorithm is enticing, but it has three major issues:
      <ul>
      <li>First, there is a bug in the handling of zero-length rules.
      <li>Second, it is quadratic for right recursions.
      <li>Third, the bookkeeping required to set up the tables is,
      by the standards of 1968 hardware, daunting.
      </ul>
    <p><b>1969</b>:
      Frank DeRemer describes a new variant of Knuth's LR
      parsing.
      DeRemer's LALR algorithm requires only
      a stack and a state table of quite
      manageable size.
    </p>
    <p><b>1972</b>:
      Aho and Ullmann describe
      a straightforward fix to the zero-length rule bug in Earley's original algorithm.
      Unfortunately, this fix involves adding even more bookkeeping to Earley's.
    <p><b>1975</b>:
      Bell Labs converts its C compiler from hand-written recursive
      descent to DeRemer's LALR algorithm.
    </p>
    <p><b>1977</b>:
      The first "Dragon book" comes out.
      This soon-to-be classic textbook is nicknamed after
      the drawing on the front cover,
      in which a knight takes on a dragon.
      Emblazoned on the knight's lance are the letters "LALR".
      From here on out,
      to speak lightly of LALR will be to besmirch the escutcheon
      of parsing theory.
    </p>
    <p><b>1979</b>: Bell Laboratories releases Version 7 UNIX.
	V7 includes what is, by far,
		the most comprehensive, useable and easily available
		compiler writing toolkit yet developed.
	 Central to the toolkit is
	 yacc, an LALR based parser generator.
	  With a bit of hackery,
	  yacc parses its own input language,
	  as well as the language of V7's main compiler,
	  the portable C compiler.
	  After two decades of research,
	  it seems that the parsing problem is solved.
    </p>
    <p><b>1987</b>:
      Larry Wall introduces Perl 1.
      Perl embraces complexity like no previous language.
      Larry uses LALR very aggressively --
      to my knowledge more aggressively than anyone before
      or since.
    </p>
    <p><b>1991</b>:
      Joop Leo discovers a way of speeding up right
      recursions in Earley's algorithm.
      Leo's algorithm
      is linear for just about every unambiguous grammar of
      practical interest, and many ambiguous ones as well.
      In 1991 hardware is six orders of magnitude faster
      than 1968 hardware, so that the
      issue of bookkeeping overhead had receded
      in importance.
      This is a major discovery.
      When it comes to speed,
      the game has changed in favor of Earley algorithm.
      But Earley parsing is almost forgotten.
      It will be 20 years before anyone writes a practical
      implementation of Leo's algorithm.
    </p>
    <p><b>1990's</b>:
      Earley's is forgotten.
      So everyone in LALR-land is content, right?
      Wrong. Far from it, in fact.
      Users of LALR are making unpleasant discoveries.
      While LALR automatically
      generates their parsers,
      debugging them
      is so hard they could just as easily
      write the parser by hand.
      Once debugged, their LALR parsers are fast for correct inputs.
      But almost all they tell the users about incorrect inputs
      is that they are incorrect.
      In Larry's words, LALR is "fast but stupid".
    </p><b>2000</b>:
    Larry Wall decides on a radical reimplementation
      of Perl -- Perl 6.
      Larry does not even consider using LALR again.
    </p>
    <p><b>2002</b>:
      Aycock&Horspool publish their attempt at a fast, practical Earley's parser.
      Missing from it is Joop Leo's improvement --
      they seem not to be aware of it.
      Their own speedup is limited in what it achieves
      and the complications it introduces
      can be counter-productive at evaluation time.
      But buried in their paper is a solution to the zero-length rule bug.
      And this time the solution requires no additional bookkeeping.
    </p>
    <p><b>2006</b>:
      GNU announces that the GCC compiler's parser has been rewritten.
      For three decades,
      the industry's flagship C compilers have used
      LALR as their parser --
      proof of the claim that LALR and serious
      parsing are equivalent.
      Now, GNU replaces
      LALR with the technology that
      it replaced a quarter century earlier:
      recursive descent.
    </p>
    <p><b>2000 to today</b>:
    With the retreat from LALR comes a collapse in the
      prestige of parsing theory.
      After a half century,
      we seem to be back
      where we started.
      If you took Ned Iron's original 1961 algorithm,
      changed the names and dates,
      and translated the code from the mix of assembler and
      ALGOL into Haskell,
      you would easily republish it today,
      and bill it as 
      as revolutionary and new.
    </p>
    <p>
    <h3>Marpa</h3>
      Over the years,
      I had come back to Earley's algorithm again and again.
      Around 2010, I realized
      that the original, long-abandoned vision --
      an efficient, practical, general and syntax-driven parser --
      was now, in fact, quite possible.
      The necessary pieces had fallen into place.
    </p>
    <p>
      Aycock&Horspool have solved the zero-length rule bug.
      Joop Leo had found the speedup for right recursion.
      And the issue of bookkeeping overhead had pretty much evaporated on its
      own.
      Machine operations are now a billion times faster than in 1968,
      and probably no longer relevant in any case --
      caches misses are now the bottleneck.
    </p>
    <p>But while the original issues with Earley's disappeared,
      a new issue emerged.
      With a parsing algorithm as powerful as Earley's behind it,
      a syntax-driven approach can do much more than it can with
      a left parser.
      But with the experience with LALR in their collective consciousness,
      few modern programmers are prepared
      to trust a purely declarative parser.
      As Lincoln said, "Once a cat's been burned,
      he won't even sit on a cold stove."
    </p>
    <p>
      To be accepted, Marpa needed to allow
      procedure parsing,
      not just declarative parsing.
      So Marpa allows the user to specify events --
      occurrences of symbols and rules --
      at which declarative parsing pauses.
      While paused,
      the application can call procedural logic
      and single-step forward token by token.
      The procedural logic can hand control back
      over to syntax-driven parsing at any point it likes.
      The Earley tables can provide the procedural logic with
      full knowledge of the state of the
      parse so far:
      all rules recognized
      in all possible parses so far,
      and all symbols expected.
      Earley's algorithm is now a even better companion
      for hand-written procedural logic than recursive descent.
    </p>
    <h3>For more</h3>
    <p>
      For more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
      official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
      Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 16:50 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/09/chron.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
