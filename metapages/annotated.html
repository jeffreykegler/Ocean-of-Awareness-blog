<html>
  <head>
    <link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog//index.rss" />
    <title>
      Ocean of Awareness
    </title>
    <style type="text/css">
      strong {font-weight: 700;}
    </style>
  </head>
  <body>
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
      <h1>
        Ocean of Awareness
      </h1>
    </div>
    <div id="menu" style="margin:0;padding:10px;width:150px;float:left;">
      <h2>
        Jeffrey Kegler's blog
      </h2>
      <p>
        About Marpa, his new parsing algorithm,
        and other topics of interest
      </p>
      <h3>
        On this page
      </h3>
      <p class="view">
        <a href="#NOT_SERIES">
          Posts not part of a series
        </a>
      </p>
      <p class="view">
        <a href="#PARSE_HTML">
          Parsing HTML
        </a>
      </p>
      <p class="view">
        <a href="#COMPARISONS">
          Marpa vs. other parsers</a>
      </p>
      <p class="view">
        <a href="#BOVICIDE">
          The Bovicide series</a>
      </p>
      <p class="view">
        <a href="#PERL_AND_PARSING">
          The Perl and parsing series</a>
      </p>
      <p class="view">
        <a href="#NLP">Natural Language Processing</a>
      </p>
      <p class="view">
        <a href="#VISIONS">Visions</a>
      </p>
      <h3>
        Other Resources
      </h3>
      <p>
        <a href="http://www.jeffreykegler.com/">
          Jeffrey Kegler's personal website
        </a>
      </p>
      <p>
        <a href="http://www.jeffreykegler.com/marpa">
          The Marpa website
        </a>
      </p>
      <p>
        Ocean of Awareness blog
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
          home page
        </a>
        and
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog//metapages/chronological.html">
          chronological index
        </a>
      </p>
    </div>
    <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
      <h1>
        Posts about Marpa: an annotated list
      </h1>
      <h2>
        <a name="#NOT_SERIES">
        </a>
        Posts not part of a series
      </h2>
      <ul>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">Domain-Specific Languages made simpler</a>.
            Practical general parsing makes writing DSL's a lot simpler.
            The example of this post has two full DSL's in less than 600 lines of code,
            test cases included.
	    This is my most popular post.
          </p>
        </li>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/precedence-parsing-made-simpler.html">Precedence parsing made simpler</a>.
            Defining grammars in terms of precedence is an attractive technique.
            General parsing makes it a lot simpler.
            Here's a precedence parsing DSL where you don't have to define your
            operators, much less describe them as infix, postfix, circumfix, etc.
            Which means efficient precedence parsing can be conveniently extended to n-ary
            operations, and can even allow implied operators.
          </p></li>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/the-solved-problem-that-isnt-is.html">The solved problem that isn't, is</a>.
            In an excellent post, Laurence Tratt described parsing as "the solved problem that isn't".
            That expressed my reasons for creating very well I thought.
            In this post, I state point by point why I believe I can accurately claim
            that, with Marpa, the parsing problem is, indeed, now solved.
          </p></li>
      </ul>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/07/partial-parsing-and-error-reporting.html">Partial parsing and error reporting
            </a>
            describes the technique of partial parsing -- parsing
            when you can only deal with some of the target language.
            This technique is useful for incremental parser development.
            It is also the way to really do error reporting well.
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/07/prefixing-the-ruby-slippers-and-the-bigfoot-maneuver.html">Prefixing the Ruby Slippers, and the Bigfoot Maneuver</a>
            goes into the topic even more deeply.
          </p></li><li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/07/two-new-interfaces-to-marpa.html">Two new interfaces to Marpa
            </a>
            describes Libmarpa and Marpa::R2::Thin.
            Libmarpa is the core of Marpa, available as a C library.
            Marpa::R2::Thin is a "thin" wrapper for Libmarpa.
            With Libmarpa, you get pure C language speed.
            With Marpa::R2::Thin, you get the ability to create your
            own Marpa interface in Perl,
            on a completely equal footing with Marpa::R2 itself.
          </p></li><li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/06/the-useful-the-playful-the-easy-the-hard-and-the-beautiful.html">The useful, the playful, the easy, the hard and the beautiful
            </a>
            starts out describing a nice interface to Marpa written by Peter Stuifzand,
            and then gets into a discussion of how number series emerge from grammars.
            I especially enjoyed this post, as apparently did a number of readers.
          </p></li><li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/06/marpa-customizing-the-ruby-slippers.html">Marpa & customizing the Ruby Slippers
            </a>
            announces one of Marpa::R2's more important features.
            The Marpa algorithm, at every point in a parse,
            knows which rules were being recognized and how far recognition had proceeded.
            Much of this information was already available,
            in one form or another,
            in Marpa::XS.
            As of Marpa::R2, the application programmer has
            efficient and direct access to 100% of this
            information.
          </p></li><li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/what-is-the-marpa-algorithm.html">
              What is the Marpa algorithm?
            </a>
            lays out the essentials of the Marpa algorithm.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html">
              Marpa and the Ruby Slippers
            </a>
            talks more about Marpa and the Ruby Slippers.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/01/why-i-stuck-with-perl.html">
              Why I Stuck with Perl
            </a>
            : I liked Python very much, and at the time I started Marpa, Python looked like a better choice in terms of mindshare. In this post, I explain why the initial Marpa implementation uses Perl.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/jay-earleys-idea.html">
              Jay Earley's Idea
            </a>
            : A user-friendly description of Earley's algorithm. Marpa's algorithm is much more complicated, but at heart, Marpa is an Earley parser.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/what-no-lexer.html">
              What? No Lexer!
            </a>
            : A generation of programmers have grown up identifying lexing with parsing. Marpa is not a lexer, and Marpa::XS does not even contain a lexer. This post explains why, and how to get your lexing done if you are using Marpa. (This post is rapidly becoming outdated. Several people have undertaken lexers specifically intended as Marpa front-ends, and I expect that one or more will soon be on CPAN.)
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/developing-parsers-incrementally-with-marpa.html">
              Developing parsers incrementally with Marpa
            </a>
            : Hints on how to get started with Marpa::XS.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/03/user-experiences-with-marpa-some-observations.html">
              User experiences with Marpa
            </a>
            : How users react to Marpa. Of course, I am a hopelessly biased source. but I do get a lot of feedback.
          </p>
        </li>
      </ul>
      <h2><a name="PARSE_HTML">How to parse HTML</a></h2>
      <p>
        This series describes a new strategy for parsing liberal HTML,
        using Marpa and the Ruby Slippers techniques it makes possible.
        It is the most worked out example of Marpa use that I've done to date.
      </p>
      <ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/how-to-parse-html.html">
            How to Parse HTML
          </a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-2.html">
            How to parse HTML, part 2
          </a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-3.html">
            How to parse HTML, part 3
          </a>
        </li>
      </ul>
      <p>The Marpa-based HTML reformatter,
        <tt>html_fmt</tt>,
        is the Marpa application that I use the most.
        In fact, as I am typing this HTML,
        I am using it repeatedly as a filter,
        much in the same way that you'd use
        <tt>gnuindent</tt>
        for C code or
        <tt>perltidy</tt>
        for Perl.
      </p>
      <ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/html_fmt.html">
            A Marpa-based HTML reformatter</a>
        </li>
      </ul>
      <p>When I left off with the first series, I mentioned that an HTML parser really should
        be configurable -- the user/application should be able to decide which variant of HTML
        they want to parse.
        The result is a parser driven by a configuration file that allows the user to reshape
        HTML.
        And, by the way, the configurable version is almost twice as fast.
      </p><ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html.html">
            A configurable HTML parser</a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html2.html">
            A configurable HTML parser, part 2</a>
        </li>
      </ul>
      <h2><a name="COMPARISONS">Marpa v. other parsers</a></h2>
      <p>These posts compare Marpa directly to other parsers,
        with benchmarks.
      </p><ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-v-perl-regexes-some-numbers.html">
              Marpa v. Perl regexes: some numbers
            </a>
            pits Marpa directly against Perl regexes. Marpa will never beat regular expressions at their own game, but regular expressions are often taken out of their game, and in those cases the results can get interesting.
          </p>
        </li><li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/marpa-v-perl-regexes-a-rematch.html">Marpa v. Perl regexes: a rematch</a>
            revisits the comparison of the earlier post.
            In that benchmark, much of the advantage of Perl regexes came, not from faster parsing,
            but from lower overhead.
            This post contains a more direct comparison of the two parse engines.
          </p>
        </li><li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/04/marpa-v-parserecdescent-some-numbers.html">Marpa v. Parse::RecDescent: some numbers</a>
            Recursive descent is currently very popular.
            This post takes an interesting example from another post,
            and rewrites it from Parse::RecDescent into Marpa.
            Marpa has equal time complexity, and its parse engine is written in heavily optimized C,
            while Parse::RecDescent is pure Perl.
            The result is what you'd expect.
          </p>
        </li></ul>
      <h2>
        <a name="BOVICIDE">The Bovicide Series
        </a>
      </h2>
      <p>
        Yacc and its derivatives are considered the standard in parser
        generators. Yacc is part of a great series of traditions it was my
        privilege to watch being formed, and I have the greatest respect
        for its inventors. But to my mind yacc is one tradition more honored
        in the breach than in the observance. In this series I describe
        what will be required for a parsing algorithm to displace yacc's
        LALR, and why I think the Marpa algorithm has what it takes and
        more.
        The first three requirements are described in my first post,
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/killing-yacc-1-2-3.html">
          Killing Yacc: 1, 2 &amp; 3
        </a>
        :
      </p>
      <ul>
        <li>
          <p>
            Requirement 1: Handle Arbitrary Context-Free Grammars in O(n
            <sup>
              3
            </sup>
            )
          </p>
        </li>
        <li>
          <p>
            Requirement 2: Handle "Average" Grammars in Linear Time
          </p>
        </li>
        <li>
          <p>
            Requirement 3: A Sound Theoretical Basis
          </p>
        </li>
      </ul>
      <p>
        Error reporting has long been overlooked, and it is something
        at which yacc was astonishingly bad. I looked at the issue of
        development-time error reporting in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/why-the-bovicidal-rage-killing-yacc-4.html">
          Why
          the Bovicidal Rage?
        </a>
        :
      </p>
      <ul>
        <li>
          <p>
            Requirement 4: Easy Diagnosis of Grammar Problems
          </p>
        </li>
      </ul>
      <p>
        And in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/04/bovicide-5-parse-time-error-reporting.html">
          Bovicide
          5: Parse-time Error Reporting
        </a>
        , I looked at the other half of
        error reporting.
      </p>
      <ul>
        <li>
          <p>
            Requirement 5: Good Reporting of Parse-time Errors
          </p>
        </li>
      </ul>
      <p>
        Both hand-written recursive descent and Marpa meet, to various
        degrees, all five of the previous requirements. The last requirement,
        stated in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/05/bovicide-6-the-final-requirement.html">
          Bovicide
          6: The Final Requirement
        </a>
        , was the tie-breaker. Hand-written
        recursive descent has many strengths, but it will never be available
        as a library.
      </p>
      <ul>
        <li>
          <p>
            Requirement 6: Available as a Library
          </p>
        </li>
      </ul>
      <h2>
        <a name="PERL_AND_PARSING">
        </a>
        The "Perl and parsing" series
      </h2>
      <p>
        My "Perl and parsing" series used Perl to illustrate parsing theory
        and parsing theory to investigate Perl. I am not one of those who
        believes that mathematics takes place in vacuum -- it follows trends
        and even what are more accurately called fashions. Therefore this
        series has a lot of discussion of how current parsing theory came
        to be.
      </p>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/parsing-with-ruby-slippers.html">
              Parsing with Ruby Slippers
            </a>
            : This is the post where I debuted the "Ruby Slippers" parsing technique, using both HTML and an example from Perl to illustrate it.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/parsing-perl-2-down-the-garden-path.html">
              Parsing Perl 2: Down the Garden Path
            </a>
            : Larry Wall did an amazing job getting LALR to work for the Perl grammar, but occasionally the limits show through. The post contains an example.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/07/parsing-perl-3-perl-and-minimalism.html">
              Parsing Perl 3: Perl and Minimalism
            </a>
            : I had intended a couple of posts about Perl &amp; parsing. At this point I realized the topic was expanding on me. This post is about the influence of minimalism on computer languages and parsing theory. Larry Wall is perhaps the only language design who has managed to escape the influence of minimalism and that is the reason Perl is so different from other languages.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/miniminalism-philosophy-tradition-or-lunacy.html">
              Minimalism: Philosophy, Tradition, or Lunacy?
            </a>
            An explanation of why the programmers of my generation and prior -- the ones who shaped the field -- are, almost without exception, stanch minimalists. Not numbered as part of the series, but it fits into the discussion of minimalism.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/08/perl-and-parsing-4-the-golden-age-of-right-parsing.html">
              Perl and Parsing 4: The Golden Age of Right Parsing
            </a>
            : Having nibbled at philosophy, I now charge into a history of parsing theory. My approach is unusual. I treat parsing theory as what it is: a human endeavor. This post describes the rise of LR, or right parsing.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/09/perl-and-parsing-6-rewind.html">
              Perl and Parsing 5: Rewind
            </a>
            : If you require evidence that parsing theory can be as much about trends, ideology and fashion as it is about mathematics and techology, here it is. The dominant parsing algorithm for production compilers today is hand-written recursive descent, exactly the one that was displaced in 1975, when the technology was almost unimaginably less powerful.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/01/perl-and-parsing-6-error-handling.html">
              Perl and Parsing 6: Error Handling
            </a>
            : A discussion of Perl error detection. Despite the limits of its underlying LALR parse engine, the Perl interpreter can seem psychic at times. I show how the conjuring is done, and give some other examples where the limits imposed by LALR parsing show up very clearly.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/02/perl-and-parsing-7-do-list-operators-have-leftright-precedence.html">
              Perl and Parsing 7: Do List Operators have Left/Right Precedence?
            </a>
            : The documents describe Perl's list operators in terms of left- and right-precedence. Despite the fancy names, these are not terms from parsing theory and are not well-defined. In this post I show that, whatever their meaning, it is wrong, and I propose an alternative.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/03/perl-and-parsing-8-the-where-and-why-of-rejection.html">
              Perl and Parsing 8: The Where and Why of Rejection
            </a>
            : Sometimes Perl is just not that into your syntax. An illustration of the limits of LALR error detection, using Perl.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html">
              Perl and Parsing 9: "Use" and the Ruby Slippers
            </a>
            : While Marpa is the first parser to allow it in anything close to its full power and generality, Ruby Slippers parsing is not unprecedented. Perl parses its use statement by dummying up tokens based on the grammar. But in order to use the Ruby Slippers, so unhelpful is LALR, Perl has to simulate the parse inside the lexer.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-10-use-the-easier-way.html">
              Perl and Parsing 10: "Use" the Easier Way
            </a>
            : In this post I use Marpa to parse Perl's use statement. Marpa is a lot better at the Ruby Slippers technique, but here the problem can be solved even more simply with another of Marpa's extended capabilities: ambiguous tokens. Ambiguous tokens are tokens whose type is left uncertain. It is left up to the parser to decide which token to use, something which Marpa can do easily.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-11-are-all-perl-programs-parseable.html">
              Perl and Parsing 11: Are all Perl programs parseable?
            </a>
            The answer is no. Because I was the first to formally prove it, I initially got the blame, and now get the credit as the discoverer that Perl parsing is undecidable. While a very interesting result, its significance can be overstated. In particular, while undecidable parsing has definite benefits for the Perl user, no downside has ever been demonstrated.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-12-beating-up-on-the-use-statement.html">
              Perl and Parsing 12: Beating up on the "use" statement
            </a>
            . I had spotted a gotcha in the parsing of the "use" statement, which I saved up from from the previous two posts. In the meantime chromatic noticed another. Piling on is really not fair but, hey, can you really blame me for unlucky timing?
          </p>
        </li>
      </ul>
      <h2><a name="NLP">Natural Language Processing</a></h2>
      <ul>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/03/the-syntax-of-english-is-undecidable.html">The
              syntax of English is undecidable</a>.
            Many of those most interested in Marpa are from the natural language processing (NLP) community.
            In taking on natural language,
            as in taking on any other computing task,
            a reasonable first question is, "Is it decidable?".
            This post claims to answer that question.
          </p></li></ul>
      <h2><a name="VISIONS">Visions</a></h2>
      <p>A warning to the reader:
        The posts in this section are my most misunderstood,
        and therefore, so far, can be called my least successful.
        These are posts in which I outline future directions,
        as plainly and simply as I know how to,
        uncluttered by details.
        The problem seems to be that, without technical details
        and code examples,
        many readers take my words
        as pleasant speculations,
        and not as I intend them,
	as descriptions of things
        that can be done now, today.
      </p>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/quantum.html">
              Parsing on your new hyper-quantum computer</a>
            Marpa is a non-deterministic parser, and those used to coping with recursive decsent are
            used to thinking in terms of a single thread.
            With non-determinism, you become free of all that backtracking and lookahead,
            and your parser becomes simpler and more modular.
            This requires a re-visioning of parsing, but it is very similar to the re-visioning
            you'd need to do if you were suddenly delivered new non-deterministic hardware
            and asked to program efficiently for it.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/03/making-the-parsing-game-safe.html">
              Making the parsing game safe</a>:
            What Marpa means for Domain-Specific Languages (DSLs) and Language-Oriented Programming (LOP).
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/marpa-and-oo.html">
              Marpa and OO</a>:
            Like it says.
            Object-oriented programming and how it relates to Marpa.
          </p>
        </li>
      </ul>
    </div>
    <div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
      <p>
        This is Ocean of Awareness's
        new home. This blog has been hosted at
        <a href="http://blogs.perl.org/users/jeffrey_kegler/">
          blogs.perl.org
        </a>
        but I have succumbed to the lure of static blogging.
        I have not yet decided how to deal with comments at this new blog location.
        If the post is Marpa-related,
        <a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
          the Marpa mailing list
        </a>
        is a good place to comment.
        Also,
        I will continue to dual-post for some time,
        and have not yet frozen comments on the versions of the
        post at
        <a href="http://blogs.perl.org/users/jeffrey_kegler/">
          blogs.perl.org
        </a>
        .
      </p>
    </div>
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
      var pageTracker = _gat._getTracker("UA-33430331-1");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>
  </body>
</html>
