<html>
  <head>
    <link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog//index.rss" />
    <title>
      Ocean of Awareness
    </title>
    <style type="text/css">
      strong {font-weight: 700;}
    </style>
  </head>
  <body>
    <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    <div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
      <h1>
        Ocean of Awareness
      </h1>
    </div>
    <div id="menu" style="margin:0;padding:10px;width:150px;float:left;">
      <h2>
        Jeffrey Kegler's blog
      </h2>
      <p>
        About Marpa, his new parsing algorithm,
        and other topics of interest
      </p>
      <h3>
        On this page
      </h3>
      <p class="view">
        <a href="#TUTORIAL">
          Tutorials</a>
      </p>
      <p class="view">
        <a href="#DSL">
          Language-driven programming</a>
      </p>
      <p class="view">
        <a href="#GENERAL">
          About Marpa in general</a>
      </p>
      <p class="view">
        <a href="#PARSING">
          About parsing in general</a>
      </p>
      <p class="view">
        <a href="#DESIGN">
          Language design</a>
      </p>
      <p class="view">
        <a href="#PARSE_HTML">
          Parsing HTML</a>
      </p>
      <p class="view">
        <a href="#COMPARISONS">
          Marpa vs. other parsers</a>
      </p>
      <p class="view">
        <a href="#BOVICIDE">
          The Bovicide series</a>
      </p>
      <p class="view">
        <a href="#PERL_AND_PARSING">
          The Perl and parsing series</a>
      </p>
      <p class="view">
        <a href="#NLP">Natural Language Processing</a>
      </p>
      <p class="view">
        <a href="#THEORY">Theory</a>
      </p>
      <p class="view">
        <a href="#VISIONS">Visions</a>
      </p>
      <p class="view">
        <a href="#OLD_TUTORIAL">Older Tutorials</a>
      </p>
      <h3>
        Other Resources
      </h3>
      <p>
        <a href="http://www.jeffreykegler.com/">
          Jeffrey Kegler's personal website</a>
      </p>
      <p>
        <a href="http://jeffreykegler.github.com/Marpa-web-site/">
          The Marpa website</a>
      </p>
      <p>
        Ocean of Awareness blog
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/">
          home page</a>
        and
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog//metapages/chronological.html">
          chronological index</a>
      </p>
    </div>
    <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
      <h1>
        Posts about Marpa: an annotated list
      </h1>
      <h2><a name="TUTORIAL">Tutorials</a></h2>
      <p>
        Practical general parsing makes writing a DSL much simpler than it has been in the past.
        The posts in this series of tutorials are among my most popular.
        Although
        you can join the series starting at a topic of special interest,
        the easiest way to read (or at least skim)
        them is in the order listed.
      </p>
      <ul>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">
              Making DSL's even simpler</a>.
            The best place to start.
            An updated version of one of my most popular posts,
            it describes Marpa's Scanless interface (SLIF).
          </p></li>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html">
              Announcing Marpa's Scanless interface</a>.
            The announcement of the Scanless interface, this also includes a small tutorial.
          </p></li>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/self_lex.html">
              A self-parsing and self-lexing grammar</a>.
            A tutorial that walks through the Scanless interface's own self-defining and self-hosting
            grammar.
            Reading a grammar that is defining itself can cause dizziness, but if you tolerate
            that sort of thing,
            this makes an excellent advanced tutorial.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/03/bnf_to_ast.html">
              BNF to AST</a>
            This post is based on the chapter on the Language Design Pattern,
            from the very influential
            <a href="http://en.wikipedia.org/wiki/Design_Patterns">
              Design Patterns book</a>.
            In that book, the authors (widely known as the Gang of Four)
            did not attempt to parse the language of their example --
            there was
            no simple way to produce an AST straight from BNF.
            Now there is.
            This tutorial contains the Gang of Four example worked out in full with a Marpa-based
            parser, and
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/03/interpreter.html">
              a sequel</a>
            talks about some of the implications of easier parsing.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/04/procedural.html">
              Marpa and procedural parsing</a>.
            "Procedural parsing" is a fancy term for giving up on your parsing algorithm and just hacking
            out the parse.
            With the currently favored parsing algorithms, a lot of this type of code is
            necessary, and programmers have come to expect a parser to allow for it.
            Marpa tries to offer the best of both worlds:
            a declarative parser which knows exactly where it is in your BNF at all times,
            but one which is willing to step out of the way and let custom code take over,
            at the same time sharing what it knows with the custom code.
            Perl heredocs are an example of a language feature which requires procedural
            parsing.
            Parsing these correctly requires jumping back and forth in the input.
            This tutorial for this post shows how to handle them straightforwardly using Marpa's SLIF.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/06/mixing-procedural.html">
              Mixing procedural and declarative parsing</a>.
            This post is another example that combines procedural and syntax-driven parsing
            in order to get the best of both worlds.
          </p>
        </li>
      </ul>
      <p>If you're looking for tutorials, you'll want to start, and probably to
        end, with those based on the SLIF interface.
        The best of mine for the beginner are above, in this section.
        The
        <a href="#DESIGN">section on programming language design</a>
        also contains some posts whose examples work as SLIF-based tutorials.
      </p>
      <p>
        While SLIF-based tutorials should be strongly preferred, my
        pre-SLIF tutorials,
        <a href="#OLD_TUTORIAL">
          described below</a>
        may still have some value.
        They contain many useful examples,
        and most of the code in them carries over to SLIF line-for-line.
      </p>
      <h2><a name="DSL"></a>Language-driven programming</h2>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/03/interpreter.html">
              The Interpreter Design Pattern</a>.
            The Language Design Pattern,
            is from the very influential
            <a href="http://en.wikipedia.org/wiki/Design_Patterns">
              Design Patterns book</a>,
            which was the subject of
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/03/bnf_to_ast.html">
              one of my tutorials</a>.
            This post discusses the implications for the Language Design Pattern of making
            parsers much easier to write.
          </p><p>
          </p></li>
        <li>
          <p>
            In 1980, George Copeland wrote
            <a href="http://dl.acm.org/citation.cfm?id=802685">
              an article titled "What if Mass Storage were Free?"</a>
            Afterwards, the cost of mass storage fell dramatically.
            Copeland saw the first signs of this, and ran a thought experiment:
            What might happen costs fell to the point where mass storage was, in effect, free?
            This post runs a similar thought experiment on languages.
            What might happen when the time and effort required to create a new language
            falls toward zero?
          </p>
        </li>
      </ul>
      <h2><a name="GENERAL"></a>About Marpa in general</h2>
      <ul>
        <li><p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/05/table.html">
              Why Marpa works: table parsing</a>.
            Marpa is different from the other widely used parsers.
            The others use stacks, state machines or both.
            Marpa is a table parser.
            This post explains the advantages of table parsing,
            but also the challenges faced in implementing it.
          </p>
        </li>
        <li><p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/the-solved-problem-that-isnt-is.html">The solved problem that isn't, is</a>.
            In an excellent post, Laurence Tratt described parsing as "the solved problem that isn't".
            Tratt expressed my reasons for creating Marpa very well.
            I claim that,
            with Marpa, the parsing problem is, in fact, now solved.
            In this post I state, point by point, why I believe
            I can accurately make that claim.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/self_parse.html">
              A grammar that exemplifies, describes and parses itself</a>:
            &nbsp;This post contains the grammar for Marpa's new BNF interface,
            a grammar that is both self-description and self-example.
            In the 1970's self-reference was very much the fashion.
            But this grammar is not just for looks -- it drives its own compiler
            and will be the basis of its own development:
            it is handy enough as an interface
            to make dealing with a circular dependency worthwhile.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html">
              Marpa and the Ruby Slippers</a>
            An older post,
            but one with a nice explanation of one of Marpa's significant new features:
            Ruby Slippers parsing.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/01/why-i-stuck-with-perl.html">
              Why I Stuck with Perl</a>:
            I liked Python very much, and at the time I started
            Marpa, Python looked like a better choice in terms
            of mindshare. In this post, I explain why the initial
            Marpa implementation uses Perl.
            This post has been very popular, even
            being translated into Japanese.
          </p>
        </li>
      </ul>
      <h2><a name="PARSING"></a>About parsing in general</h2>
      <p>In the process of writing Marpa, I read and thought a lot
        about the various approaches to parsing,
        and how they developed.
        When I came to share my thoughts, it turned quite a few people
        were interested.
        These posts also discuss the ideas behind
        Marpa, and how they relate to other parsing algorithms.
      </p>
      <ul><li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html">
              Parsing: a timeline</a>
            A timeline of parsing research, describing how other algorithm pushed the parsers
            in the Earley lineage
            (like Marpa)
            aside, only for it all to come down twisted.
            This is
            the most technical post I've ever dared put on this blog.
            Suprisingly, it was also a runaway hit.
            Within its first two weeks it became my most popular post, by far.
            The development of the various parsing algorithms is an interesting story,
            one that has never really been told as a story before.
            Readers apparently liked this.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/11/ll.html">
              Parsing: top-down and bottom-up</a>
            If "Parsing: a timeline" was about "when and how?",
            then this is about "why?"
            It describes the concepts behind the two major traditional approaches to
            parsing and confronts some questions:
            Why did
            the invention of bottom-up parsing create so much
            enthusiasm?
            Why, despite bottom-up's abandonment by practitioners,
            does it still play such a big role in classrooms and in textbooks?
            What does this say about the way forward?
            Is there one?
          </p>
        </li>
        <li>
          <p><a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/11/successful.html">
              What makes a parsing algorithm successful?</a>Some parsers have lasting success,
	      others do not.
	      What makes the difference?
	      This post identifies two properties.
	      First, having a <b>workable</b> definition of the grammars it parses in linear time.
	      Second, allowing the user to intervene in the parse with custom logic.
	      Successful parsers have one property or the other.
	      Interesting, neither of these figures into most parser comparisons.
          </p>
        </li>
      </ul><h2><a name="DESIGN">Designing languages</a></h2>
      <p>Marpa allows things to be done which
        could not be done before.
        Many of these things are significant for language design --
        they allow languages to take radically new and aggressive approaches
        to their syntax.
      </p>
      <ul>
        <li>
          <p>
            <a href="
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/08/ambig.html">Language
              Design: exploiting ambiguity</a>.
            Actual ambiguity is a show-stopper.
            But in the present state of the art,
            even potential ambiguity is totally avoided in language design.
            Which only makes sense, right?
          </p><p>
            Well, actually, no.
            Our workhorse languages, the ones we humans use to communicate with each other,
            are full of potential ambiguities, and allowing ambiguity makes those languages more
            powerful and flexible.  Could that same work for computer languages?
            This post explores that possibility.
          </p></li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/03/kv.html">Evolvable
              languages</a>.
            The parsers in heaviest use today (LALR and recursive descent) parse only
            a very limited subset of what you can express in in BNF.
            That's a barrier that a language starts bumping up against almost immediately,
            and bumps up against more and more frequently as its adds features.
          </p>
          <p>
            But Marpa lets you keep extending your language and (essentially) as long as you can
            describe your language extension in BNF,
            or in BNF plus some hacks, you can still
            parse the language in linear time.
            "Language design has been like shooting
            crap in a casino that sets you up to win a lot of the first rolls
            before the laws of probability grind you down.
            Marpa changes the game."
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/02/semantic_ws.html">Significant newlines?
              Or semicolons?</a>.
            Currently a programming language designer must choose: either make whitespace semantically significant,
            or use explicit punctuation to separate statements.
            But Lua does without either, by keeping the syntax restricted and tiny.
            And with the power of Marpa, you can also do without either, but at the same time have a lanuage which
            is as large and as syntactically
            rich as you want.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/delimiter.html">
              Reporting mismatched delimiters</a>.
            Delimiters are parentheses and brackets, but also quote marks and even HTML
            and XML tags -- anything that explicitly marks the beginning and end of some text.
            Delimiters are widely used,
            easy to get wrong and,
            in current practice,
            annoying to fix, in large part because current parsers are not good at diagnosing
            delimiter mismatches.
            Worse, a mismatched delimiter will almost certainly make the rest of a compiler's
            error message so unreliable that they are effectively useless.
          </p><p>Marpa allows more accurate reporting of delimiter mismatches than traditional
            parsers,
            and in most cases Marpa can recover and go on to accurately report other errors.
            Read this blog post to find out how.
            Hint: the Ruby Slippers get involved.
          </p></li></ul>
      <h2><a name="PARSE_HTML">How to parse HTML</a></h2>
      <p>
        This series describes a new strategy for parsing liberal HTML,
        using Marpa and the Ruby Slippers techniques it makes possible.
        It is the most worked out example of Marpa use that I've done to date.
      </p>
      <ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/how-to-parse-html.html">
            How to Parse HTML</a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-2.html">
            How to parse HTML, part 2</a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-3.html">
            How to parse HTML, part 3</a>
        </li>
      </ul>
      <p>The Marpa-based HTML reformatter,
        <tt>html_fmt</tt>,
        is the Marpa application that I use the most.
        In fact, as I am typing this HTML,
        I am using it repeatedly as a filter,
        much in the same way that you'd use
        <tt>gnuindent</tt>
        for C code or
        <tt>perltidy</tt>
        for Perl.
      </p>
      <ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/html_fmt.html">
            A Marpa-based HTML reformatter</a>
        </li>
      </ul>
      <p>When I left off with the first series, I mentioned that an HTML parser really should
        be configurable -- the user/application should be able to decide which variant of HTML
        they want to parse.
        The result is a parser driven by a configuration file that allows the user to reshape
        HTML.
        And, by the way, the configurable version is almost twice as fast.
      </p><ul>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html.html">
            A configurable HTML parser</a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html2.html">
            A configurable HTML parser, part 2</a>
        </li>
        <li>
          <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html3.html">
            Configuring the Ruby Slippers for HTML</a>
        </li>
      </ul>
      <h2><a name="COMPARISONS">Marpa v. other parsers</a></h2>
      <p>These posts compare Marpa directly to other parsers,
        with benchmarks.
      </p><ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-v-perl-regexes-some-numbers.html">
              Marpa v. Perl regexes: some numbers</a>
            pits Marpa directly against Perl regexes. Marpa will never beat regular expressions at their own game, but regular expressions are often taken out of their game, and in those cases the results can get interesting.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/marpa-v-perl-regexes-a-rematch.html">Marpa v. Perl regexes: a rematch</a>
            revisits the comparison of the earlier post.
            In that benchmark, much of the advantage of Perl regexes came, not from faster parsing,
            but from lower overhead.
            This post contains a more direct comparison of the two parse engines.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/04/marpa-v-parserecdescent-some-numbers.html">Marpa v. Parse::RecDescent: some numbers</a>.
            Recursive descent is currently very popular.
            This post takes an interesting example from another post,
            and rewrites it from Parse::RecDescent into Marpa.
            Marpa has equal time complexity, and its parse engine is written in heavily optimized C,
            while Parse::RecDescent is pure Perl.
            The result is what you'd expect.
          </p>
        </li>
      </ul>
      <h2><a name="BOVICIDE">The Bovicide Series</a></h2>
      <p>
        Yacc and its derivatives are considered the standard in parser
        generators. Yacc is part of a great series of traditions it was my
        privilege to watch being formed, and I have the greatest respect
        for its inventors. But to my mind yacc is one tradition more honored
        in the breach than in the observance. In this series I describe
        what will be required for a parsing algorithm to displace yacc's
        LALR, and why I think the Marpa algorithm has what it takes and
        more.
        The first three requirements are described in my first post,
        <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/killing-yacc-1-2-3.html">
          Killing Yacc: 1, 2 &amp; 3</a>
        :
      </p>
      <ul>
        <li>
          <p>
            Requirement 1: Handle Arbitrary Context-Free Grammars in O(n<sup>3</sup>)
          </p>
        </li>
        <li>
          <p>
            Requirement 2: Handle "Average" Grammars in Linear Time
          </p>
        </li>
        <li>
          <p>
            Requirement 3: A Sound Theoretical Basis
          </p>
        </li>
      </ul>
      <p>
        Error reporting has long been overlooked, and it is something
        at which yacc was astonishingly bad. I looked at the issue of
        development-time error reporting in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/why-the-bovicidal-rage-killing-yacc-4.html">
          Why the Bovicidal Rage?</a>:
      </p>
      <ul>
        <li>
          <p>
            Requirement 4: Easy Diagnosis of Grammar Problems
          </p>
        </li>
      </ul>
      <p>
        And in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/04/bovicide-5-parse-time-error-reporting.html">
          Bovicide 5: Parse-time Error Reporting</a>,
        I looked at the other half of
        error reporting.
      </p>
      <ul>
        <li>
          <p>
            Requirement 5: Good Reporting of Parse-time Errors
          </p>
        </li>
      </ul>
      <p>
        Both hand-written recursive descent and Marpa meet, to various
        degrees, all five of the previous requirements. The last requirement,
        stated in
        <a
href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/05/bovicide-6-the-final-requirement.html">
          Bovicide 6: The Final Requirement</a>,
        was the tie-breaker. Hand-written
        recursive descent has many strengths, but it will never be available
        as a library.
      </p>
      <ul>
        <li>
          <p>
            Requirement 6: Available as a Library
          </p>
        </li>
      </ul>
      <h2><a name="PERL_AND_PARSING"></a>The "Perl and parsing" series</h2>
      <p>
        My "Perl and parsing" series used Perl to illustrate parsing theory
        and parsing theory to investigate Perl. I am not one of those who
        believes that mathematics takes place in vacuum -- it follows trends
        and even what are more accurately called fashions. Therefore this
        series has a lot of discussion of how current parsing theory came
        to be.
      </p>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/parsing-with-ruby-slippers.html">
              Parsing with Ruby Slippers</a>:
            This is the post where I debuted the "Ruby Slippers" parsing technique, using both HTML and an example from Perl to illustrate it.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/parsing-perl-2-down-the-garden-path.html">
              Parsing Perl 2: Down the Garden Path</a>:
            Larry Wall did an amazing job getting LALR to work for the Perl grammar, but occasionally the limits show through. The post contains an example.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/07/parsing-perl-3-perl-and-minimalism.html">
              Parsing Perl 3: Perl and Minimalism</a>:
            I had intended a couple of posts about Perl &amp; parsing. At this point I realized the topic was expanding on me. This post is about the influence of minimalism on computer languages and parsing theory. Larry Wall is perhaps the only language design who has managed to escape the influence of minimalism and that is the reason Perl is so different from other languages.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/12/miniminalism-philosophy-tradition-or-lunacy.html">
              Minimalism: Philosophy, Tradition, or Lunacy?</a>
            An explanation of why the programmers of my generation and prior -- the ones who shaped the field -- are, almost without exception, stanch minimalists. Not numbered as part of the series, but it fits into the discussion of minimalism.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/08/perl-and-parsing-4-the-golden-age-of-right-parsing.html">
              Perl and Parsing 4: The Golden Age of Right Parsing</a>:
            Having nibbled at philosophy, I now charge into a history of parsing theory. My approach is unusual. I treat parsing theory as what it is: a human endeavor. This post describes the rise of LR, or right parsing.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/09/perl-and-parsing-6-rewind.html">
              Perl and Parsing 5: Rewind</a>:
            If you require evidence that parsing theory can be as much about trends, ideology and fashion as it is about mathematics and techology, here it is. The dominant parsing algorithm for production compilers today is hand-written recursive descent, exactly the one that was displaced in 1975, when the technology was almost unimaginably less powerful.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/01/perl-and-parsing-6-error-handling.html">
              Perl and Parsing 6: Error Handling</a>:
            A discussion of Perl error detection. Despite the
            limits of its underlying LALR parse engine, the Perl
            interpreter can seem psychic at times. I show how the
            conjuring is done, and give some other examples where
            the limits imposed by LALR parsing show up very
            clearly.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/02/perl-and-parsing-7-do-list-operators-have-leftright-precedence.html">
              Perl and Parsing 7: Do List Operators have Left/Right Precedence?</a>:
            The documents describe Perl's list operators in terms
            of left- and right-precedence. Despite the fancy
            names, these are not terms from parsing theory and
            are not well-defined. In this post I show that,
            whatever their meaning, it is wrong, and I propose
            an alternative.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/03/perl-and-parsing-8-the-where-and-why-of-rejection.html">
              Perl and Parsing 8: The Where and Why of Rejection</a>:
            Sometimes Perl is just not that into your syntax. An
            illustration of the limits of LALR error detection,
            using Perl.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html">
              Perl and Parsing 9: "Use" and the Ruby Slippers</a>:
            While Marpa is the first parser to allow it in anything
            close to its full power and generality, Ruby Slippers
            parsing is not unprecedented. Perl parses its use
            statement by dummying up tokens based on the grammar.
            But in order to use the Ruby Slippers, so unhelpful
            is LALR, Perl has to simulate the parse inside the
            lexer.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-10-use-the-easier-way.html">
              Perl and Parsing 10: "Use" the Easier Way</a>:
            In this post I use Marpa to parse Perl's use statement.
            Marpa is a lot better at the Ruby Slippers technique,
            but here the problem can be solved even more simply
            with another of Marpa's extended capabilities: ambiguous
            tokens. Ambiguous tokens are tokens whose type is left
            uncertain. It is left up to the parser to decide which
            token to use, something which Marpa can do easily.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-11-are-all-perl-programs-parseable.html">
              Perl and Parsing 11: Are all Perl programs parseable?</a>.
            The answer is no. Because I was the first to formally
            prove it, I initially got the blame, and now get the
            credit as the discoverer that Perl parsing is undecidable.
            While a very interesting result, its significance can
            be overstated. In particular, while undecidable parsing
            has definite benefits for the Perl user, no downside
            has ever been demonstrated.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/10/perl-and-parsing-12-beating-up-on-the-use-statement.html">
              Perl and Parsing 12: Beating up on the "use" statement</a>.
            I had spotted a gotcha in the parsing of the "use"
            statement, which I saved up from from the previous
            two posts. In the meantime chromatic noticed another.
            Piling on is really not fair but, hey, can you really
            blame me for unlucky timing?
          </p>
        </li>
      </ul>
      <h2><a name="NLP">Natural Language Processing</a></h2>
      <ul>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/03/the-syntax-of-english-is-undecidable.html">The
              syntax of English is undecidable</a>.
            Many of those most interested in Marpa are from the natural language processing (NLP) community.
            In taking on natural language,
            as in taking on any other computing task,
            a reasonable first question is, "Is it decidable?".
            This post claims to answer that question.
          </p></li>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/07/lovelace.html">
              Parsing Ada Lovelace</a>.
            I wrote this post when I started exploring parsing ambiguity.
            Following this line of inquiry eventually resulted in a new way of handling ambiguity in programming languages -- allowing
            potential ambiguities in the grammar, but not allowing actual ambiguities.
            (An actual ambiguity, when it occurs, is handled in much the same way as a syntax error.
            And it can be fixed, for example, by adding parentheses, or whatever other punctuation eliminates
            the ambiguity.)
            My primary concern is programming language issues, not natural languages issues,
            but I find going back and forth between the two very fruitful.
          </p><p>
          </p></li>
      </ul>
      <h2><a name="THEORY">Theory</a></h2>
      <p>Behind Marpa is a lot of mathematics,
        a lot of it old, but also some new.
        The posts below are for those curious about the Theory side of Marpa.
        (The definitive source is
        <a href="https://docs.google.com/file/d/0B9_mR_M2zOc4Ni1zSW5IYzk3TGc/edit?usp=sharing">
          my paper on the theory behind Marpa</a>, but that assumes the reader
        is comfortable with the mathematics of Parsing Theory.)
      </p><ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2010/06/jay-earleys-idea.html">
              Jay Earley's Idea</a>:
            A user-friendly description of Earley's algorithm.
            Marpa's algorithm is much more complicated, but at
            heart, Marpa is an Earley parser.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/04/fast_enough.html">
              Is Earley parsing fast enough?</a>:
            In 1968, Earley's algortihm was considered too slow to be practical for production.
            Now Earley's has improved and computers are over a billion times faster.
            Maybe, after 45 years, the old rule of thumb on Earley parsing speed needs revisiting.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/what-is-the-marpa-algorithm.html">
              What is the Marpa algorithm?</a>
            lays out the essentials of the Marpa algorithm.
            Does not require the reader to be
            mathematically inclined,
            but even that reader might want to look here
            before digging into
            <a href="https://docs.google.com/file/d/0B9_mR_M2zOc4Ni1zSW5IYzk3TGc/edit?usp=sharing">
              the actual theory paper</a>.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/06/the-useful-the-playful-the-easy-the-hard-and-the-beautiful.html">
              The useful, the playful, the easy, the hard and the beautiful</a>
            starts out describing a nice interface to Marpa written by Peter Stuifzand,
            and then gets into a discussion of how number series emerge from grammars.
            I especially enjoyed this post, as apparently did a number of readers.
          </p>
        </li>
      </ul>
      <h2><a name="VISIONS">Visions</a></h2>
      <p>A warning to the reader:
        The posts in this section are my most misunderstood,
        and therefore, so far, can be called my least successful.
        These are posts in which I outline future directions,
        as plainly and simply as I know how to,
        uncluttered by details.
        The problem seems to be that, without technical details
        and code examples,
        many readers take my words
        as pleasant speculations,
        and not as I intend them,
        as descriptions of things
        that can be done now, today.
      </p>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/quantum.html">
              Parsing on your new hyper-quantum computer</a>
            Marpa is a non-deterministic parser, and those used to coping with recursive decsent are
            used to thinking in terms of a single thread.
            With non-determinism, you become free of all that backtracking and lookahead,
            and your parser becomes simpler and more modular.
            This requires a re-visioning of parsing, but it is very similar to the re-visioning
            you'd need to do if you were suddenly delivered new non-deterministic hardware
            and asked to program efficiently for it.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/03/making-the-parsing-game-safe.html">
              Making the parsing game safe</a>:
            What Marpa means for Domain-Specific Languages (DSLs) and Language-Oriented Programming (LOP).
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/marpa-and-oo.html">
              Marpa and OO</a>:
            Object-oriented programming and how it relates to Marpa.
          </p>
        </li>
      </ul>
      <h2><a name="OLD_TUTORIAL">Older tutorials</a></h2>
      <p>These tutorial were written before the SLIF interface was created.
        Today, you'd want to use the SLIF in most of these cases.
        But most of their contents are still relevant,
        and most of the actual code would simply be carried over.
      </p>
      <ul>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">
              Domain-Specific Languages made simpler</a>.
            This is the predecessor of
            "<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">Making
              DSL's even simpler</a>".
            It's an example of how to write a DSL without using Marpa's own DSL-writing DSL's,
            instead boot-strapping your own.
            It has two full DSL's in less than 600 lines of code.
          </p>
        </li>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/precedence-parsing-made-simpler.html">Precedence parsing made simpler</a>.
            Defining grammars in terms of precedence is an attractive technique.
            General parsing makes it a lot simpler.
            Here's a precedence parsing DSL where you don't have to define your
            operators, much less describe them as infix, postfix, circumfix, etc.
            Which means efficient precedence parsing can be conveniently extended to n-ary
            operations, and can even allow implied operators.
          </p>
        </li>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/error.html">
              A Marpa DSL tutorial: Error reporting made easy</a>.
            Your quickly written
            domain-specific language can, as of its first draft,
            have error reporting whose helpfulness and precision
            exceeds that of carefully hand-crafted production
            compilers. This tutorial shows how.
          </p>
        </li>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/pattern_search.html">
              A Marpa tutorial: pattern searches</a>.
            We use regular expressions for pattern searching these days.
            But what if your search target is not a regular expression?
            This tutorial shows how to use Marpa to search text
            files for arbitrary context-free expressions.
          </p>
        </li>
        <li>
          <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/iterative.html">
              A Marpa tutorial: iterative parser development</a>.
            Unanchored search and error reporting are examples of the same general problem:
            finding a desired pattern/language,
            when it is embedded in other, aribitrary, text.
            This approach can also be used as a test-driven method
            for parser development.
          </p><p>You start with a small subset,
            and to test how far you've succeeded,
            you "search" for it in the text you are trying to parse.
            As you add syntax, you "find" more and larger "targets" in your texts.
            When all "searches" of valid texts
            finds a single "target" which spans the entire text,
            the language is finished.
          </p><p>This tutorial gives an example of one iteration in the development
            cycle of a parser.
            It takes the language of the previous post
            (a small subset of Perl expressions)
            and extends a bit.
          </p></li></ul>
      <p>
        These posts, while not full-fledged tutorials,
        have a "how-to" focus.
      </p>
      <ul>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/developing-parsers-incrementally-with-marpa.html">
              Developing parsers incrementally with Marpa</a>:
            Hints on how to get started with Marpa::XS.
          </p>
        </li>
        <li>
          <p>
            <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/01/what-no-lexer.html">
              What? No Lexer!</a>:
            A generation of programmers have grown up identifying
            lexing with parsing. Marpa is not a lexer, and Marpa::XS
            itself does not contain a lexer.
            The tutorials above contain very nice lexers,
            written in a few short lines of Perl.
          </p>
        </li>
      </ul>
      <div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
        <p>
          This is Ocean of Awareness's
          new home. This blog has been hosted at
          <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
          but I have succumbed to the lure of static blogging.
          I have not yet decided how to deal with comments at this new blog location.
          If the post is Marpa-related,
          <a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
            the Marpa mailing list</a>
          is a good place to comment.
        </p>
      </div>
      <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
      <script type="text/javascript">
      try {
      var pageTracker = _gat._getTracker("UA-33430331-1");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>
    </div></body>
</html>
