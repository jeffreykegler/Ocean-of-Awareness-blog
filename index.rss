<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Undershoot: Parsing theory in 1965</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/07/knuth_1965_2.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body style=&quot;max-width:850px&quot;&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;blockquote&gt;The difference between theory and practice is
      that in theory there is no difference between
      theory and practice,
      but in practice, there is.&lt;a id=&quot;footnote-1-ref&quot; href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      Once it was taken seriously that humans might have the power to, for
      example, &quot;read&quot; a chessboard in a way that computers could not beat.
      This kind of &quot;computational mysticism&quot; has taken a beating.
      But it survives in one last stronghold -- parsing theory.
    &lt;/p&gt;&lt;p&gt;
      In
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html&quot;&gt;
        a previous post&lt;/a&gt;,
      I asked &quot;Why is parsing considered solved?&quot;
      If the state of the art of computer parsing is taken as anything close to its ultimate solution,
      then it is a case of &quot;human exceptionalism&quot; --
      the human brain has some
      power that makes it much better at parsing than computers can be.
      It is very unlikely resorting to human exceptionalism as an explanation
      would be accepted
      for any other problem in computer science.
      Why is it accepted for parsing theory?&lt;a id=&quot;footnote-2-ref&quot; href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
      The question really requires two separate answers:
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;&quot;Why do practitioners accept the current state of the art as the solution?&quot; and
      &lt;/li&gt;&lt;li&gt;&quot;Why do the theoreticians accept the current state of the art as the solution?&quot;
      &lt;/li&gt;&lt;/ul&gt;
    &lt;p&gt;
    &lt;/p&gt;&lt;p&gt;In one sense, the answer to both questions is the same --
      because of the consensus created by Knuth's 1965 paper
      &quot;On the translation of languages from left to right&quot;.
      In
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html&quot;&gt;a previous post&lt;/a&gt;,
      I looked at Knuth 1965
      and I answered the practitioner question in detail.
      But, for the sake of brevity,
      I answered the question about the theoreticians in outline.
      This post expands on that outline.
    &lt;/p&gt;
    &lt;h2&gt;The Practitioners&lt;/h2&gt;
    &lt;p&gt;
      To summarize, in 1965,
      &lt;b&gt;practitioners&lt;/b&gt;
      accepted the parsing problem as solved
      for the following reasons.
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;In 1965, every practical parser was stack-driven.&lt;/li&gt;
      &lt;li&gt;As of 1965, stacks themselves were quite leading edge.
        As recently as 1961,
        a leading edge article&lt;a id=&quot;footnote-3-ref&quot; href=&quot;#footnote-3&quot;&gt;[3]&lt;/a&gt;
        could not assume that its readers knew what &quot;pop&quot; and &quot;push&quot; operations
        were.
      &lt;/li&gt;
      &lt;li&gt;An algorithm that combined state transitions and stack operations was
        already a challenge to existing machines.
        In 1965, any more complicated algorithm was likely to be unuseable
        in practice.
      &lt;/li&gt;
      &lt;li&gt;Last, but not least, the theoreticians assured the
        practitioners that
        &lt;tt&gt;LR&lt;/tt&gt;-parsing was either state-of-the-art
        or beyond,
        so making more agressive use of hardware
        would be futile.
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;What about the theorists?&lt;/h2&gt;
    &lt;p&gt;The practitioners of 1965, then,
      were quite reasonable in feeling that
      &lt;tt&gt;LR&lt;/tt&gt;-parsing was as good as anything they were likely to be able
      to implement any time soon.
      And they were being told by the theorists that,
      in fact,
      it never would get any better --
      there were theoretical limits on parsers that faster
      hardware could not overcome.
    &lt;/p&gt;
    &lt;p&gt;We now know that the theorists were wrong --
      there are non-&lt;tt&gt;LR&lt;/tt&gt;
      parsers which are better than the
      &lt;tt&gt;LR&lt;/tt&gt;
      parsers are at
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars.
      What made the theorists go astray?
    &lt;/p&gt;
    &lt;h2&gt;How theorists work&lt;/h2&gt;
    &lt;p&gt;As the epigraph for this post reminds us,
      theorists who hope to guide practitioners have to confront a big problem --
      theory is practice only in theory.
      Theoreticians
      (or at least the better ones, like Knuth)
      know this,
      but they try to make theory as reliable a guide to
      practice as possible.
    &lt;/p&gt;
    &lt;p&gt;One of the most important examples of the theoretician's successes
      is asymptotic notation, which we owe to Knuth&lt;a id=&quot;footnote-4-ref&quot; href=&quot;#footnote-4&quot;&gt;[4]&lt;/a&gt;.
      Asymptotic notation is
      more commonly referred to as big-O notation.
      The term &quot;asymptotic notation&quot;
      emphasizes its most dangerous aspect
      from a practical point of view:
      Asymptotic notation assumes
      that the behavior of most interest
      is the behavior for arbitrarily large inputs.
    &lt;/p&gt;
    &lt;p&gt;
      Practical inputs can be very large but,
      by definition,
      they are never arbitrarily large.
      Results in asymptotic terms
      might be what is called &quot;galactic&quot; --
      they might have
      relevance only in situations which cannot possibly occur in practice.
    &lt;/p&gt;
    &lt;p&gt;
      Fortunately for computer science,
      asymptotic results usually are
      not &quot;galactic&quot;.
      Most often asymptotic results are not only
      relevant to practice --
      they are extremely relevant.
      Wikipedia pages for algorithms put
      the asymptotic complexities in special displays,
      and these displays are one of the first
      things that some practitioners look at.
    &lt;/p&gt;
    &lt;h2&gt;Bracketing&lt;/h2&gt;
    &lt;p&gt;Since coming up with a theoretical model that is equivalent
      to &quot;practical&quot; is impossible,
      theoreticians often work like artillerists.
      Artillerists often deliberately overshoot and undershoot,
      before they &quot;fire for effect&quot;.
      &quot;Bracketing&quot; their target in this way has disadvantages --
      it reduces the element of surprise,
      and can even allow the enemy to get their counter-fire in first.
      But, nasty as these consequences could be,
      the advantage in accuracy is usually held to outweigh them.
    &lt;/p&gt;
    &lt;p&gt;The practice of theoretical computer science is
      less risky,
      which makes &quot;bracketing&quot; a very attractive approach to
      tricky problems.
      Theoreticians often
      try to &quot;bracket&quot; practice between an &quot;undershoot&quot;
      and an &quot;overshoot&quot;.
      The undershoots are models simple and efficient enough to be practical,
      but too weak to capture all the needs of practice.
      The overshoots are models which capture everything
      a practitioner needs,
      but which are too complicated and/or too resource-intensive
      for practice.
    &lt;/p&gt;&lt;p&gt;The P vs. NP problem is an active example of a bracketing technique.
      You will sometimes read that
      the P/NP boundary is expected to be
      that between practical and impractical,
      but this is an extreme simplification.
      P includes complexities like
      &lt;tt&gt;O(n^1000000)&lt;/tt&gt;,
      where the complexity for even
      &lt;tt&gt;n == 2&lt;/tt&gt;
      is
      a nunber which, in decimal form,
      fills many pages.
      Modulo bold advances in quantum computing,
      I cannot imagine that
      &lt;tt&gt;O(n^1000000)&lt;/tt&gt;
      will ever be
      practical.
      And you can make the complexities much harder
      than
      &lt;tt&gt;O(n^1000000)&lt;/tt&gt;
      without ever reaching P-hard.
    &lt;/p&gt;
    &lt;p&gt;
      So P-hard is beyond any reasonable definition of &quot;practical&quot; --
      it is an &quot;overshoot&quot;.
      But the P vs. NP question is almost certainly very relevant to what is &quot;practical&quot;.
      Resolving the P vs. NP question is likely
      to be an important or even necessary step.
      It is a mystery that such a seemingly obvious
      question has resisted the best efforts of the theoreticians
      for so long,
      and the solution of P vs. NP is likely
      to bring
      new insights
      into asymptotic complexity.
    &lt;/p&gt;
    &lt;h2&gt;Bracketing practical parsing&lt;/h2&gt;
    &lt;p&gt;When Knuth published his 1965,
      &quot;practical parsing&quot; was already bracketed.
      On the overshoot side, Irons had already published a parser for
      context-free grammars.
      Worst case, this ran in exponential time,
      and it was, and remains, expected that general context-free parsing
      was not going to be practical.&lt;a id=&quot;footnote-5-ref&quot; href=&quot;#footnote-5&quot;&gt;[5]&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;On the undershoot side,
      there were regular expressions and recursive descent.
      Regular expressions are fast and very practical,
      but parse a very limited set of grammars.
      Recursive descent is also fast and,
      since it parses a larger set of grammars,
      was the closest undershoot.
    &lt;/p&gt;
    &lt;h2&gt;Mistake 1: The misdefinition of &quot;language&quot;&lt;/h2&gt;
    &lt;p&gt;To curry respect from the behaviourists,
      American linguistics for many years banned any reference
      to meaning.
      Behaviorists looked down on
      hypothesized mental states as not worthy of &quot;science&quot;,
      and it's hard to have a theory of meaning
      without conjectures about mental states.
      Without mental states,
      language was just a set utterances.
      So in 1926 the linguist Leonard Bloomfield
      dutifully
      defined a &quot;language&quot; as a set of &quot;utterances&quot;
      (for our purposes, &quot;strings&quot;),
      and through the 30s and 40s most American
      linguists followed him.
    &lt;/p&gt;
    &lt;p&gt;After a brief nod to this tradition,
      Noam Chomsky restored sanity to linguistics.
      But it was too late for computer science.
      Automata theory adopted the semantics-free definition.
      In 1965, Knuth inherited a lot of prior work,
      almost all of which ignored,
      not just meaning or semantics,
      but even syntax and structure.&lt;a id=&quot;footnote-6-ref&quot; href=&quot;#footnote-6&quot;&gt;[6]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;Language extension versus language intension&lt;/h2&gt;
    &lt;p&gt;Knuth, of course, wanted to make contact with prior art.
      The definition he had inherited seemed to work well enough
      and Knuth's 1965 defines a language as a set of strings.
      Most subsequent work has refused to breach this tradition.
    &lt;/p&gt;
    &lt;p&gt;In most people's idea of what a language is,
      the utterances/strings mean something --
      you cannot take just
      any set of meaningless strings and call it a language.
      So the parsing theorists and everybody else had
      two different definitions of language.
    &lt;/p&gt;
    &lt;p&gt;But parsing theory also hoped to produce results relevant
      to practice,
      and few people are interested in recognizing meaningless strings --
      almost everybody who parses is interested in (at a minimum)
      finding some kind of structure in what they parse,
      in order to do something with the result of the parse.
      Parsing theorists ended up using the word &quot;language&quot; in one
      sense, but implying that results they found worked
      for the word &quot;language&quot; in the usual sense.
    &lt;/p&gt;
    &lt;p&gt;
      At this point both senses of the word &quot;language&quot;
      have gotten entrenched in parsing theory.
      Instead of making up a new terminology for this blog post,
      I will borrow a distinction from linguistics
      and speak of
      &lt;b&gt;the extension of a language&lt;/b&gt;
      and
      &lt;b&gt;the intension of a language&lt;/b&gt;.
      The extension of a language is the Bloomfieldian defintion --
      the set of utterances/strings in the language.
      The intension of a language, for our purposes here,
      can be regarded as its BNF grammar.
      Each language intension will have (if it is well-defined)
      exactly one extension.
      But multiple language intensions can have the same extension.
    &lt;/p&gt;
    &lt;h2&gt;Red Herring 1: The stack machine model as a natural boundary&lt;/h2&gt;
    &lt;p&gt;The temptation to use language extensions as
      a proxy for
      &lt;tt&gt;LR&lt;/tt&gt;-grammars must have been overwhelming.
      It turns out that the language extension of
      deterministic stack machines
      is
      &lt;b&gt;exactly&lt;/b&gt;
      that of the
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars.
      Further,
      the language extension of the context-free grammars is
      exactly that of the non-deterministic stack machines.
      (Non-deterministic stack machines are
      stack machines which can &quot;fork&quot; new instances of themselves on the fly.)
    &lt;/p&gt;
    &lt;p&gt;
      If you take language extensions as the proxy for grammars,
      things fall into place very neatly:
      the
      &lt;tt&gt;LR&lt;/tt&gt;-parsers are the deterministic subset of the
      context-free parsers.
      And &quot;deterministic&quot; seemed like a very good approximation
      of practical.
      Certainly non-deterministic parsing is probably not practical.
      And the best practical parsers in 1965 were
      deterministic stack parsers.
    &lt;/p&gt;&lt;p&gt;
      Viewed this way,
      &lt;tt&gt;LR&lt;/tt&gt;-parsing looked like the equivalent
      of practical parsing.
      It was a &quot;direct hit&quot;,
      or as close to a exact equivalent of practical parsing
      as theory was going to get.
    &lt;/p&gt;
    &lt;p&gt;As we shall see,
      with this red herring,
      the reasoning went astray.
      But disaster was not inevitable.
      The whole point of bracketing, after all,
      is that it allows you to correct errors.
      Another red herring, however, resulted in
      parsing theory going on a decades-long
      wrong turn.
    &lt;/p&gt;
    &lt;h2&gt;Red Herring 2:
      &lt;tt&gt;LR&lt;/tt&gt;
      parsers are not good at
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars&lt;/h2&gt;
    &lt;p&gt;The second red herring led to the mis-bracketing of practical
      parsing.
      Having seemingly established that
      &lt;tt&gt;LR&lt;/tt&gt;-parsing is a natural boundary
      in the hierarchy of languages,
      Knuth discovered that general
      &lt;tt&gt;LR&lt;/tt&gt;-parsers were very far from practical.
      &lt;tt&gt;LR&lt;/tt&gt;
      parsing goes out to
      &lt;tt&gt;LR(k)&lt;/tt&gt;
      for arbitrary
      &lt;tt&gt;k&lt;/tt&gt;,
      but even
      &lt;tt&gt;LR(1)&lt;/tt&gt;
      parsing was impractical in 1965 --
      in fact, it is rare in practical use today.
      As the
      &lt;tt&gt;k&lt;/tt&gt;
      in
      &lt;tt&gt;LR(k)&lt;/tt&gt;
      grows, the size of the tables grows exponentially,
      while the value of the additional lookahead rapidly diminishes.
      It is not likely that
      &lt;tt&gt;LR(2)&lt;/tt&gt;
      parsing will ever see much practical use,
      never mind
      &lt;tt&gt;LR(k) : k &amp;gt; 2&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      From this it was concluded that
      &lt;tt&gt;LR&lt;/tt&gt;-parsing is an overshoot.
      In reality,
      as Joop Leo was to show,
      it is an
      &lt;b&gt;undershoot&lt;/b&gt;,
      and in practical terms a very large one.
      If you mistake an undershoot for an overshoot,
      bracketing no longer works,
      and you are not likely to hit your target.
    &lt;/p&gt;
    &lt;h2&gt;The Wrong Turn&lt;/h2&gt;
    &lt;p&gt;
      From all this,
      parsing theorists concluded that
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;LR-parsing is a good approximation to practical parsing -- it brackets
        it closely.&lt;/li&gt;
      &lt;li&gt;LR-parsing is an overshoot.&lt;/li&gt;
      &lt;li&gt;A subset of
        &lt;tt&gt;LR&lt;/tt&gt;-parsing will be the solution to the parsing problem.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;Signs of trouble ignored&lt;/h2&gt;
    &lt;p&gt;There were, in hindsight, clear signs
      that
      &lt;tt&gt;LR&lt;/tt&gt;
      language extensions were not a good proxy for
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars.
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars form a hierarchy --
      for every
      &lt;tt&gt;k&lt;/tt&gt;, there is an
      &lt;tt&gt;LR&lt;/tt&gt;
      grammar which
      is
      &lt;tt&gt;LR(k)&lt;/tt&gt;, but which is not
      &lt;tt&gt;LR(k+1)&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      But if you look at extensions
      instead of grammars,
      the hierarchy immediately
      collapses --
      every
      &lt;tt&gt;LR(k)&lt;/tt&gt;
      language extension is also
      an
      &lt;tt&gt;LR(1)&lt;/tt&gt;
      language extension,
      as long as
      &lt;tt&gt;k&amp;#8805;1&lt;/tt&gt;.
      Only
      &lt;tt&gt;LR(0)&lt;/tt&gt;
      remains distinct.
    &lt;/p&gt;
    &lt;p&gt;It gets worse.
      In most practical applications,
      you can add an end-of-input marker to a grammar.
      If you do this the
      &lt;tt&gt;LR&lt;/tt&gt;
      extension hierarchy collapses totally --
      every
      &lt;tt&gt;LR(k)&lt;/tt&gt;
      language extension is also an
      &lt;tt&gt;LR(0)&lt;/tt&gt;
      language extension.
    &lt;/p&gt;
    &lt;p&gt;In short, it seems that,
      as a proxy for
      &lt;tt&gt;LR&lt;/tt&gt;
      grammars,
      &lt;tt&gt;LR&lt;/tt&gt;
      language extensions are likely to be completely worthless.
    &lt;/p&gt;
    &lt;h2&gt;Why didn't Knuth see the problem?&lt;/h2&gt;
    &lt;p&gt;Why didn't Knuth see the problem?
      Knuth certainly noted the strange behavior of the
      &lt;tt&gt;LR&lt;/tt&gt;
      hierarchy
      in extensional terms -- he discovered it,
      and devoted several dense pages of his 1965 to laying
      out the complicated mathematics involved.
    &lt;/p&gt;
    &lt;p&gt;
      Why did
      Knuth expect to get away with punning
      intension and extension,
      even in the face of some very unsettling results?
      Here, the answer is very simple --
      &quot;punning&quot; had always worked before.
    &lt;/p&gt;
    &lt;p&gt;
      Regular expressions are easily turned into parsers&lt;a id=&quot;footnote-7-ref&quot; href=&quot;#footnote-7&quot;&gt;[7]&lt;/a&gt;,
      so the language extension of a regular grammar is an adequate approximation
      to its intension.
      Context-free recognition has the same complexity,
      and in practice uses the same algorithms,
      as context-free parsing,
      so here again,
      language extension is a good approximation
      of language intension.
    &lt;/p&gt;
    &lt;p&gt;
      And the
      &lt;tt&gt;LL&lt;/tt&gt;
      languages follow a strict hierarchy --
      for every
      &lt;tt&gt;k&lt;/tt&gt;,
      &lt;tt&gt;LL(k)&lt;/tt&gt;
      is a proper subset of
      &lt;tt&gt;LL(k+1)&lt;/tt&gt;.
      This fact forces
      &lt;tt&gt;LL&lt;/tt&gt;
      grammars to follow the same
      hierarchy&lt;a id=&quot;footnote-8-ref&quot; href=&quot;#footnote-8&quot;&gt;[8]&lt;/a&gt;.
      So, when studying complexity,
      &lt;tt&gt;LL&lt;/tt&gt;
      language extensions are an excellent proxy for
      &lt;tt&gt;LL&lt;/tt&gt;
      grammars.
    &lt;/p&gt;
    &lt;p&gt;
      Based on past experience,
      Knuth had reason to believe
      he could use language extensions as a proxy
      for grammars,
      and that the result would be
      a theory that was a reliable
      guide to practice.
    &lt;/p&gt;
    &lt;h2&gt;Aftermath&lt;/h2&gt;
    &lt;p&gt;In
      &lt;a href=&quot;https://jeffreykegler.github.io/personal/timeline_v3&quot;&gt;
        my timeline of parsing&lt;/a&gt;,
      I describe what happened next.
      Briefly,
      theory focused on finding a useful subset of
      &lt;tt&gt;LR(1)&lt;/tt&gt;.
      One,
      &lt;tt&gt;LALR&lt;/tt&gt;, became the favorite and
      the basis of the
      &lt;tt&gt;yacc&lt;/tt&gt;
      and
      &lt;tt&gt;bison&lt;/tt&gt;
      tools.
    &lt;/p&gt;
    &lt;p&gt;
      Research into parsing of supersets of
      &lt;tt&gt;LR&lt;/tt&gt;
      became rare.
      The theorists were convinced the
      &lt;tt&gt;LR&lt;/tt&gt;
      parsing
      was the solution.
      These were so convinced that when,
      in 1991, Joop Leo discovered a practical way to
      parse an
      &lt;tt&gt;LR&lt;/tt&gt; superset,
      the result went unimplemented for decades.
    &lt;/p&gt;
    &lt;p&gt;In 1965, the theoreticians gave a lot of weight
      to the evidence from the world of practice,
      but probably not undue weight.
      Going forward, it was a different story.
    &lt;/p&gt;
    &lt;p&gt;
      Leo had,
      in essence,
      disproved the implied conjecture of Knuth 1965.
      But the question is
      not an explicit mathematical question,
      like that of P vs. NP.
      It is a slipprier one -- capturing practice.
      Practitioners left it to the theoreticians to keep up with
      the literature.
      But theoreticians, as long as
      &lt;tt&gt;LR&lt;/tt&gt;-superset methods did not
      come into use in the world of practice,
      felt no need to revisit their conclusions.
    &lt;/p&gt;
    &lt;h2&gt;Comments, etc.&lt;/h2&gt;
    &lt;p&gt;
      I encourage
      those who want to know more about the story of Parsing Theory
      to look at my
      &lt;a href=&quot;https://jeffreykegler.github.io/personal/timeline_v3&quot;&gt;
        Parsing: a timeline 3.0&lt;/a&gt;.
      In particular,
      &quot;Timeline 3.0&quot; tells the story of the search for a good
      &lt;tt&gt;LR(k)&lt;/tt&gt;
      subclass,
      and what happened afterwards.
    &lt;/p&gt;
    &lt;p&gt;
      To learn about Marpa,
      my Earley/Leo-based parsing project,
      there is the
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;semi-official web site, maintained by Ron Savage&lt;/a&gt;.
      The official, but more limited, Marpa website
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;is my personal one&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel:
      &lt;tt&gt;#marpa&lt;/tt&gt; at &lt;tt&gt;freenode.net&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;p id=&quot;footnote-1&quot;&gt;1.
        Attributed to Jan L. A. van de Snepscheut and Yogi Berra.
        See
        &lt;a href=&quot;https://en.wikiquote.org/wiki/Jan_L._A._van_de_Snepscheut&quot;&gt;
          https://en.wikiquote.org/wiki/Jan_L._A._van_de_Snepscheut&lt;/a&gt;,
        accessed 1 July 2018.
        I quote my preferred form  of this --
        the one it takes in
        Doug Rosenberg and Matt Stephens,
        &lt;cite&gt;Use Case Driven Object Modeling with UML: Theory and Practice&lt;/cite&gt;,
        2007,
        p. xxvii.
        Rosenberg and Stephens is also the accepted authority for its attribution.
 &lt;a href=&quot;#footnote-1-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-2&quot;&gt;2.
        As an aside, I am open to the idea that
        the human mind has abilities that Turing machines cannot improve on
        or even duplicate.
        When it comes to
        survival heuristics tied to the needs of human bodies, for example,
        it seems very reasonable to at least entertain the conjecture
        that the human mind might be near-optimal,
        particularly in big-O terms.
        But when it comes to ability to solve problems which can be formalized
        as &quot;puzzles&quot; -- and syntactic analysis is one of these --
        I think that resort to human exceptionalism
        is a sign of desperation.
 &lt;a href=&quot;#footnote-2-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-3&quot;&gt;3.
          Oettinger, Anthony. &quot;Automatic Syntactic Analysis and the Pushdown
          Store&quot;,
          &lt;cite&gt;Proceedings of Symposia in Applied Mathematics&lt;/cite&gt;,
          Volume 12,
          American Mathematical Society, 1961.
          Oettinger describes &quot;push&quot; and &quot;pop&quot;
          stack operations in &quot;Iversion notation&quot; -- what
          later became APL.
          See the discussion of Oettinger in
          my
          &lt;a href=&quot;
    &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html&quot;&gt;
            &quot;Why is parsing considered solved?&quot; post&lt;/a&gt;.
 &lt;a href=&quot;#footnote-3-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-4&quot;&gt;4.
        Knuth did not invent asymptotic notation --
        it comes from calculus --
        but he introduced it to computer science
        and motivated its use.
 &lt;a href=&quot;#footnote-4-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-5&quot;&gt;5.
        The best lower bound for context-free parsing is still
        &lt;tt&gt;O(n)&lt;/tt&gt;.
        So it is even possible that there is a practical
        linear-time general context-free
        parser.
        But its discovery would be a big surprise.
 &lt;a href=&quot;#footnote-5-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-6&quot;&gt;6.
        In
        &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/chomsky_1956.html&quot;&gt;
          another blog post&lt;/a&gt;,
        I talk about the use of the word
        &quot;language&quot; in parsing theory
        in much more detail.
 &lt;a href=&quot;#footnote-6-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-7&quot;&gt;7.
        For example,
        regular expressions can be extended with &quot;captures&quot;.
        Captures cannot handle recursion, but neither can regular expressions,
        so captures are usually sufficient to provide all the structure
        an application wants.
 &lt;a href=&quot;#footnote-7-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-8&quot;&gt;8.
        The discussion of the
        &lt;tt&gt;LL(k)&lt;/tt&gt;
        hierarchy is in a sense anachronistic --
        the
        &lt;tt&gt;LL(k)&lt;/tt&gt;
        hierachy was not studied until after 1965.
        But Knuth certainly was aware of recursive descent,
        and it seems reasonable to suppose that,
        even in 1965,
        he had a sense of what
        the
        &lt;tt&gt;LL&lt;/tt&gt;
        hierarchy would look like.
 &lt;a href=&quot;#footnote-8-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Parsing left recursions</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/lrecursion.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body style=&quot;max-width:850px&quot;&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;h2&gt;Left recursion&lt;/h2&gt;
    &lt;p&gt;A lot has been written about parsing left recursion.
    Unfortunately, much of it simply adds to the mystery.
    In this post, I hope to frame the subject clearly and briefly.
    &lt;p&gt;
    &lt;/p&gt;I expect the reader has some idea of what left recursion is,
    and perhaps some experience of it as an issue.
    Informally, left recursion occurs when a symbol expands to something
    with itself on the left.
    This can happen directly, for example, if
    production &lt;tt&gt;(1)&lt;/tt&gt; is in a grammar.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    (1) A ::= A B
    &lt;/tt&gt;&lt;/pre&gt;
    Indirect left recursion happens when,
    for example,
    &lt;tt&gt;(2)&lt;/tt&gt; and
    &lt;tt&gt;(3)&lt;/tt&gt;
    are productions in a grammar.
    &lt;pre&gt;&lt;tt&gt;
    (2) A ::= B C
    (3) B ::= A D
    &lt;/tt&gt;&lt;/pre&gt;
    A grammar with productions
    &lt;tt&gt;(4)&lt;/tt&gt; and
    &lt;tt&gt;(5)&lt;/tt&gt;
    has a &quot;hidden&quot; left recursion.
    &lt;pre&gt;&lt;tt&gt;
    (4) A ::= B A C
    (5) B ::= # empty
    &lt;/tt&gt;&lt;/pre&gt;
    This is because
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;
    ends up leftmost in derivations like:
    &lt;pre&gt;&lt;tt&gt;
    (6) A  &amp;#10230; B A C &amp;#10230 A C
    &lt;/tt&gt;&lt;/pre&gt;
    In derivation &lt;tt&gt;(6)&lt;/tt&gt;,
    production &lt;tt&gt;(4)&lt;/tt&gt; was applied,
    then production &lt;tt&gt;(5)&lt;/tt&gt;.
    &lt;p&gt;For those into notation,
    a grammar is left recursive if and only if it allows a derivation of the
    form
    &lt;pre&gt;&lt;tt&gt;
    (7) A  &amp;#10230;&lt;sup&gt;+&lt;/sup&gt; &amp;beta; A &amp;gamma; &lt;/tt&gt; where &lt;tt&gt; &amp;beta; = &amp;epsilon;
    &lt;/tt&gt;&lt;/pre&gt;
    In &lt;tt&gt;(7)&lt;/tt&gt; &lt;tt&gt;&amp;epsilon;&lt;/tt&gt; is the empty string,
    and 
    &lt;tt&gt; &amp;alpha; &amp;#10230;&lt;sup&gt;+&lt;/sup&gt; &amp;beta;&lt;/tt&gt;
    indicates that &lt;tt&gt;&amp;alpha;&lt;/tt&gt; derives &lt;tt&gt;&amp;beta;&lt;/tt&gt;
    in one or more rule applications.
    &lt;h2&gt;So, OK, what is the problem?&lt;/h2&gt;
    &lt;p&gt;The problem with parsing left recursions is that if you are parsing
    using a derivation like
    &lt;pre&gt;&lt;tt&gt;
    (8) A  &amp;#10230; A B &lt;/tt&gt;
    &lt;/tt&gt;&lt;/pre&gt;
    then you have defined
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;
    in terms of 
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;.
    All recursions can be a problem,
    but left recursions are a particular problem because almost all practical
    parsing methods&lt;a id=&quot;footnote-1-ref&quot; href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;
    proceed left to right,
    and derivations like &lt;tt&gt;(8)&lt;/tt&gt; will lead many of
    the most popular algorithms straight into
    an infinite regress.
    &lt;h2&gt;Why do some algorithms not have a problem?&lt;/h2&gt;
    &lt;p&gt;In a sense,
    all algorithms which solve the left recursion problem do
    it in the same way.
    It is just that in some,
    the solution appears in a much simpler form.
    &lt;/p&gt;
    &lt;p&gt;
    The solution is at most simple in Earley's algorithm.
    That is no coincidence -- as Pingali and Bilardi&lt;a id=&quot;footnote-2-ref&quot; href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;
    show,
    Earley's, despite its daunting reputation,
    is actually the most basic Chomskyan context-free parsing algorithm,
    the one from which all others derive.
    &lt;/p&gt;
    &lt;p&gt;Earley's builds a table.
    The Earley table contains an initial Earley set
    and an Earley set for each token.
    The Earley set for each token
    describes the state of the parse after consuming that token.
    The basic idea is not dissimilar
    to that of the Might/Darais/Spiewak (MDS) idea of parsing by derivatives,
    and the logic for building the Earley sets resembles
    that of MDS.&lt;a id=&quot;footnote-3-ref&quot; href=&quot;#footnote-3&quot;&gt;[3]&lt;/a&gt;
    &lt;p&gt;
    For the purpose of studying left recursion,
    what matters is that
    each Earley set contains Earley &quot;items&quot;.
    Some of the items are called predictions
    because they predict the occurrence of a symbol
    at that location in the input.
    &lt;/p&gt;
    To record a left recursion in an Earley set,
    the program adds
    a prediction item for the left recursive symbol.
    It is that simple.&lt;a id=&quot;footnote-4-ref&quot; href=&quot;#footnote-4&quot;&gt;[4]&lt;/a&gt;
    &lt;/p&gt;
    Multiple occurrences of a prediction item would be identical,
    and therefore useless.
    Therefore subsequent attempts
    to add the same prediction item are ignored,
    and recursion does not occur.
    &lt;/p&gt;
    &lt;h2&gt;If some have no problem, why do others?&lt;/h2&gt;
    &lt;p&gt;Besides Earley's,
    a number of other algorithms handle left recursion without
    any issue -- notably LALR 
    (aka &lt;tt&gt;yacc&lt;/tt&gt; or &lt;tt&gt;bison&lt;/tt&gt;) and LR.
    This re-raises the original question:
    why do some algorithms have a left recursion problem?
    &lt;/p&gt;
    &lt;p&gt;The worst afflicted algorithms are the &quot;top-down&quot;
    parsers.
    The best known of these is recursive descent --
    a parsing methodology which, essentially, does parsing
    by calling a subroutine to handle each symbol.
    In the traditional implementation of recursive descent,
    left recursion is very problematic.
    Suppose that, as part of a recursive descent implementation,
    you are writing the function to parse the
    symbol &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;,
    which you are calling
    &lt;tt&gt;parse_A()&lt;/tt&gt;.
    If your grammar has a rule
    &lt;pre&gt;&lt;tt&gt;
    (9) A ::= A B
    &lt;/tt&gt;&lt;/pre&gt;
    the first thing you need to do in a naive
    implementation of
    &lt;tt&gt;parse_A()&lt;/tt&gt;
    is to call &lt;tt&gt;parse_A()&lt;/tt&gt;.
    And &lt;tt&gt;parse_A()&lt;/tt&gt; will
    then call &lt;tt&gt;parse_A()&lt;/tt&gt;.
    And so, in the naive implementation, on and on forever.
    &lt;h2&gt;The fixed-point solution to left recursion&lt;/h2&gt;
    &lt;p&gt;Over the years,
    many ways to solve the top-down left recursion issue have been
    announced.
    The MDS solution is one of the more interesting --
    interesting because it actually works&lt;a id=&quot;footnote-5-ref&quot; href=&quot;#footnote-5&quot;&gt;[5]&lt;/a&gt;,
    and because it describes all the others,
    including the Earley algorithm solution.
    MDS reduces the problem to
    the more general one of finding a &quot;fixed point&quot; of the recursion.
    &lt;/p&gt;
    &lt;p&gt;In math, the &quot;fixed point&quot; of a function is an argument of
    the function which is equal to its value for that argument --
    that is, an &lt;tt&gt;x&lt;/tt&gt; such that &lt;tt&gt;f(x)&amp;nbsp;=&amp;nbsp;x&lt;/tt&gt;.
    MDS describes an algorithm which &quot;solves&quot; the left recursion
    for its fixed point.
    That &quot;fixed point&quot; can then be memoized.
    For example the value of &lt;tt&gt;parse_A&lt;/tt&gt;
    can be the memoized &quot;fixed point&quot; value of
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;p&gt;The Earley solution of left recursion was, in fact, an optimized
    &quot;fixed point&quot;.
    The computation of an Earley is the application of a set
    of rules for adding Earley items.
    This continues until no more Earley items can be added.
    In other words, the rules for building an Earley set
    are applied until they find
    their &quot;fixed point&quot;.&lt;a id=&quot;footnote-6-ref&quot; href=&quot;#footnote-6&quot;&gt;[6]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;Other top-down solutions&lt;/h2&gt;
    &lt;p&gt;The MDS fixed point solution &lt;b&gt;does&lt;/b&gt;
    the job,
    but as described in their paper it requires a functional
    programming language to implement,
    and it is expensive.
    In the worst case, the MDS approach is exponential,
    although they conjecture that it is linear for a large
    class of practical grammars.
    &lt;/p&gt;
    &lt;p&gt;Top-down algorithms can take an &quot;in-between strategy&quot; --
    they can tackle those left recursions that are cheap to
    find, without computing the full &quot;fixed point&quot;.
    Here a well-defined boundary is crucial:
    A programmer wants to know if their particular grammar will
    work,
    and whether small tweaks to their grammar will break it.
    &lt;/p&gt;
    &lt;p&gt;
    Top-down can be seen as
    &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2015/12/topdown.html&quot;&gt;
    a &quot;guessing&quot; strategy with hacks&lt;/a&gt;.
    Hacks are always needed in top-down, because the input is at the bottom,
    not the top, and a useful top-down algorithm needs to look at the input.
    But the hacks can be as simple as lookahead,
    and lookahead can be implemented without seriously compromising
    the simplicity and flexibility of the original top-down approach.
    &lt;/p&gt;
    &lt;p&gt;With detection and fixing of left-recursion,
    the &quot;hack&quot; part of the top-down strategy becomes very complicated.
    The attraction of top-down is its simplicity,
    and its resulting adapability to procedural logic.
    The point can be reached where the original strategy
    comes into question.
    &lt;/p&gt;
    &lt;p&gt;
    After all,
    a recursive descent parser can straightforwardly take care of left recursion
    issues by calling an Earley parser.
    But in that case,
    why not simply use Earley's?
    &lt;/p&gt;
    &lt;h2&gt;Comments, etc.&lt;/h2&gt;
      Marpa is my own implementation of an Earley parser.&lt;a id=&quot;footnote-7-ref&quot; href=&quot;#footnote-7&quot;&gt;[7]&lt;/a&gt;
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on its IRC channel: #marpa at freenode.net.
    &lt;/p&gt;
    &lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;p id=&quot;footnote-1&quot;&gt;&lt;b&gt;1.&lt;/b&gt;
    I probably could have said &quot;all practical parsing methods&quot;
    instead of &quot;almost all&quot;.
    Right-to-left parsing methods exist,
    but they see little use.
    In any case, they only reverse the problem.
    Parsing in both directions is certainly possible but,
    as I will show,
    we do not have to go to quite that much trouble.
 &lt;a href=&quot;#footnote-1-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-2&quot;&gt;&lt;b&gt;2.&lt;/b&gt;
        Keshav Pingali and Gianfranco Bilardi, UTCS tech report TR-2012.
        2012.
        &lt;a href=&quot;https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2102.pdf&quot;&gt;
          PDF accessed 9 Junk 2018&lt;/a&gt;.
        &lt;a href=&quot;https://www.youtube.com/watch?v=eeZ3URxd8Wc&quot;&gt;
          Video accessed 9 June 2018&lt;/a&gt;.
        Less accessible is
        Keshav Pingali and Gianfranco Bilardi,
        &quot;A graphical model for context-free grammar parsing.&quot;
        Compiler Construction - 24th International Conference, CC 2015.
        Lecture Notes in Computer Science,
        Vol. 9031, pp. 3-27, Springer Verlag, 2015.
        &lt;a href=&quot;https://www.researchgate.net/publication/286479583_A_Graphical_Model_for_Context-Free_Grammar_Parsing&quot;&gt;
          PDF accessed 9 June 2018&lt;/a&gt;.
 &lt;a href=&quot;#footnote-2-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-3&quot;&gt;&lt;b&gt;3.&lt;/b&gt;
        Matthew Might, David Darais and Daniel Spiewak.
	&quot;Functional Pearl: Parsing with Derivatives.&quot;
	International Conference on Functional Programming 2011 (ICFP 2011).
	Tokyo, Japan. September, 2011. pages 189-195.
        &lt;a href=&quot;http://matt.might.net/papers/might2011derivatives.pdf&quot;&gt;
          PDF accessed 9 Jun 2018&lt;/a&gt;.
        &lt;a href=&quot;http://matt.might.net/papers/might2011derivatives-icfp-talk.pdf&quot;&gt;
          Slides accessed 9 June 2018&lt;/a&gt;.
        &lt;a href=&quot;http://matt.might.net/media/mattmight-icfp2011-derivatives.mp4&quot;&gt;
          Video accessed 9 June 2018&lt;/a&gt;.
 &lt;a href=&quot;#footnote-3-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-4&quot;&gt;&lt;b&gt;4.&lt;/b&gt;
    Those familiar with Earley's algorithm may note that
    Earley items are traditionally in terms of productions,
    not symbols.
    Symbol predictions are therefore recorded indirectly.
    &lt;br&gt;&lt;br&gt;
    Specifically, Earley items are traditionally duples
    of &lt;tt&gt;(dr, origin)&lt;/tt&gt;,
    where &lt;tt&gt;dr&lt;/tt&gt; is a dotted production -- a production
    with a &quot;dot location&quot; marked;
    and &lt;tt&gt;origin&lt;/tt&gt; is a location in the input.
    In all predictions &lt;tt&gt;origin&lt;/tt&gt; is the current location,
    and the dot location is at the start of the production,
    so there can be at most one prediction per rule.
    A prediction of a symbol 
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt;
    is recorded as a prediction of every
    production which has 
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt; on its LHS.
    &lt;br&gt;&lt;br&gt;
    The argument in the main text is made the way it is
    because it is simpler to speak
    of &quot;predicted symbols&quot; than
    to repeatedly refer to &quot;sets of predictions
    of productions sharing a common LHS&quot;.
 &lt;a href=&quot;#footnote-4-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-5&quot;&gt;&lt;b&gt;5.&lt;/b&gt;
    There have been many more attempts than implementations
    over the years,
    and even some of the most-widely used
    implementations &lt;a href=&quot;https://www.youtube.com/watch?v=lFBEf0o-4sY&amp;feature=youtu.be&amp;t=6m29s&quot;&gt;
    have
    their issues.&lt;/a&gt;
 &lt;a href=&quot;#footnote-5-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-6&quot;&gt;&lt;b&gt;6.&lt;/b&gt;
    Recall that potential left recursions are 
    recorded as &quot;predictions&quot; in Earley's algorithm.
    Predictions recurse,
    but since they do not depend on the input,
    they can be precomputed.
    This means that Earley implementations can
    bring each Earley set to its fixed point
    very quickly.
 &lt;a href=&quot;#footnote-6-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-7&quot;&gt;&lt;b&gt;7.&lt;/b&gt;
        Marpa has a stable implementation.
        For it, and for more information on Marpa, there are these resources:&lt;br&gt;
        &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;
          Marpa website, accessed 25 April 2018&lt;/a&gt;.&lt;/br&gt;
        &lt;a href=&quot;https://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;
          Kegler's website, accessed 25 April 2018&lt;/a&gt;.&lt;/br&gt;
        &lt;a href=&quot;https://github.com/jeffreykegler/Marpa--R2&quot;&gt;
          Github repo, accessed 25 April 2018.&lt;/a&gt;&lt;/br&gt;
        &lt;a href=&quot;https://metacpan.org/pod/Marpa::R2&quot;&gt;
          MetaCPAN, accessed 30 April 2018.&lt;/a&gt;.&lt;/br&gt;
	  There is also a theory paper for Marpa:
        Kegler, Jeffrey.
        &quot;Marpa, A Practical General Parser: The Recognizer.&quot;, 2013.
        &lt;a href=&quot;http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/KEGLER,%20Jeffrey%20-%20Marpa,%20a%20practical%20general%20parser:%20the%20recognizer.pdf&quot;&gt;
          PDF accessed 24 April 2018&lt;/a&gt;.
 &lt;a href=&quot;#footnote-7-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Marpa and combinator parsing</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/combinator.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body style=&quot;max-width:850px&quot;&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;h2&gt;The missing part&lt;/h2&gt;
    &lt;p&gt;
    &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/csg.html&quot;&gt;
    A previous post&lt;/a&gt;
    described how to use the current stable Marpa
    implementation as a better procedural parser.
    This post describes how the Marpa algorithm can be used as the basis
    of better combinator parsers.
    &lt;/p&gt;
    &lt;p&gt;In the post on procedural parsing,
    the subparsers&lt;a id=&quot;footnote-1-ref&quot; href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;
    were like combinators,
    in that they could be called recursively,
    so that a parse could be built up from components.
    Like combinators,
    each child could return,
    not just a parse,
    but a set of parses.
    And, as in combinators, once a child combinator
    returned its value,
    the parent parser could resume parsing
    at a location specified by the child combinator.
    So what was missing?
    &lt;p&gt;A combinator,
    in order to handle ambiguity,
    returns not a subparse, but a set of subparses.
    In the full combinator model,
    each subparse can have its own &quot;resume location&quot;.&lt;a id=&quot;footnote-2-ref&quot; href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;
    The procedural parsing post did not provide for multiple
    resume locations.
    We will now proceed to make up for that.
    &lt;/p&gt;
    &lt;h2&gt;How it works&lt;/h2&gt;
    &lt;p&gt;The Marpa parser has the ability to accept
    multiple subparses,
    each with its own length.
    This allows child subparses to overlap in any fashion,
    forming a mosaic as complex as the application needs.
    &lt;/p&gt;
    &lt;/p&gt;An Earley parser is table-driven --
    its parse tables consists of Earley sets,
    with an initial Earley set
    and one Earley set per token.
    This makes for a very simple idea of location.
    Location 0 is the location of the initial Earley set.
    Location &lt;tt&gt;N&lt;/tt&gt; is the location of the Earley set after the &lt;tt&gt;N&lt;/tt&gt;'th
    token has been consumed.
    &lt;/p&gt;
    &lt;p&gt;Simplicity is great, but unfortunately
    this won't work for variable-length
    tokens.
    To handle those, Marpa introduces another idea of location:
    the &lt;b&gt;earleme&lt;/b&gt;.
    Like Earley set locations,
    the earlemes begin at 0,
    and advance in integer sequence.
    Earley set 0 is always at earleme 0.
    Every Earley set has an earleme location.
    On the other hand,
    not every earleme has a corresponding Earley set --
    there can be &quot;empty&quot; earlemes.
    &lt;/p&gt;
    &lt;p&gt;The lower-level interface for Marpa is Libmarpa.
    Every time Libmarpa adds a token,
    a length in earlemes must be specified.
    In the most-used higher level Marpa interfaces,
    this &quot;earleme length&quot; is always 1,
    which makes the Libmarpa location model collapse into the traditional one.
    &lt;/p&gt;
    &lt;p&gt;
    The Libmarpa recognizer advances earleme-by-earleme.
    In the most-used higher level Marpa interfaces,
    a token ends at every earleme
    (unless of course that earleme is after end-of-input).
    This means that the most-used Marpa interfaces
    create a new Earley set every time they advance one earleme.
    Again, in this case, the Libmarpa model collapses into
    the traditional one.
    &lt;/p&gt;
    &lt;p&gt;In Libmarpa and other lower-level interfaces,
    there may be cases where
    &lt;ul&gt;
    &lt;li&gt;one or more tokens
    end after the current earleme, but&lt;/li&gt;
    &lt;li&gt;no tokens end &lt;b&gt;at&lt;/b&gt; the current earleme.&lt;/li&gt;
    &lt;/ul&gt;
    In such cases the current earleme will be empty.
    &lt;/p&gt;
    &lt;p&gt;This is only an outline of the basic concepts behind the
    Marpa input model.
    The formalisms are in the Marpa theory paper.&lt;a id=&quot;footnote-3-ref&quot; href=&quot;#footnote-3&quot;&gt;[3]&lt;/a&gt;
    The documentation for Libmarpa and Marpa's other low-level interfaces contains
    more accessible,
    but detailed, descriptions.&lt;a id=&quot;footnote-4-ref&quot; href=&quot;#footnote-4&quot;&gt;[4]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;Value added&lt;/h2&gt;
    &lt;h3&gt;Left-eidetic information&lt;/h3&gt;
    &lt;p&gt;As readers of my previous posts&lt;a id=&quot;footnote-5-ref&quot; href=&quot;#footnote-5&quot;&gt;[5]&lt;/a&gt;
    will know,
    Marpa is &quot;left-eidetic&quot; -- the application has access to everything to its left.
    This is an advantage over the traditional implementation of combinator parsing,
    where parse information about the left context may be difficult
    or impossible to access.&lt;a id=&quot;footnote-6-ref&quot; href=&quot;#footnote-6&quot;&gt;[6]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h3&gt;More powerful linear-time combinators&lt;/h3&gt;
    &lt;p&gt;Marpa parses a superset of LR-regular grammars in linear time,
    which makes it a more powerful &quot;building block&quot;
    than traditionally available for combinator parsing.
    This gives the programmer of a combinator parser more options.
    &lt;/p&gt;
    &lt;h3&gt;State of the art worse-than-linear combinators&lt;/h3&gt;
    &lt;p&gt;In special circumstances, programmers may want to use subparsers 
    which are worse than linear -- for example, they may know that
    the string is very short.
    Marpa parses context-free grammars in state of the art time.&lt;a id=&quot;footnote-7-ref&quot; href=&quot;#footnote-7&quot;&gt;[7]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;The code, comments, etc.&lt;/h2&gt;
      To learn more about Marpa,
      a good first stop is the
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;semi-official web site, maintained by Ron Savage&lt;/a&gt;.
      The official, but more limited, Marpa website
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;is my personal one&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
    &lt;/p&gt;
    &lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;p id=&quot;footnote-1&quot;&gt;&lt;b&gt;1.&lt;/b&gt;
    In some of the descriptions of Marpa's procedural
    parsing, these subparsers are called &quot;lexers&quot;.
    This emphasizes the usual case in current practice,
    where the subparsers are the bottom layer of the
    parsing application,
    and do not invoke their own child subparsers.
 &lt;a href=&quot;#footnote-1-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-2&quot;&gt;&lt;b&gt;2.&lt;/b&gt;
    In notational terms, a full combinator is a function of the form
    &lt;br&gt;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
    &lt;tt&gt;A* &amp;#8594; &amp;#8473;( P &amp;#215; A* )&lt;/tt&gt;,
    &lt;br&gt;
    where &lt;tt&gt;A&lt;/tt&gt; is the alphabet of the grammar;
    &lt;tt&gt;P&lt;/tt&gt; is a representation of a single parser
    (for example, a parse tree);
    &lt;tt&gt;&amp;#8473;(X)&lt;/tt&gt; is the power set of a set &lt;tt&gt;X&lt;/tt&gt;:
    and
    &lt;tt&gt;X &amp;#215; Y&lt;/tt&gt; is the Cartesian product
    of sets &lt;tt&gt;X&lt;/tt&gt; and &lt;tt&gt;Y&lt;/tt&gt;.
    The subparsers
    of the procedural parsing post
    were of the form
    &lt;br&gt;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
    &lt;tt&gt;A* &amp;#8594; &amp;#8473;( P ) &amp;#215; A*&lt;/tt&gt;.
    &lt;br&gt;
 &lt;a href=&quot;#footnote-2-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-3&quot;&gt;&lt;b&gt;3.&lt;/b&gt;
    Kegler, Jeffrey.&lt;a
    href=&quot;http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/KEGLER,%20Jeffrey%20-%20Marpa,%20a%20practical%20general%20parser:%20the%20recognizer.pdf&quot;&gt;
    &quot;Marpa, a Practical General Parser: The Recognizer&quot;.&lt;/a&gt;
    2013.
    Section 12, &quot;The Marpa input model&quot;, pp. 39-40.
 &lt;a href=&quot;#footnote-3-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-4&quot;&gt;&lt;b&gt;4.&lt;/b&gt;
    Libmarpa API document,
    &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/libmarpa_api/stable/api_one_page.html#Input&quot;&gt;
    the &quot;Input&quot; section&lt;/a&gt;.
    Marpa::R2's NAIF interface allows
    access to the full Libmarpa input model
    and its documentation contains
    &lt;a href=&quot;https://metacpan.org/pod/distribution/Marpa-R2/pod/Advanced/Models.pod&quot;&gt;
    a higher-level description of Marpa's alternative input models.&lt;/a&gt;
    There is also a thin Perl interface to Libmarpa,
    &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/libmarpa_api/stable/api_one_page.html#Input&quot;&gt;the THIF interface&lt;/a&gt;,
    which allows full access to the alternative input models.
 &lt;a href=&quot;#footnote-4-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-5&quot;&gt;&lt;b&gt;5.&lt;/b&gt;
    For example, the
    &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/csg.html&quot;&gt;
    post on procedural parsing&lt;/a&gt; contains a good,
    simple, example of the use of Marpa's left-eideticism.
 &lt;a href=&quot;#footnote-5-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-6&quot;&gt;&lt;b&gt;6.&lt;/b&gt;
    For best effect,
    left-eidetism and functional purity
    probably should be used in combination.
    For the moment at least,
    I am focusing on explaining the capabilities,
    and leaving it to others to find the monadic
    or other solutions that will allow programmers to leverage
    this power in functionally pure ways.
 &lt;a href=&quot;#footnote-6-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-7&quot;&gt;&lt;b&gt;7.&lt;/b&gt;
    Specifically O(n^2) for unambiguous grammars,
    and O(n^3) for ambiguous grammars.
 &lt;a href=&quot;#footnote-7-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Marpa and procedural parsing</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/csg.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body style=&quot;max-width:850px&quot;&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;h2&gt;Procedural parsing&lt;/h2&gt;
    &lt;p&gt;Marpa is an Earley-based parser,
      and Earley parsers are typically not good at procedural parsing.
      Many programmers are used to recursive descent (RD),
      which has been state-of-the-art in terms of
      its procedural programming capabilities --
      it was these capabilities which led to
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/fast_power.html&quot;&gt;
      RD's
      triumph over the now-forgotten Irons algorithm.&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
      Marpa, however, has a parse engine expressly redesigned&lt;a id=&quot;footnote-1-ref&quot; href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;
      to handle procedural logic well.
      In fact, Marpa is &lt;b&gt;better&lt;/b&gt; at procedural logic
      than RD.
    &lt;/p&gt;
    &lt;h2&gt;A context-sensitive grammar&lt;/h2&gt;
    &lt;p&gt;Marpa parses all LR-regular grammars in linear time,
    so the first challenge is to find a grammar
    that illustrates a
    &lt;b&gt;need&lt;/b&gt; for procedural logic, even when Marpa is used.
    The following is the canonical example of a grammar that is
    context-sensitive, but not context-free:
    &lt;/p&gt;
    &lt;pre&gt;
          a^n . b^n . c^n : n &gt;= 1
    &lt;/pre&gt;
    I will call this the &quot;ABC grammar&quot;.
    It is a sequence of
    &lt;tt&gt;a&lt;/tt&gt;'s,
    &lt;tt&gt;b&lt;/tt&gt;'s, and
    &lt;tt&gt;c&lt;/tt&gt;'s,
    in alphabetical order,
    where the character counts are all
    equal to each other and greater
    than zero.
    &lt;/p&gt;
    &lt;p&gt;The ABC &quot;grammar&quot; is really a counting problem more than
    a natural parsing problem,
    and parsing is not the fastest or easiest way to solve it.
    Three tight loops, with counters, would do the same job nicely,
    and would be much faster.
    But I chose the ABC grammar for exactly this reason.
    It &lt;b&gt;is&lt;/b&gt; simple in itself,
    but it is tricky when treated as a parsing problem.&lt;a id=&quot;footnote-2-ref&quot; href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
    In picking the strategy below,
    I opted for one that illustrates
    a nice subset of Marpa's procedural parsing capabilities.
    Full code is
    &lt;a href=&quot;https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/csg&quot;&gt;
    on-line&lt;a&gt;,
    and readers are encouraged to &quot;peek ahead&quot;.
    &lt;/p&gt;
    &lt;h2&gt;Step 1: the syntax&lt;/h2&gt;
    &lt;p&gt;Our strategy will be to start with a context-free syntax,
    and then extend it with procedural logic.
    Here is the context-free grammar:
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    lexeme default = latm =&gt; 1
    :default ::= action =&gt; [name,start,length,values]
    S ::= prefix ABC trailer
    ABC ::= ABs Cs
    ABs ::= A ABs B | A B
    prefix ::= A*
    trailer ::= C_extra*
    A ~ 'a'
    B ~ 'b'
    :lexeme ~ Cs pause =&gt; before event =&gt; 'before C'
    Cs ~ 'c' # dummy -- procedural logic reads &lt;Cs&gt;
    C_extra ~ 'c'
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;The first line is boiler-plate:
    It turns off a default which was made pointless
    by a later enhancement to Marpa::R2.
    Marpa::R2 is stable, and backward-compatibility is
    a very high priority.
    &lt;pre&gt;&lt;tt&gt;
    :default ::= action =&gt; [name,start,length,values]
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    We will produce a parse tree.
    The second line defines its format --
    each node is an array whose elements are,
    in order,
    the node name, its start position,
    its length and its child nodes.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    S ::= prefix ABC trailer
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;The symbol &lt;tt&gt;&amp;lt;ABC&amp;gt;&lt;/tt&gt;
    is our &quot;target&quot; -- the counted
    &lt;tt&gt;a&lt;/tt&gt;'s,
    &lt;tt&gt;b&lt;/tt&gt;'s,
    and &lt;tt&gt;c&lt;/tt&gt;'s.
    To make things a bit more interesting,
    and to make the problem more like a parsing problem instead of a counting problem,
    we allow a prefix of &lt;tt&gt;a&lt;/tt&gt;'s
    and a trailer of &lt;tt&gt;c&lt;/tt&gt;'s.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    ABC ::= ABs Cs
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;We divide the
    &lt;tt&gt;&amp;lt;ABC&amp;gt;&lt;/tt&gt; target into two parts:
    &lt;tt&gt;&amp;lt;ABs&amp;gt;&lt;/tt&gt;, which contains the
    &lt;tt&gt;a&lt;/tt&gt;'s,
    and &lt;tt&gt;b&lt;/tt&gt;'s;
    and
    &lt;tt&gt;&amp;lt;Cs&amp;gt;&lt;/tt&gt;, which contains
    the &lt;tt&gt;c&lt;/tt&gt;'s.
    &lt;/p&gt;
    &lt;p&gt;
    The string
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    a^n . b^n
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    is context free, so that we can handle it
    without procedural logic, as follows:
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    ABs ::= A ABs B | A B
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    The line above recognizes a non-empty string of
    &lt;tt&gt;a&lt;/tt&gt;'s,
    followed by an equal number
    of &lt;tt&gt;b&lt;/tt&gt;'s.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    prefix ::= A*
    trailer ::= C_extra*
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;As stated above,
    &lt;tt&gt;&amp;lt;prefix&amp;gt;&lt;/tt&gt;
    is a series of &lt;tt&gt;a&lt;/tt&gt;'s and
    &lt;tt&gt;&amp;lt;trailer&amp;gt;&lt;/tt&gt;
    is a series of &lt;tt&gt;c&lt;/tt&gt;'s.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    A ~ 'a'
    B ~ 'b'
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;Marpa::R2 has a separate lexical and syntactic phase.
    Here we define our lexemes.
    The first two are simple enough:
    &lt;tt&gt;&amp;lt;A&amp;gt;&lt;/tt&gt; is the character &quot;&lt;tt&gt;a&lt;/tt&gt;&quot;; and
    &lt;tt&gt;&amp;lt;B&amp;gt;&lt;/tt&gt; is the character &quot;&lt;tt&gt;b&lt;/tt&gt;&quot;.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    :lexeme ~ Cs pause =&gt; before event =&gt; 'before C'
    Cs ~ 'c' # dummy -- procedural logic reads &lt;Cs&gt;
    C_extra ~ 'c'
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    For the character &quot;&lt;tt&gt;c&lt;/tt&gt;&quot;,
    we need procedural logic.
    As hooks for procedural logic,
    Marpa allows a full range of events.
    Events can occur on prediction and completion of symbols;
    when symbols are nulled;
    before lexemes;
    and after lexemes.
    The first line in the above display
    declares a &quot;before lexeme&quot; event
    on the symbol
    &lt;tt&gt;&amp;lt;Cs&amp;gt;&lt;/tt&gt;.
    The name of the event is &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot;.
    &lt;/p&gt;
    &lt;p&gt;The second line is a dummy entry,
    which is needed to allow the &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot;
    event to trigger.
    The entry says that
    &lt;tt&gt;&amp;lt;Cs&amp;gt;&lt;/tt&gt; is a single character &quot;&lt;tt&gt;c&lt;/tt&gt;&quot;.
    This is false --
    &lt;tt&gt;&amp;lt;Cs&amp;gt;&lt;/tt&gt; is a series of one or more
    &lt;tt&gt;c&lt;/tt&gt;'s,
    which needs to be counted.
    But when
    the &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot; event triggers,
    the procedural
    logic will make things right.
    &lt;/p&gt;
    &lt;p&gt;The third line defines
    &lt;tt&gt;&amp;lt;C_extra&amp;gt;&lt;/tt&gt;, which
    is another lexeme for the character &quot;&lt;tt&gt;c&lt;/tt&gt;&quot;.
    We have two different lexemes for
    the character &lt;tt&gt;c&lt;/tt&gt;, because we want some
    &lt;tt&gt;c&lt;/tt&gt;'s (those in the target)
    to trigger events;
    and we want other
    &lt;tt&gt;c&lt;/tt&gt;'s (those in the trailer)
    not to trigger events,
    but to be consumed by Marpa directly.
    &lt;/p&gt;
    &lt;h2&gt;The procedural logic&lt;/h2&gt;
    &lt;p&gt;
    At this point, we have solved part of the problem with context-free syntax,
    and set up a Marpa event named &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot;,
    which will solve the rest of it.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    my $input_length = length ${$input};
    for (
        my $pos = $recce-&gt;read($input);
        $pos &lt; $input_length;
        $pos = $recce-&gt;resume()
      )
    {
      &lt;/tt&gt;&lt;b&gt;... Process events ...&lt;/b&gt;&lt;tt&gt;
    }
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;Processing of events takes place inside a Marpa read loop.
    This is initialized with a &lt;tt&gt;read()&lt;/tt&gt; method,
    and is continued with a &lt;tt&gt;resume()&lt;/tt&gt; method.
    The &lt;tt&gt;read()&lt;/tt&gt; and &lt;tt&gt;resume()&lt;/tt&gt; methods
    both return the current position
    in the input.
    If the current position is end-of-input, we are done.
    If not, we were interrupted by an event, which we
    must process.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    &lt;/tt&gt;&lt;b&gt;Process events&lt;/b&gt;&lt;tt&gt;

    EVENT:
      for (
	  my $event_ix = 0 ;
	  my $event    = $recce-&gt;event($event_ix) ;
	  $event_ix++
	)
      {
	  my $name = $event-&gt;[0];
	  if ( $name eq 'before C' ) {
	      &lt;/tt&gt;&lt;b&gt;... Process &quot;before C&quot; event ...&lt;/b&gt;&lt;tt&gt;
	  }
	  die qq{Unexpected event: name=&quot;$name&quot;};
      }
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;In this application, only one event can occur at any location,
    so the above loop is &quot;overkill&quot;.
    It loops through the events, one by one.
    The &lt;tt&gt;event&lt;/tt&gt; method returns a reference to an array
    of event data.
    The only element we care about is the event name.
    In fact, if we weren't being careful about error checking,
    we would not even care about the event name,
    since there can be only one.
    &lt;/p&gt;
    &lt;p&gt;If, as expected, the event name is &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot;,
    we process it.
    In any other case, we die with an error message.
    &lt;/p&gt;
    &lt;pre&gt;&lt;tt&gt;
    &lt;/tt&gt;&lt;b&gt;Process &quot;before C&quot; event&lt;/b&gt;&lt;tt&gt;

    my ( $start, $length ) = $recce-&gt;last_completed_span('ABs');
    my $c_length = ($length) / 2;
    my $c_seq = ( 'c' x $c_length );
    if ( substr( ${$input}, $pos, $c_length ) eq $c_seq ) {
	$recce-&gt;lexeme_read( 'Cs', $pos, $c_length, $c_seq );
	next EVENT;
    }
    die qq{Too few C's};
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;This is the core part of our procedural logic,
    where we have a &quot;&lt;tt&gt;before C&lt;/tt&gt;&quot; event.
    We must
    &lt;ul&gt;
    &lt;li&gt;determine the right number of &lt;tt&gt;c&lt;/tt&gt; characters;&lt;/li&gt;
    &lt;li&gt;check that the input has
      the right number of &lt;tt&gt;c&lt;/tt&gt; characters;&lt;/li&gt;
    &lt;li&gt;put together a lexeme to feed the Marpa parser; and&lt;/li&gt;
    &lt;li&gt;return control to Marpa.&lt;/li&gt;
    &lt;/ul&gt;
    There is a lot going on,
    and some of Marpa's most powerful capabilities for assisting
    procedural logic are shown here.
    So we will go through the above display in detail.
    &lt;/p&gt;
    &lt;h3&gt;Left-eidetic&lt;/h3&gt;
    &lt;pre&gt;&lt;tt&gt;
    my ( $start, $length ) = $recce-&gt;last_completed_span('ABs');
    my $c_length = ($length) / 2;
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;Marpa claims to be &quot;left-eidetic&quot;,
    that is, to have full knowledge of the parse so far,
    and to make this knowledge available to the programmer.
    How does a programmer cash in on this promise?
    &lt;p&gt;Of course, there is
    &lt;a href=&quot;https://metacpan.org/pod/distribution/Marpa-R2/pod/Progress.pod&quot;&gt;a fully general interface&lt;/a&gt;,
    which allows you to go through the Earley tables and extract
    the information in any form necessary.
    But another, more convenient interface,
    fits our purposes here.
    Specifically,
    &lt;/p&gt;
    &lt;ul&gt;&lt;li&gt;we want to determine how many &lt;tt&gt;c&lt;/tt&gt; characters we are looking for.&lt;/li&gt;
    &lt;li&gt;How many &lt;tt&gt;c&lt;/tt&gt; characters we are looking for depends
    on the number of
    &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; characters that we have already seen
    in the target.&lt;/li&gt;
    &lt;li&gt;The &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; characters that we have already seen in the
    target are in the
    &lt;tt&gt;&amp;lt;ABs&amp;gt;&lt;/tt&gt; symbol instance.&lt;/li&gt;
    &lt;li&gt;So, what we want to know is the length of the
    most recent &lt;tt&gt;&amp;lt;ABs&amp;gt;&lt;/tt&gt; symbol instance.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;/p&gt;
    &lt;p&gt;Marpa has a &lt;tt&gt;last_completed_span()&lt;/tt&gt; method,
    and that is just what we need.
    This finds the most recent instance of a symbol.
    (If there had been more than one most recent instance,
    it would have found the longest.)
    The &lt;tt&gt;last_completed_span()&lt;/tt&gt; method returns the start
    of the symbol instance (which we do not care about)
    and its length.
    The desired number of &lt;tt&gt;c&lt;/tt&gt; characters,
    &lt;tt&gt;$c_length&lt;/tt&gt;, is half the length of the
    &lt;tt&gt;&amp;lt;ABs&amp;gt;&lt;/tt&gt; instance.
    &lt;/p&gt;
    &lt;h3&gt;External parsing&lt;/h3&gt;
    &lt;pre&gt;&lt;tt&gt;
    my $c_seq = ( 'c' x $c_length );
    if ( substr( ${$input}, $pos, $c_length ) eq $c_seq ) { &lt;/tt&gt;&lt;b&gt;...&lt;/b&gt;&lt;tt&gt; }
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;Marpa allows external parsing.
    You can pause Marpa, as we have done,
    and hand control over to another parser -- including
    another instance of Marpa.
    &lt;/p&gt;
    &lt;p&gt;
    Here external parsing is necessary to make our parser
    context-sensitive,
    but the external parser does not have to be fancy.
    All it needs to do is
    some counting -- not hard,
    but something that a context-free grammar cannot do.
    &lt;/p&gt;
    &lt;p&gt;
    &lt;tt&gt;$pos&lt;/tt&gt; is the current position in the input,
    as returned by the &lt;tt&gt;read()&lt;/tt&gt; or &lt;tt&gt;resume()&lt;/tt&gt;
    method in the outer loop.
    Our input is the string referred to by &lt;tt&gt;$input&lt;/tt&gt;.
    We just calculated &lt;tt&gt;$c_length&lt;/tt&gt; as the number of
    &lt;tt&gt;c&lt;/tt&gt; characters required.
    The above code checks to see that the required number of
    &lt;tt&gt;c&lt;/tt&gt; characters is at &lt;tt&gt;$pos&lt;/tt&gt; in the input.
    &lt;/p&gt;
    &lt;h3&gt;Communicating with Marpa&lt;/h3&gt;
    &lt;pre&gt;&lt;tt&gt;
	$recce-&gt;lexeme_read( 'Cs', $pos, $c_length, $c_seq );
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    Our external logic is doing the parsing,
    but we need to let Marpa know what we are finding.
    We do this with the &lt;tt&gt;lexeme_read()&lt;/tt&gt; method.
    &lt;tt&gt;lexeme_read()&lt;/tt&gt; needs to know what symbol we are reading
    (&lt;tt&gt;Cs&lt;/tt&gt; in our case);
    and its value
    (&lt;tt&gt;$c_seq&lt;/tt&gt; in our case).
    &lt;/p&gt;
    &lt;p&gt;
    Marpa requires that
    every symbol be tied in some way to the input.
    The tie-in is only for error reporting,
    and it can be hack-ish or completely artificial,
    if necessary.
    In this application, our symbol instance is tied into
    the input in a very natural way --
    it is the stretch of the input that we compared
    to &lt;tt&gt;$c_seq&lt;/tt&gt; in the display before last.
    We therefore tell Marpa
    that the symbol is at &lt;tt&gt;$pos&lt;/tt&gt; in the input,
    and of length &lt;tt&gt;$c_length&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Passing control back to Marpa&lt;/h3&gt;
    &lt;pre&gt;&lt;tt&gt;
	next EVENT;
    &lt;/tt&gt;&lt;/pre&gt;
    &lt;p&gt;
    External parsing can go on quite a long time.
    In fact, an external parser &lt;b&gt;never&lt;/b&gt; has to hand
    control back to Marpa.
    But in this case, we are done very quickly.
    &lt;/p&gt;
    &lt;p&gt;
    We ask for the next iteration of the &lt;tt&gt;EVENT&lt;/tt&gt;
    loop.
    (In this code,
    there will not be a next iteration, unless there is an error.)
    Once done, the &lt;tt&gt;EVENT&lt;/tt&gt; loop will hand control
    over to the outer loop.
    The outer loop will call the &lt;tt&gt;resume()&lt;/tt&gt;
    method to return control back to Marpa.
    &lt;/p&gt;
    &lt;h2&gt;The code, comments, etc.&lt;/h2&gt;
    &lt;p&gt;The full code for this example is 
    &lt;a href=&quot;https://github.com/jeffreykegler/Ocean-of-Awareness-blog/tree/gh-pages/code/csg&quot;&gt;
    on-line&lt;a&gt;.
      There is a lot more to Marpa, including
      more facilities for adding procedural logic to your Marpa parsers.
      To learn more about Marpa,
      a good first stop is the
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;semi-official web site, maintained by Ron Savage&lt;/a&gt;.
      The official, but more limited, Marpa website
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;is my personal one&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
    &lt;/p&gt;
    &lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;p id=&quot;footnote-1&quot;&gt;&lt;b&gt;1.&lt;/b&gt;
      To handle procedural logic well,
      an Earley engine needs to complete its Earley sets
      in strict order --
      that is, Earley set &lt;tt&gt;N&lt;/tt&gt;
      cannot change after work on Earley set &lt;tt&gt;N+1&lt;/tt&gt;
      has begun.
      I have not looked at every Earley parse engine,
      and some may have had this strict-sequencing property.
      And many of the papers are agnostic about the order
      of operations.
      But Marpa is the first Earley parser to recognize
      and exploit strict-sequencing as a feature.
 &lt;a href=&quot;#footnote-1-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-2&quot;&gt;&lt;b&gt;2.&lt;/b&gt;
    The ABC grammar, in fact,
    is not all that easy or natural to describe
    even with a context-sensitive phrase structure description.
    A solution is given on Wikipedia:
    &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-sensitive_grammar#Examples&quot;&gt;
    https://en.wikipedia.org/wiki/Context-sensitive_grammar#Examples&lt;/a&gt;.
 &lt;a href=&quot;#footnote-2-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Parsing with pictures</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2018/05/pingali.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body style=&quot;max-width:850px&quot;&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;h2&gt;Derivatives == Earley?&lt;/h2&gt;
    &lt;p&gt;In a cordial Twitter exchange with Matt Might and
      and David Darais, Prof. Might asked if I was interested
      in looking at their derivatives-based approach.
      I answered that I was looking at it --
      Marpa is an optimization of the Might/Darais approach.
    &lt;/p&gt;
    &lt;p&gt;This may sound strange.
      At first glance, our two algorithms seem about as different as
      parsing algorithms can get.
      My Marpa parser is an Earley parser, table-driven,
      and its parse engine is written in C language.&lt;a id=&quot;footnote-1-ref&quot; href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
      The MDS (Might/Darais/Spiewak) parser is
      an extension of regular expressions
      which constructs states on the fly.
      MDS uses combinators and has implementations
      in several functional programming languages.&lt;a id=&quot;footnote-2-ref&quot; href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;Grammar Flow Graphs&lt;/h2&gt;
    &lt;p&gt;Why then do I imagine that Marpa is an optimized version of the MDS
      approach?
      The reason is a paper sent to
      me by Prof. Keshav Pingali at Austin: &quot;Parsing with Pictures&quot;.&lt;a id=&quot;footnote-3-ref&quot; href=&quot;#footnote-3&quot;&gt;[3]&lt;/a&gt;
      The title is a little misleading:
      their approach is not
      &lt;b&gt;that&lt;/b&gt;
      easy,
      and the paper requires a considerable amount of math.
      But it is a lot easier than the traditional way
      of learning the various approaches to parsing.
    &lt;/p&gt;
    &lt;p&gt;The basis of the Pingali-Bilardi approach
      is the Grammar Flow Graph (GFG).
      These GFGs are the &quot;pictures&quot; of their title.
      GFGs are NFAs with recursion added.
      As has long been known,
      adding recursion to NFAs
      allows them to represent any context-free language.
    &lt;/p&gt;
    &lt;p&gt;Pingali and Bilardi's next step is new.
      A GFG can be &quot;simulated&quot; using the same algorithm
      used to simulate an NFA.
      However, the result is not immediately impressive.
      The simulation does produce a recognizer, but not a good recognizer:
      Some of the strings recognized by
      the GFG simulator
      are not in the context-free language.&lt;a id=&quot;footnote-4-ref&quot; href=&quot;#footnote-4&quot;&gt;[4]&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;To repair their &quot;simulation&quot;,
      Pingali and Bilardi add a tag to each state.
      This tag tracks where the recursion began.&lt;a id=&quot;footnote-5-ref&quot; href=&quot;#footnote-5&quot;&gt;[5]&lt;/a&gt;.
      This not only fixes the recognizer,
      but the added information is enough to allow the set
      of parse trees to be efficiently recovered from the
      sets of GFG states.
      In other words, with tags, the GFG recognizer now is a parser.
    &lt;/p&gt;
    &lt;p&gt;
      It turns out that this recognizer-turned-parser is not new.
      In fact, it is
      &lt;b&gt;exactly&lt;/b&gt;
      Earley's algorithm.
    &lt;/p&gt;
    &lt;p&gt;Pingali and Bilardi do not stop there.
      Using their new framework,
      they go on to show that all LL-based and LR-based algorithms
      are simplifications of their Earley parser.
      From this point of view,
      Earley parsing is the foundation of all context-free parsing,
      and LL- and LR-based algorithms are Earley optimizations.&lt;a id=&quot;footnote-6-ref&quot; href=&quot;#footnote-6&quot;&gt;[6]&lt;/a&gt;
    &lt;/p&gt;&lt;h2&gt;Step 1: The MDS algorithm&lt;/h2&gt;
    &lt;p&gt;
      To show that Marpa is an optimization of the MDS approach,
      I will start with the MDS algorithm, and attempt to optimize it.
      For its functional programming language,
      the MDS paper uses Racket.
      The MDS parser is described directly,
      in the usual functional language manner,
      as a matching
      operation.
    &lt;/p&gt;
    &lt;p&gt;
      In the MDS paper,
      the MDS parser is optimized with laziness and memoization.
      Nulls are dealt with by computing their fixed points on the fly.
      Even with these three optimizations,
      the result is still highly inefficient.
      So,
      as an additional step, MDS also
      implements &quot;deep recursive simplication&quot; -- in effect,
      strategically replacing laziness with eagerness.
      With this the MDS paper conjectures that the algorithm's time
      is linear for a large class of practical grammars.
    &lt;/p&gt;
    &lt;h2&gt;Step 2: Extended regular expressions&lt;/h2&gt;
    &lt;p&gt;
      Next, we notice that the context-free grammars
      of the MDS algorithm
      are regular expressions extended to allow recursion.
      Essentially, they are
      GFG's translated into Racket match expressions.
      The equivalence is close enough that
      you could imagine the MDS paper using GFG's
      for its illustrations.
    &lt;/p&gt;
    &lt;h2&gt;Step 3: Simulating an NFA&lt;/h2&gt;
    &lt;p&gt;
      Unsurprisingly, then,
      the MDS and GFG approaches are similar in their first step.
      Each consumes a single character to produce a
      &quot;partial parse&quot;.
      A partial parse, for both of these algorithms,
      can be represented as a duple.
      One element of the duple is a string representing the
      unconsumed input.
      The other is a representation of a set of parse trees.
      In the case of MDS,
      in keeping with its functional approach,
      the set of parse trees is represented directly.
      In the case of the GFG-simulator,
      the set of parse trees is compressed into a sequence of
      GFG-state-sets.
      There is one GFG-state-set for the start of parsing,
      and one for each consumed character.
    &lt;/p&gt;
    &lt;h2&gt;Step 4: Earley's Algorithm&lt;/h2&gt;
    &lt;p&gt;At this point,
      with the introduction of the GFG state-sets to represent parse-trees,
      the MDS algorithm and its optimized GFG equivalent have
      &quot;forked&quot;.
      Recall from above,
      that this GFG simulator has a bug --
      it is over-liberal.
    &lt;/p&gt;
    &lt;p&gt;
      The bug is the one already described,
      and our fix is the one already described:
      Each GFG state either starts a recursion or is part of one.
      We fix the bug by tagging each GFG state with
      the index of the GFG state-set that starts its recursion.
      Once these tags are added,
      the GFG state-sets are exactly Earley sets.
    &lt;/p&gt;
    &lt;h2&gt;Step 5: The Leo optimization&lt;/h2&gt;
    &lt;p&gt;Next we incorporate an optimization by Joop Leo,
      which makes Earley parsing linear for all LR-regular grammars,
      without using lookahead.
      Since LR-regular is a superset of LR(k) and LL(k),
      including LL(*),
      we do not bother with lookahead.
    &lt;/p&gt;
    &lt;h2&gt;Step 6: Marpa&lt;/h2&gt;
    &lt;p&gt;To get from an Earley/Leo parser to a Marpa parser,
      we need to address one more major point.
      In modern parsing practice,
      programmers expect the ability to introduce procedural logic,
      even to the point of switching parsers.
      By ensuring that processing each Earley set is complete
      before processing on the next Earley set begins,
      we accomplish this.
    &lt;/p&gt;
    &lt;p&gt;
      This means that Marpa has available full information
      about the parse so far -- it is left-eidetic.
      Error reporting is unexcelled,
      and procedural logic can use this information as well.
      For example,
      full parse information implies full knowledge of which
      tokens are expected next.
    &lt;/p&gt;
    &lt;p&gt;
      This means that you can write an liberal HTML parser,
      starting with a very illiberal HTML grammar.
      When the illiberal parser encounters a point where it cannot
      continue because of a missing token,
      procedural logic can ask
      what the expected token is;
      concoct that token on the fly;
      supply that token to the illiberal parser;
      and then ask the illiberal parser to continue.
      This is called the &quot;Ruby Slippers&quot; technique,
      and an HTML parser based on it has been implemented.&lt;a id=&quot;footnote-7-ref&quot; href=&quot;#footnote-7&quot;&gt;[7]&lt;/a&gt;
    &lt;/p&gt;
    &lt;h2&gt;The way forward&lt;/h2&gt;
    &lt;p&gt;
      As mentioned,
      the MDS algorithm has its own approach to optmization,
      one which takes maximum advantage of functional programming.
      In contrast, Marpa relies on C level coding.
    &lt;/p&gt;
    &lt;p&gt;One example of the contrast in optimization techniques
      is null handling.
      Recall from above that, to deal with null processing,
      the MDS algorithm uses a fixed-point
      algorithm on the fly.
      Marpa, on the other hand,
      before parsing begins.
      precomputes a list of nullable
      symbols using bit vectors.
      In this particular case, Marpa will usually be the winner.
    &lt;/p&gt;
    &lt;p&gt;A second case in which hand optimization wins is the
      all-important Leo optimization.
      Simon Peyton-Jones is a very smart man,
      but nonetheless I believe that
      the day that GHC will look at a functional specification
      of an Earley parser and rediscover the Leo optimization
      at compile time is far off.
    &lt;/p&gt;
    &lt;p&gt;
      On the other hand,
      I do not imagine that hand optimization and/or C language is the
      winner in all cases.
      A programmer is deceiving himself if he imagines that he can spot all the cases where
      lazy evaluation or memoization will be effective in the general case.
      And of course,
      even an omniscient programmer is not going to be there at run-time
      to do &quot;just in time&quot; optimization.
      Perhaps the optimal parser of the future will combine important hand optimizations
      with functional programming.
    &lt;/p&gt;
    &lt;h2&gt;Comments, etc.&lt;/h2&gt;
    &lt;p&gt;
      To learn about Marpa,
      my Earley/Leo-based parsing project,
      there is the
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;semi-official web site, maintained by Ron Savage&lt;/a&gt;.
      The official, but more limited, Marpa website
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;is my personal one&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
    &lt;/p&gt;
    &lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;p id=&quot;footnote-1&quot;&gt;&lt;b&gt;1.&lt;/b&gt;
        Kegler, Jeffrey.
        &quot;Marpa, A Practical General Parser: The Recognizer.&quot;, 2013.
        &lt;a href=&quot;http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/KEGLER,%20Jeffrey%20-%20Marpa,%20a%20practical%20general%20parser:%20the%20recognizer.pdf&quot;&gt;
          PDF accessed 24 April 2018&lt;/a&gt;.
        &lt;br&gt;&lt;br&gt;
        Marpa has a stable implementation.
        For it, and for more information on Marpa, there are these resources:
        &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;
          Marpa website, accessed 25 April 2018&lt;/a&gt;.
        &lt;a href=&quot;https://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;
          Kegler's website, accessed 25 April 2018&lt;/a&gt;.
        &lt;a href=&quot;https://github.com/jeffreykegler/Marpa--R2&quot;&gt;
          Github repo, accessed 25 April 2018.&lt;/a&gt;
        &lt;a href=&quot;https://metacpan.org/pod/Marpa::R2&quot;&gt;
          MetaCPAN, accessed 30 April 2018.&lt;/a&gt;.
 &lt;a href=&quot;#footnote-1-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-2&quot;&gt;&lt;b&gt;2.&lt;/b&gt;
        Matthew Might, David Darais and Daniel Spiewak. &quot;Functional Pearl: Parsing with Derivatives.&quot; International Conference on Functional Programming 2011 (ICFP 2011). Tokyo, Japan. September, 2011. pages 189--195.
        &lt;a href=&quot;http://matt.might.net/papers/might2011derivatives.pdf&quot;&gt;
          PDF accessed 9 Jun 2018&lt;/a&gt;.
        &lt;a href=&quot;http://matt.might.net/papers/might2011derivatives-icfp-talk.pdf&quot;&gt;
          Slides accessed 9 June 2018&lt;/a&gt;.
        &lt;a href=&quot;http://matt.might.net/media/mattmight-icfp2011-derivatives.mp4&quot;&gt;
          Video accessed 9 June 2018&lt;/a&gt;.
 &lt;a href=&quot;#footnote-2-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-3&quot;&gt;&lt;b&gt;3.&lt;/b&gt;
        Keshav Pingali and Gianfranco Bilardi, UTCS tech report TR-2012.
        2012.
        &lt;a href=&quot;https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2102.pdf&quot;&gt;
          PDF accessed 9 Junk 2018&lt;/a&gt;.
        &lt;a href=&quot;https://www.youtube.com/watch?v=eeZ3URxd8Wc&quot;&gt;
          Video accessed 9 June 2018&lt;/a&gt;.
        &lt;br&gt;&lt;br&gt;
        Less accessible,
        but with more details about GFGs and GFG-based
        Earley parsing is
        Keshav Pingali and Gianfranco Bilardi,
        &quot;A graphical model for context-free grammar parsing.&quot;
        Compiler Construction - 24th International Conference, CC 2015.
        Lecture Notes in Computer Science,
        Vol. 9031, pp. 3-27, Springer Verlag, 2015.
        &lt;a href=&quot;https://www.researchgate.net/publication/286479583_A_Graphical_Model_for_Context-Free_Grammar_Parsing&quot;&gt;
          PDF accessed 9 June 2018&lt;/a&gt;.
 &lt;a href=&quot;#footnote-3-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-4&quot;&gt;&lt;b&gt;4.&lt;/b&gt;
        Pingali and Bilardi 2012, section 3.1.
 &lt;a href=&quot;#footnote-4-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-5&quot;&gt;&lt;b&gt;5.&lt;/b&gt;
        Pingali and Bilardi 2015, p. 11.
 &lt;a href=&quot;#footnote-5-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-6&quot;&gt;&lt;b&gt;6.&lt;/b&gt;
        Pingali and Bilardi 2012, Sections 4-7.
 &lt;a href=&quot;#footnote-6-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;footnote-7&quot;&gt;&lt;b&gt;7.&lt;/b&gt;
        I have based an
        liberal HTML pretty-printer on that parser,
        one which I use quite frequently.
        I used it, for example, when writing this blog post.
        To find out more about Ruby Slippers parsing see the Marpa FAQ,
        &lt;a href=&quot;http://savage.net.au/Perl-modules/html/marpa.faq/faq.html#q122&quot;&gt;
          questions 122&lt;/a&gt;
        and
        &lt;a href=&quot;http://savage.net.au/Perl-modules/html/marpa.faq/faq.html#q123&quot;&gt;
          123&lt;/a&gt;;
        my
        &lt;a href=&quot;file:///mnt2/new/projects/Ocean-of-Awareness-blog/metapages/annotated.html#PARSE_HTML&quot;&gt;
          blog series on parsing html&lt;/a&gt;; and
        my blog post
        &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html&quot;&gt;
          &quot;Marpa and the Ruby Slippers&quot;&lt;/a&gt;.
 &lt;a href=&quot;#footnote-7-ref&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  </channel>
</rss>
