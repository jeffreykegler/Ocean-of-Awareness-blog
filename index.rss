<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>A Configurable HTML Parser</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/config_html.html</link>
    <description>    &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment
      --&gt;
      This post introduces an HTML parser which is both liberal and configurable.
      Currently available as a
      &lt;a href=&quot;https://metacpan.org/release/JKEGL/Marpa-R2-2.021_006&quot;&gt;
        part of a Marpa::R2 developer's release on CPAN&lt;/a&gt;,
      the new Marpa::R2::HTML allows detailed
      configuration of new tags
      and respecification of the behavior of existing tags.
    &lt;/p&gt;&lt;p&gt;
      To show how a configurable HTML parser works,
      I will start with a simple task.
      Let's suppose we have a new tag, call it
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;.
      The older, non-configurable version of Marpa, and most browsers,
      would recognize this tag.
      But they'd simply give it a default configuration,
      one which is usually very liberal --
      liberal meaning the tag is allowed to contain just about anything,
      and to go just about anywhere.
      A configurable parser allows us to specify the new tag's behavior
      more explicitly and strictly.
    &lt;/p&gt;&lt;h3&gt;
      Block vs. inline&lt;/h3&gt;&lt;p&gt;
      In this post
      I am going to assume that the reader knows,
      or will look up what he needs to know,
      about HTML.
      But block vs. inline is a essential HTML concept
      which is often ignored -- even
      &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;
      the excellent Wikipedia page on HTML&lt;/a&gt;
      does not define &quot;inline&quot;, although it uses the term in the technical
      sense twice.
      Since the concept is also central to this post,
      let me briefly summarize it.
    &lt;/p&gt;&lt;p&gt;
      Quoting from the
      &lt;a href=&quot;http://www.w3.org/TR/1999/PR-html40-19990824/sgml/dtd.html#inline&quot;&gt;
        HTML 4.01 Strict DTD&lt;/a&gt;,
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
      HTML has two basic content models:

        %inline;     character level elements and text strings
        %block;      block-like elements e.g. paragraphs and lists
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      There is also what I will call a &quot;mixed flow&quot;,
      which can contain anything that
      can appear in either a block or inline flow.
      (What I call a mixed flow is
      simply called a &quot;flow&quot;
      in the HTML 4.01 DTD.)
    &lt;/p&gt;&lt;p&gt;
      Significant in the examples are
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;,
      which is a block element that contains an inline flow and
      &lt;code&gt;
        &amp;lt;span&amp;gt;&lt;/code&gt;,
      which is an inline element that contains an inline flow.
      The
      &lt;code&gt;
        &amp;lt;body&amp;gt;&lt;/code&gt;
      tag is an important structural tag,
      which contains an block flow.
    &lt;/p&gt;&lt;p&gt;
      For simplicity I am following HTML 4.01 DTD.
      HTML 5
      uses radically different terminology and is more liberal
      in what it allows.
      Differences among standards are an important reason for
      an HTML parser to be configurable.
    &lt;/p&gt;
    &lt;h3&gt;
      Controlling element context&lt;/h3&gt;
    &lt;h4&gt;
      An inline element containing an inline flow&lt;/h4&gt;
    &lt;p&gt;
      Let's define the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      tag
      to be an inline tag with inline contents.
      This is done by adding the following line to the
      Marpa::R2::HTML grammar configuration file:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
ELE_marpa is a FLO_inline included in GRP_inline
&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      Let's take as our HTML, the following:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;marpa&amp;gt;-during-&amp;lt;span&amp;gt;-more inline stuff-&amp;lt;p&amp;gt;-new block-
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      With the following shell commands,
      we add the new line to
      &lt;a href=&quot;https://gist.github.com/3869482&quot;&gt;
        &lt;code&gt;
          default.cfg&lt;/code&gt;,
        the default grammar configuration file&lt;/a&gt;.
      We then use the
      &lt;code&gt;
        marpa_r2_html_fmt&lt;/code&gt;
      utility
      that comes with Marpa::R2
      to parse the HTML.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
cp default.cfg test.cfg
echo &quot;ELE_acme is a FLO_inline included in GRP_inline&quot; &amp;gt;&amp;gt; test.cfg
echo '&amp;lt;acme&amp;gt;-during-&amp;lt;span&amp;gt;-more inline stuff-&amp;lt;p&amp;gt;-new block-' |
  marpa_r2_html_fmt --no-added-tag --compile test.cfg
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
&lt;code&gt;marpa_r2_html_fmt&lt;/code&gt; indents the HTML and
      adds missing tags
This will show us the structure of our small HTML document.
      Here is what we get:
    &lt;/p&gt;
    &lt;!-- examples/acme-inline-inline.out --&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;
      &amp;lt;acme&amp;gt;
        -during-&amp;lt;span&amp;gt;
          -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;/acme&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;
      -new block-
    &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      We see from this that the configuration took proper effect.
      Since the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      tag was configured as an inline element,
      it cannot go directly inside the
      the
      &lt;code&gt;
        &amp;lt;body&amp;gt;&lt;/code&gt;.
      So a new
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;
      is created to contain the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element.
      (A Marpa::R2::HTML configuration can also change
      the contents that are acceptable inside the
      &lt;code&gt;
        &amp;lt;body&amp;gt;&lt;/code&gt;.
      For the moment, we'll keep it simple
      and accept as given that
      &lt;code&gt;
        &amp;lt;body&amp;gt;&lt;/code&gt;
      contains a block flow.)
    &lt;/p&gt;&lt;p&gt;
      Similarly,
      since the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      tag contains an inline flow,
      it must end before the next
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;
      tag.
      The parser supplies an
      end tag for the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element,
      and also
      closes the
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;
      paragraph that was
      started to hold the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element.
    &lt;/p&gt;
    &lt;h4&gt;
      A block element containing an inline flow&lt;/h4&gt;
    &lt;!-- examples/acme-block-inline.out --&gt;
    &lt;p&gt;
      Our new configuration line can also specify that
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      is a block element:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
ELE_acme is a FLO_inline included in GRP_block
&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      The code to test this is very similar to that displayed above.
      It, and the scripts for all of this post's other examples,
      can be found
      &lt;a href=&quot;https://gist.github.com/3870030&quot;&gt;
        as a gist&lt;/a&gt;.
      Here's the result:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;acme&amp;gt;
      -during-&amp;lt;span&amp;gt;
        -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;/acme&amp;gt;&amp;lt;p&amp;gt;
      -new block-
    &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Here the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element is allowed in a block,
      so no new
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;
      element was needed to contain it.
      Since
      the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element's contents are inline,
      the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element still needed to be ended before
      the
      &lt;code&gt;
        &amp;lt;p&amp;gt;&lt;/code&gt;
      tag in the actual input.
    &lt;/p&gt;
    &lt;h3&gt;
      The grammar configuration file&lt;/h3&gt;
    &lt;p&gt;
      Those who click through to look at
      &lt;a href=&quot;https://gist.github.com/3869482&quot;&gt;
        the grammar configuration file&lt;/a&gt;
      may notice
      its length.
      Three pages.
      And almost half of those three pages
      are single-line descriptions of elements
      which are one or more of deprecated, obsolete
      or proprietary.
      Arguably the configuration file
      should be even shorter.
    &lt;/p&gt;&lt;p&gt;
      Other implementations of liberal HTML
      parsers spread the logic specifying the HTML
      variant across a considerably larger body of code,
      sometimes a vastly larger.
      This very much affects the cost of evolving and
      maintain the parser.
    &lt;/p&gt;&lt;p&gt;
      As for the configuration file's format at the moment:
      it is experimental.
      I can state from experience that it is
      quite serviceable,
      and fairly readable,
      but it could be more elegant.
    &lt;/p&gt;&lt;h3&gt;
      Controlling element content&lt;/h3&gt;
    &lt;h4&gt;
      A block element containing a mixed flow&lt;/h4&gt;
    &lt;!-- examples/acme-block-mixed.out --&gt;
    &lt;p&gt;
      We can also configure the contents of
      the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element.
      This configuration line specifies a mixed flow.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
ELE_acme is a FLO_mixed included in GRP_block
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;And here is what we get:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;acme&amp;gt;
      -during-&amp;lt;span&amp;gt;
        -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;p&amp;gt;
        -new block-
      &amp;lt;/p&amp;gt;&amp;lt;/acme&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      A mixed flow accepts any contents,
      so that the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element's contents expand to include the
      entire body of the html document.
    &lt;/p&gt;
    &lt;h4&gt;
      A block element containing a block flow&lt;/h4&gt;
    &lt;!-- examples/acme-block-block.out --&gt;
&lt;p&gt;With this configuration line, we request a block
        flow for the contents:
      &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
ELE_acme is a FLO_block included in GRP_block
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      The results:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;acme&amp;gt;
      &amp;lt;p&amp;gt;
        -during-&amp;lt;span&amp;gt;
          -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;
        -new block-
      &amp;lt;/p&amp;gt;&amp;lt;/acme&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Here the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element also spans the entire body of the HTML
      element,
      but because block flows are less liberal than
      mixed flows,
      the contents of the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element have to be properly &quot;packaged&quot; inside
      block elements.
    &lt;/p&gt;
    &lt;h4&gt;
      A block element containing PCDATA&lt;/h4&gt;
    &lt;!-- examples/acme-block-pcdata.out --&gt;
    &lt;p&gt;
      We are getting progressively more restrictive with the contents
      of the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element.
      We've already seen the example
      of an
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      block element for inline contents.
      This configuration line specifies that the contents
      must be PCDATA.
      PCDATA allows text, but not child elements.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
ELE_acme is a FLO_pcdata included in GRP_block
&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      The result:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;acme&amp;gt;
      -during-&amp;lt;/acme&amp;gt;&amp;lt;p&amp;gt;
      &amp;lt;span&amp;gt;
        -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;
      -new block-
    &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Note here that the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      tag ends as soon as another element is encountered.
    &lt;/p&gt;&lt;h4&gt;
      An empty block element&lt;/h4&gt;
    &lt;p&gt;
      The final restriction on the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element is the insistance that it be empty:
      &lt;!-- examples/acme-block-empty.out --&gt;
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
ELE_acme is a FLO_empty included in GRP_block
&lt;/pre&gt;&lt;/blockquote&gt;
      &lt;p&gt;
        And here is our result:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;acme&amp;gt;
    &amp;lt;/acme&amp;gt;&amp;lt;p&amp;gt;
      -during-&amp;lt;span&amp;gt;
        -more inline stuff-&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;
      -new block-
    &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;h3&gt;
      Displayed effects&lt;/h3&gt;
    &lt;p&gt;
      Any of these different configurations of
      the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      tag could have a dramatic effect on what is displayed,
      depending on your CSS file.
      Whether or not
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      is a block element also affects
      what is displayed.
      When
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      is a block element,
      its boundaries will typically display as paragraph breaks.
    &lt;/p&gt;
    &lt;p&gt;
      In the above examples,
      the case where
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      is configured as a block element containing PCDATA
      typically displays as three paragraphs:
    &lt;/p&gt;&lt;pre&gt;
-during-

-more inline stuff-

-new block-
&lt;/pre&gt;
    &lt;!-- html_fmt: Next line is cruft --&gt;
    &lt;/p&gt;
    &lt;p&gt;
      In the other cases, the end boundary of the
      &lt;code&gt;
        &amp;lt;acme&amp;gt;&lt;/code&gt;
      element varies,
      but always coincides with the beginning or
      end of other block elements,
      so that the visible display is as
      two paragraphs:
    &lt;/p&gt;&lt;pre&gt;
-during- -more inline stuff-

-new block-
&lt;/pre&gt;
    &lt;!-- html_fmt: Next line is cruft --&gt;
    &lt;/p&gt;
    &lt;h3&gt;
      Final remarks&lt;/h3&gt;&lt;p&gt;
      The configurable Marpa::R2::HTML does considerably more than
      could be mentioned in this post.
      I hope to say more about it soon.
      Comments on this post can be sent to the Marpa Google Group:
      &lt;code&gt;
        marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Parsing on your new hyper-quantum computer</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/quantum.html</link>
    <description>    &lt;blockquote&gt;
      &lt;!--
      perl ./marpa_r2_html_fmt
      --&gt;
      &lt;i&gt;
        If you want to build a ship, don't drum up the men to gather wood,
        divide the work and give orders. Instead, teach them to yearn for
        the vast and endless sea.&lt;/i&gt;
      -- Antoine de Saint-Exupery
    &lt;/blockquote&gt;
    &lt;p&gt;
      Imagine that, the day the new machine arrives,
      you are maintaining a parser.
      Your parser
      is the current state of the art
      -- hand-written recursive descent.
    &lt;/p&gt;&lt;p&gt;
    &lt;/p&gt;
    The new computer will
    replace your staid old von Neumann box is not
    just a quantum computer.
    It's fully non-deterministic.
    You can superposition any time you'd like,
    and then &quot;unsuperposition&quot; to restart.
    And when superpositioning, you can can examine
    &lt;strong&gt;
      all&lt;/strong&gt;
    the possibilities, not just one.
    &lt;p&gt;
      How would you rewrite your
      recursive descent logic to take advantage of this new hyper-quantum computer?
      Actually, this is exactly the same question that
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
        Marpa&lt;/a&gt;
      poses
      to you today.
      Because for all classes of grammar in practical use, including
      the LL(k) grammars parseable by recursive descent,
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
        Marpa&lt;/a&gt;
      is efficient non-determinism.
    &lt;/p&gt;
    &lt;p&gt;
      Your new hyper-quantum computer
      might seem at first to make your work as a programmer harder.
      On the hyper-quantum computer,
      many things are happening at once.
      On the deterministic box,
      you were dealing with a single procedural thread.
    &lt;/p&gt;
    &lt;p&gt;
      But as you get used to the new non-deterministic computer,
      you find ways in which it makes things easier.
      On the deterministic box,
      you only needed to follow a single thread,
      but you often needed to make that thread
      deal with multiple alternatives.
      To do this, you had to create
      state information and keep track of it yourself
      while backtracking.
      The complexity of dealing with
      all this roll-your-own state
      information severely limited the kinds of grammar that you could parse,
      and even the extent to which you understood exactly what your parser
      would and would not accept.
      Since much of the time on your old parser was spent
      backtracking,
      you no longer had a real handle on the
      time complexity in many sections of your code.
      In a couple of previous releases,
      minor changes had let the backtracking get out of hand.
    &lt;/p&gt;
    &lt;p&gt;
      The hyper-quantum computer
      now comes up with the parsing
      alternatives for you.
      True, you have to retrain yourself to think in terms of the alternatives
      available at any point.
      But you don't even have to know which alternatives are there --
      if you need to ask the hyper-quantum computer (or
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
        Marpa&lt;/a&gt;),
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::Progress&quot;&gt;
        it can tell you&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      You do have to learn to ask the right questions
      at the right places.
      Once you do this,
      you have a simpler and more cleanly written parser,
      running at comparable or faster speeds.
      And you begin to think about a few changes to
      the language,
      changes that will make your language more
      natural and expressive,
      but one which
      you could not have parsed before.
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>A Marpa-based HTML reformatter</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/html_fmt.html</link>
    <description>    &lt;p&gt;
      &lt;!--
      perl ./marpa_r2_html_fmt
      --&gt;
      This post is about
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;,
      a
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
        Marpa-&lt;/a&gt;based
      reformatter (&quot;tidier&quot;) for liberal HTML.
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      indents HTML according to the structure of the document,
      which makes the HTML a lot easier to read.
      In the process
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      adds missing start and end tags and identifies &quot;cruft&quot;.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      is ultra-liberal about its input.
      Like a browser's rendering engine,
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      never rejects a file,
      no matter how defective it is as an HTML document.
      An interesting experiment would be to compare what your
      favorite browser does with a random text file feed to
      it directly,
      with what it does to the same file
      after it has been passed through
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      is a by-product of moving
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/&quot;&gt;
        this blog to Github&lt;/a&gt;.
      In the course of bringing over
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html&quot;&gt;
        my old posts&lt;/a&gt;,
      I wanted a filter that would tidy them up,
      so I turned to an old demo script I'd written.
      The old demo's usefulness was a pleasant surprise,
      but it lacked two features.
      First, it wouldn't read from standard input.
      Second, in formatting the HTML, it introduced new whitespace.
      The first problem was easy to fix.
      Fixing the second involved coming up with a
      &quot;lowest common denominator&quot; for whitespace treatment
      among browsers and HTML variants.
    &lt;/p&gt;
    &lt;p&gt;
      The result,
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;,
      works very well as the first step in dealing with HTML
      that you are rewriting by hand.
      One quick pass-through and your file is much easier to read,
      has all the proper tags,
      and has comments pointing out any &quot;cruft&quot; that's there.
    &lt;/p&gt;
    &lt;p&gt;
      A production quality &quot;tidier&quot; would need to be something like
      &lt;tt&gt;
        gnuindent&lt;/tt&gt;
      --
      bristling with options.
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      so far has only two options,
      one dealing with whitespace before end tags,
      the other allowing
      a choice of strategies for avoiding added whitespace.
      (One strategy uses comments, while the other simply leaves
      the whitespace-sensitive locations as-is.)
      These two options are not nearly
      sufficient to deal with the full
      range of whitespace issues,
      never mind anything else.
    &lt;/p&gt;
    &lt;p&gt;
      But from a
      &lt;a href=&quot;http://blog.plover.com/oops/blosxom-sux.html&quot;&gt;
        &quot;Worse is Better&quot;&lt;/a&gt;
      point of view,
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      is a good start.
      It is 600 lines,
      short enough to find your
      way around in,
      particularly once you've deleted the parts you don't like.
      And its underlying Marpa-based interface is documented:
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::HTML&quot;&gt;
        Marpa::R2::HTML&lt;/a&gt;.
      Marpa::R2::HTML is beta, but has been stable for some time.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;a href=&quot;https://gist.github.com/3725639&quot;&gt;
      &lt;tt&gt;
        html_fmt&lt;/tt&gt;
      is now available as a gist.&lt;/a&gt;
      In a future release of
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
        Marpa::R2&lt;/a&gt;,
      it will be available as the
      &lt;tt&gt;
        marpa_r2_html_fmt&lt;/tt&gt; script.
      But why wait until then to fork it?
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Marpa::R2 is beta</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/r2_is_beta.html</link>
    <description>&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;Marpa::R2&lt;/a&gt;
is now beta.
Marpa is a new parsing algorithm,
based on decades of prior art.
It is a practical and efficient solution
targeted at all parsing problems that are too
complex for regular expressions.
&lt;p&gt;
The
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;Marpa::R2&lt;/a&gt;
module is the most recent Marpa module.
Marpa is also available as the
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&quot;&gt;
Marpa::XS&lt;/a&gt;
module,
which is stable and bug-fix only.
Both Marpa modules:
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Parse everything you can write in BNF.
&lt;li&gt;&lt;p&gt;
Parse all
classes of grammar in practical use today in linear time.
&lt;li&gt;&lt;p&gt;Parse all BNF grammars
in times considered theoretically optimal.
For unambiguous grammars, Marpa is never worse than
O(n&lt;sup&gt;2&lt;/sup&gt;).
For ambiguous grammars, Marpa is never worse than
O(n&lt;sup&gt;3&lt;/sup&gt;).
Marpa never goes exponential.
&lt;li&gt;&lt;p&gt;
Are fully aware, at every point in the parse, of
all the rules they are parsing,
how far into them they have proceeded,
and of what tokens they expect next.
Especially with Marpa::R2,
this information is available
to the application
conveniently and efficiently.
&lt;li&gt;&lt;p&gt;
Do not need to be handwritten.
Marpa is available as a open-source library.
It is written in C,
and the C library can be used
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/libmarpa.html&quot;&gt;
directly&lt;/a&gt;
or via
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
a Perl interface&lt;/a&gt;.
&lt;li&gt;&lt;p&gt;
For general BNF parsing,
do not require
the user to craft
a lookahead or backtracking strategy -- Marpa
does not use lookahead and never backtracks.
&lt;li&gt;&lt;p&gt;
Come
with the traditional theoretical apparatus of
proofs based on prior literature.
&lt;/ol&gt;
&lt;p&gt;
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;Marpa::R2&lt;/a&gt;
is a major rewrite of the Marpa internals.
The most visible of these changes:
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Marpa::R2 is faster.
&lt;li&gt;&lt;p&gt;Marpa::R2 is easier to install.
In particular the dependency on Glib has been removed.
Marpa::R2 now has no non-core CPAN dependencies.
&lt;li&gt;&lt;p&gt;Marpa::R2's internal symbols are now invisible
to the user, even when tracing and debugging.
&lt;li&gt;&lt;p&gt;
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/libmarpa&quot;&gt;
Libmarpa, the C library which is at the core of Marpa&lt;/a&gt;,
is now documented
and separately installable.
(Libmarpa remains alpha at this point.)
&lt;li&gt;&lt;p&gt;Another new documented interface,
&lt;a href=&quot;https://metacpan.org/module/Marpa::R2::Advanced::Thin&quot;&gt;
Marpa::R2::Thin&lt;/a&gt;,
is a &quot;thin&quot; interface to Libmarpa from Perl.
(Marpa::R2::Thin remains alpha at this point.)
&lt;/ol&gt;</description>
  </item>
  <item>
    <title>Domain-Specific Languages made simpler</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html</link>
    <description>&lt;h2&gt;Writing your own language&lt;/h2&gt;
&lt;p&gt;Creating your own language has been A Big Deal (tm).
What if you could create a simple language in hours or minutes?
There's been a serious obstacle up to now.
No practical parser &quot;just parsed&quot; BNF.
With
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;,
that restriction is lifted.
&lt;p&gt;
In this post, I will describe
a small, sample
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;
domain-specific language (DSL).
In designing it I am inspired by
&lt;a href=&quot;http://blog.plover.com/oops/blosxom-sux.html&quot;&gt;
Mark Dominus's description&lt;/a&gt;
of the
&lt;a href=&quot;http://en.wikipedia.org/wiki/Worse_is_better&quot;&gt;
&quot;Worse is Better&quot; philosophy&lt;/a&gt;,
and its implementation in the form of
&lt;a href=&quot;http://en.wikipedia.org/wiki/Blosxom&quot;&gt;
Blosxom&lt;/a&gt;.
This DSL is feature-poor,
but short, simple and extensible.
&lt;h2&gt;A calculator&lt;/h2&gt;
&lt;p&gt;
This DSL is a calculator.
Calculators are familiar and,
after all, whatever tool you build this
DSL into, it will probably be useful
to have a calculator as part of it.
What follows contains only the parts of the code
relevant to the discussion,
not necessarily in lexical order.
If you find the following interesting,
you'll almost certainly want the full code,
which is available as
&lt;a href=&quot;https://gist.github.com/3521836&quot;&gt;
a Github gist&lt;/a&gt;.
&lt;p&gt;
&lt;h2&gt;The grammar&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;
allows you to build your DSL as a clean modular
structure,
with a separate grammar, tokenizer and semantics.
If you're used to doing parsing with regexes or recursive descent,
you expect to see things mixed together,
and much as you might like modularity in other contexts,
this cleaner approach may make you uneasy.
And not without reason.
Traditionally, parsing tools that
took a modular approach
were painful to use and,
for practical grammars,
often rewarded the extra effort
they required by failing to work.
&lt;p&gt;Here's the grammar for our calculator.

&lt;div style=&quot;white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;&quot;&gt;
my $rules = Marpa::Demo::OP2::parse_rules(
    &lt;&lt;'END_OF_GRAMMAR'
reduce_op ::=
    '+'                   =&gt; do_arg0
  | '-'                   =&gt; do_arg0
  | '/'                   =&gt; do_arg0
  | '*'                   =&gt; do_arg0
script ::= e              =&gt; do_arg0
script ::= script ';' e   =&gt; do_arg2
e ::=
     NUM                  =&gt; do_arg0
   | VAR                  =&gt; do_is_var
   | :group '(' e ')'     =&gt; do_arg1
  || '-' e                =&gt; do_negate
  || :right e '^' e       =&gt; do_binop
  || e '*' e              =&gt; do_binop
   | e '/' e              =&gt; do_binop
  || e '+' e              =&gt; do_binop
   | e '-' e              =&gt; do_binop
  || e ',' e              =&gt; do_array
  || reduce_op 'reduce' e =&gt; do_reduce
  || VAR '=' e            =&gt; do_set_var
END_OF_GRAMMAR
);
&lt;/div&gt;

&lt;p&gt;This is a simple language, but it's already an advance over,
&lt;a href=&quot;http://blog.plover.com/prog/bash-expr.html&quot;&gt;
say, shell arithmetic&lt;/a&gt;.
And the &lt;tt&gt;reduce&lt;/tt&gt; operator is even a bit
of fanciness.
It's a second-order binary operator,
whose left operand is another operator.
&lt;p&gt;The grammar is written in another DSL, &lt;tt&gt;Marpa::Demo::OP2&lt;/tt&gt;,
which is bundled into the same file.
(OP2's grammar is defined directly in
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;.)
Together, these two quite useable DSL's require 600 lines,
self-testing included.
&lt;p&gt;
I'm using OP2 in this post, as it presents the &lt;strong&gt;idea&lt;/strong&gt;
of a grammar more clearly.
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;'s
lower level syntax, while more stable, flexible and efficient,
is more cluttered.
OP2 itself is interesting as an extension and generalization of
precedence parsing,
as I described in
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2012/08/precedence-parsing-made-simpler.html&quot;&gt;
a previous post&lt;/a&gt;.
Here's its syntax:
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;::=&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;A BNF rule in LHS &lt;tt&gt;::=&lt;/tt&gt; RHS form
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;'abc'&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;A literal token.
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;Separates alternative RHS's at the &lt;strong&gt;same&lt;/strong&gt; precedence level
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;||&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;Separates alternative RHS's at the &lt;strong&gt;different&lt;/strong&gt; precedence levels.
  The tighter (&quot;higher&quot;) precedence alternative is first, the
  looser (&quot;lower&quot;) precedence alternative is second.
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;=&amp;gt;&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;&lt;tt&gt;rule =&amp;gt; semantics&lt;/tt&gt;, where &lt;tt&gt;semantics&lt;/tt&gt;
is a Perl closure.
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;:left&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;The alternative is left-associative (the default)
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;:right&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;The alternative is right-associative
&lt;dt&gt;&lt;strong&gt;&lt;tt&gt;:group&lt;/tt&gt;&lt;/strong&gt;&lt;dd&gt;The alternative is grouping-associative -- that is, its
operator(s), regardless of their own precedence,
group expressions of the loosest precedence
&lt;/dl&gt;

&lt;div style=&quot;white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;&quot;&gt;
my $grammar = Marpa::R2::Grammar-&gt;new(
    {   start          =&gt; 'script',
        actions        =&gt; __PACKAGE__,
        rules          =&gt; $rules,
    }
);
$grammar-&gt;precompute;
&lt;/div&gt;

&lt;p&gt;The code just above creates a new grammar from the OP2-generated rules.
The only other information needed to fully define
the grammar is the name of the start symbol
(&quot;&lt;tt&gt;script&lt;/tt&gt;&quot;) and the name of the package where
the semantics can be found
(the current one, &lt;tt&gt;__PACKAGE__&lt;/tt&gt;).
&lt;p&gt;
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;
does a lot of precomputation to its grammars.
Once a grammar is fully defined,
and before a recognizer can be created from it,
the &lt;tt&gt;precompute()&lt;/tt&gt; method must be called.
&lt;h2&gt;The semantics&lt;/h2&gt;
&lt;p&gt;
Those curious about the semantics of this calculator
can look at
&lt;a href=&quot;https://gist.github.com/3521836&quot;&gt;
the Github gist&lt;/a&gt;.
They are somewhat interesting.
But this post is about how to get &lt;strong&gt;your&lt;/strong&gt; interesting
semantics out easily and quickly,
in the form of a powerful
language specifically designed for them.
&lt;h2&gt;The lexer&lt;/h2&gt;
&lt;h3&gt;The token table&lt;/h3&gt;
&lt;p&gt;The calculator's lexer is table-driven.
The table is quite simple -- it's an array
of two element arrays.
In the inner arrays, the first element is the symbol name,
as specified in the grammar,
and the second is a regex which matches it.

&lt;div style=&quot;white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;&quot;&gt;
my @terminals = (
    [ q{'reduce'}, qr/reduce\b/xms ],
    [ 'NUM',       qr/\d+/xms ],
    [ 'VAR',       qr/\w+/xms ],
    [ q{'='},      qr/[=]/xms ],
    [ q{';'},      qr/[;]/xms ],
    [ q{'*'},      qr/[*]/xms ],
    [ q{'/'},      qr/[\/]/xms ],
    [ q{'+'},      qr/[+]/xms ],
    [ q{'-'},      qr/[-]/xms ],
    [ q{'^'},      qr/[\^]/xms ],
    [ q{'('},      qr/[(]/xms ],
    [ q{')'},      qr/[)]/xms ],
    [ q{','},      qr/[,]/xms ],
);
&lt;/div&gt;

&lt;p&gt;
Order in the above table matters when you have
terminals, one of which can prefix another.
An example would be the operators
&lt;tt&gt;==&lt;/tt&gt; and &lt;tt&gt;=&lt;/tt&gt;.
There is no such pair here,
however,
so that
in this application,
the order makes no difference.
&lt;p&gt;
As you can see,
I am one of those who specify &lt;tt&gt;xms&lt;/tt&gt; for every
regex.
The symbol names preserve the surrounding single quotes.
This is convenient for processing,
and it also makes diagnostic messages involving
those symbols more comprehensible.
Finally, note that the &lt;tt&gt;reduce&lt;/tt&gt; operator is required to end on a word boundary.
&lt;h3&gt;The tokenizing engine&lt;/h3&gt;

&lt;div style=&quot;white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;&quot;&gt;
    my $rec = Marpa::R2::Recognizer-&gt;new( { grammar =&gt; $grammar } );

    my $length = length $string;
    pos $string = 0;
    TOKEN: while ( pos $string &lt; $length ) {

        # skip whitespace
        next TOKEN if $string =~ m/\G\s+/gcxms;

        # read other tokens
        TOKEN_TYPE: for my $t (@terminals) {
            next TOKEN_TYPE if not $string =~ m/\G($t-&gt;[1])/gcxms;
            if ( not defined $rec-&gt;read( $t-&gt;[0], $1 ) ) {
                die_on_read_problem( $rec, $t, $1, $string, pos $string );
            }
            next TOKEN;
        } ## end TOKEN_TYPE: for my $t (@terminals)

        die q{No token at &quot;}, ( substr $string, pos $string, 40 ),
            q{&quot;, position }, pos $string;
    } ## end TOKEN: while ( pos $string &lt; $length )
&lt;/div&gt;
&lt;p&gt;The calculator's token engine creates a
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;
recognizer
with the &lt;tt&gt;new()&lt;/tt&gt; constructor,
and feeds it tokens with the &lt;tt&gt;read()&lt;/tt&gt; method.
In this token engine,
I use Perl's progressive matching capabilities:
the
&lt;tt&gt;g&lt;/tt&gt; and
&lt;tt&gt;c&lt;/tt&gt; modifiers, the
&lt;tt&gt;\G&lt;/tt&gt; assertion and the
&lt;tt&gt;pos&lt;/tt&gt; function.
When writing a token engine,
there is, as the expression goes, more than one way
to do it,
many of them somewhat easier than this approach.
But progressive matching is powerful, efficient,
very flexible,
and it has the advantage that
it leaves the original string intact.
&lt;p&gt;
Those who go on to look at the
&lt;a href=&quot;https://gist.github.com/3521836&quot;&gt;
code in the gist&lt;/a&gt;
may find
&lt;tt&gt;die_on_read_problem()&lt;/tt&gt;,
the DSL's function for handling &lt;tt&gt;read()&lt;/tt&gt; errors,
helpful.
It produces a very specific and comprehensive error message.
One of
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;'s
greatest improvements over previous
parsers is that, when a parse fails,
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;
can explain why in considerable detail.
It makes sense to take full advantage of that ability.

&lt;h2&gt;Evaluating the parse&lt;/h2&gt;
&lt;p&gt;
&lt;div style=&quot;white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;&quot;&gt;

    my $value_ref = $rec-&gt;value;

    if ( !defined $value_ref ) {
        say $rec-&gt;show_progress() or die &quot;say failed: $ERRNO&quot;;
        die 'Parse failed';
    }
    return ${$value_ref};

&lt;/div&gt;
&lt;p&gt;Evaluation of the parse is done with the &lt;tt&gt;value()&lt;/tt&gt; method.
This can return all the parse results of an ambiguous parse.
We want only one parse here,
so we call &lt;tt&gt;value()&lt;/tt&gt; only once.
&lt;tt&gt;value()&lt;/tt&gt; returns a reference to the value of the parse,
and a Perl &lt;tt&gt;undef&lt;/tt&gt; if the parse failed.
The error handling is worth noticing.
One of
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;'s
strengths is that it is fully aware of which rules
are being tried at any point,
and of how far into those rules recognition has progressed.
The &lt;tt&gt;show_progress()&lt;/tt&gt; method reports that information.

&lt;h2&gt;OP2&lt;/h2&gt;
&lt;p&gt;
This ends our description of the calculator code.
In
&lt;a href=&quot;https://gist.github.com/3521836&quot;&gt;
the Github gist&lt;/a&gt;
a second DSL immediately follows the
calculator DSL.
This second DSL is OP2,
which is used to define the grammar for the calculator.
OP2 is more complicated than the calculator,
but its design is similar,
and it can be used as a second DSL example.
&lt;h2&gt;Alernatives&lt;/h2&gt;
&lt;h3&gt;Marpa::R2 verus Marpa::XS&lt;/h3&gt;
&lt;p&gt;This calculator uses
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;.
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;
is beta,
while
&lt;a href=&quot;https://metacpan.org/module/Marpa::XS&quot;&gt;
Marpa::XS&lt;/a&gt;
is in a stable, bug-fix only release.
On the other hand
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;
is somewhat faster,
and its reporting of parse-time problems is better.
&lt;h3&gt;Specifying the grammar&lt;/h3&gt;
The grammar of the calculator is specified in OP2,
which is a clear and elegant way to do it.
But OP2 is an experimental DSL created just for this
one use.
&lt;p&gt;
A more robust way to 
specify grammars is to do it directly in
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;.
OP2's grammar is specified directly in
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2&lt;/a&gt;.
A compromise between elegance and stability would be
to use OP2 (or a derivative)
to generate the rules (or some of them).
The OP2-generated rules can be used
as is, or edited to taste.
When you are happy with them,
Data::Dumper can turn the OP2-generated rules
into code,
which you can
then incorporate into your DSL program.
&lt;h3&gt;Error messages&lt;/h3&gt;
It is hard to compare
the quality of the
messages from these DSL's,
unfamiliar programs which explore new ground,
against, for example,
the comprehensibility of a C compiler's
error messages.
With the C compiler, I have the advantage of
over 40 years of Pavlovian training in guessing what
they really mean.
&lt;p&gt;
I believe that this DSL's error messages
are already, on average, up to the level
of typical production languages.
My main reason for this bold assertion is that
production parsers have set the bar,
frankly, extremely low.
I hasten to add,
this is often not because of lack of care or effort
by the implementers.
The traditional parsing technologies simply
do not provide enough information to support
accurate and helpful error reporting.
&lt;p&gt;
Much more could be done in error message handling
than is done by this calculator DSL.
&lt;a href=&quot;http://jeffreykegler.github.com/Marpa/&quot;&gt;
Marpa&lt;/a&gt;'s
situational awareness
makes much easier to write usefully
accurate error messages than has been the case.
And I find better error messages often repay a high priority,
even in programs that are strictly for personal use.</description>
  </item>
  </channel>
</rss>
