<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>A self-parsing and self-lexing grammar</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/self_lex.html</link>
    <description>  &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/self_parse.html&quot;&gt;In
      a previous post&lt;/a&gt;, I showed a self-parsing grammar,
      written in Marpa's new BNF interface.
      That grammar was in a tradition going back to the 70's.
      Following the tradition, I cheated a bit.
      That grammar required,
      but did not include, a lexer to make a prepass over
      its input.
      &lt;p&gt;
      This post contains a self-parsing
      and self-lexing grammar,
      the one for Marpa's forthcoming Scanless interface.
      This grammar is about as self-contained as a grammar can get,
      short of being encoded into a
      &lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Turing_machine&quot;&gt;Universal
      Turing machine&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Many readers will
      prefer to be introduced to the Scanless interface
      by way of
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.035_003/pod/Scanless.pod&quot;&gt;
      a simpler example&lt;/a&gt;,
      but based on the response to the previous post I know
      there are others who share my fascination with
      self-description and self-exemplification.
      And there is something to be said for reading an example
      that is a final authority on itself.
    &lt;/p&gt;
    &lt;p&gt;
      This is certainly a practical example.
      Thk grammar that follows is used
      to parse itself and all other grammars written for the
      Marpa's Scanless interface.
      It is also used to parse the strings written
      for Marpa's BNF interface,
      the Scanless interface's predecessor.
    &lt;/p&gt;
    &lt;h3&gt;Starting out&lt;/h3&gt;
    &lt;p&gt;
      The grammar in this blog post is abridged a bit,
      and rearranged for ease of explanation.
      The original is
      &lt;a href=&quot;https://metacpan.org/source/JKEGL/Marpa-R2-2.035_003/lib/Marpa/R2/meta/metag.bnf&quot;&gt;
      here&lt;/a&gt;.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
# Copyright 2012 Jeffrey Kegler
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The file starts with legalese, which I've cut.
    (The grammar is under GNU's LGPL 3.0.)
      Note the hash comment -- since this is a self-describing self-lexer,
      the grammar will eventually tell us how it deals with hash comments.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
:start ::= rules
rules ::= rule+
rule ::= &amp;lt;start rule&amp;gt;
  | &amp;lt;empty rule&amp;gt;
  | &amp;lt;priority rule&amp;gt;
  | &amp;lt;quantified rule&amp;gt;
  | &amp;lt;discard rule&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The &lt;tt&gt;rules&lt;/tt&gt;
      symbol is the start symbol.
      Our grammar consists of a series of one or more rules,
      each one of which falls into one of five types.
      &lt;/p&gt;
      &lt;p&gt;
      &lt;/p&gt;
      A few of the rules in our self-describing grammar are
      themselves self-describing.
      The last rule above is one of them: 
      it is a &lt;tt&gt;&amp;lt;priority rule&amp;gt;&lt;/tt&gt;,
      one of the 5 types it allows.
      The previous two lines exemplify two of the other possibilities:
      the first is a &lt;tt&gt;&amp;lt;start rule&amp;gt;&lt;/tt&gt;
      and the second is a &lt;tt&gt;&amp;lt;quantified rule&amp;gt;&lt;/tt&gt;.
      &lt;/p&gt;
      &lt;p&gt;
      A start rule is defined as
      consisting of the
      &lt;tt&gt;:start&lt;/tt&gt;
      pseudo-symbol,
      followed by a &lt;tt&gt;::=&lt;/tt&gt;
      operator,
      followed by a
      &lt;tt&gt;symbol&lt;/tt&gt;:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;start rule&amp;gt; ::= (':start' &amp;lt;op declare bnf&amp;gt;) symbol
&amp;lt;op declare bnf&amp;gt; ~ '::='
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;
      The parentheses can be ignored.
      Their purpose is to make life easier on the semantics
      -- they surround symbols
      that are hidden from the semantics.
    &lt;/p&gt;
    &lt;h3&gt;&quot;What I say&quot; versus &quot;what I mean&quot;&lt;/h3&gt;
    &lt;p&gt;When we define a grammar rule,
    sometimes we are asking Marpa to do exactly what
    we say, character for character.
    For example, in the 
&quot;&lt;tt&gt;&amp;lt;op declare bnf&amp;gt; ~ '::='&lt;/tt&gt;&quot; rule above,
we are saying that the symbol
&lt;tt&gt;&amp;lt;op declare bnf&amp;gt;&lt;/tt&gt; is exactly the string '::=' -- nothing more and nothing less.
&quot;Do exactly what I say&quot; rules are called lexical rules,
and for them we use the match operator (&quot;&lt;tt&gt;~&lt;/tt&gt;&quot;).
&lt;/p&gt;
&lt;p&gt;In other cases, we are asking Marpa to &quot;do what I mean&quot;.
That is, we are saying that &quot;the rule consists of these symbols, plus I want you
to do what is reasonable with whitespace and comments.&quot;
An example of that kind of rule was
&quot;&lt;tt&gt;rules ::= rule+&lt;/tt&gt;&quot;.
Within, between, before and after the &lt;tt&gt;rule&lt;/tt&gt;'s,
there will be comments and whitespace.
The whitespace is sometimes optional, sometimes required.
Spelling all this out would be very tedious.
So we want a type of rule that &quot;does what we mean&quot;.
That kind of rule is called a &quot;structural&quot; rule,
and identified by the BNF operator (&quot;&lt;tt&gt;::=&lt;/tt&gt;&quot;).
    &lt;p&gt;Some structural rules have lexical content within them.
    An example was
&quot;&lt;tt&gt;&amp;lt;start rule&amp;gt; ::= (':start' &amp;lt;op declare bnf&amp;gt;) symbol&lt;/tt&gt;&quot;.
That is basically a structural rule, where Marpa should &quot;do what I mean&quot;
with whitespace and comments.
But it contains a string, &lt;tt&gt;':start'&lt;/tt&gt;, which must be handled on a
&quot;do exactly what I say&quot; basis.
&lt;/p&gt;
&lt;p&gt;
For example, in &quot;&lt;tt&gt;:st art ::= rules&lt;/tt&gt;&quot;,
&quot;&lt;tt&gt;:st art&lt;/tt&gt;&quot; is not a valid way to specify
the &lt;tt&gt;:start&lt;/tt&gt; pseudo-symbol -- interior whitespace is not allowed
inside a symbol.
Whenever a structural rule contains lexical content,
like a string or a character class,
Marpa knows that it should treat the lexical content on a
lexical, &quot;do exactly what I say&quot;, basis.
&lt;/p&gt;
    &lt;p&gt;
    The &quot;what I mean&quot; versus &quot;what I say&quot; distinction
    corresponds very closely to the distinction in Perl 6 grammars
    between the &quot;rule&quot; and &quot;token&quot;.
    It also corresponds to the traditional division of labor in compilers,
    between the lexer and the parser proper.
    &lt;/p&gt;
    &lt;h3&gt;Rules&lt;/h3&gt;
    &lt;p&gt;Above we saw an example of a quantified rule: &quot;&lt;tt&gt;rules ::= rule+&lt;/tt&gt;&quot;.
    Here is the definition:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;quantified rule&amp;gt;
  ::= lhs &amp;lt;op declare&amp;gt;
    &amp;lt;single symbol&amp;gt; quantifier &amp;lt;adverb list&amp;gt;
lhs ::= &amp;lt;symbol name&amp;gt;
&amp;lt;op declare&amp;gt;
  ::= &amp;lt;op declare bnf&amp;gt; | &amp;lt;op declare match&amp;gt;
&amp;lt;op declare match&amp;gt; ~ '~'
quantifier ::= '*' | '+'
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      A quantified rule contains a left hand side (LHS) symbol name,
      one of the two declaration operators,
      a
      &lt;tt&gt;single symbol&lt;/tt&gt;,
      a plus or minus &quot;quantifier&quot;,
      and an adverb list.
      The adverb list can be empty, as it was in our example,
      and in fact has been in every rule so far.
    &lt;/p&gt;
    &lt;p&gt;
      Next come the two rule types that we've yet to see:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;discard rule&amp;gt;
  ::= (':discard' &amp;lt;op declare match&amp;gt;) &amp;lt;single symbol&amp;gt;
&amp;lt;empty rule&amp;gt; ::= lhs &amp;lt;op declare&amp;gt; &amp;lt;adverb list&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      We'll explain what a &quot;discard rule&quot; is when we encounter one.
      An empty rule indicates that its LHS symbol is nullable.
      We won't encounter an empty rule in this grammar.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;priority rule&amp;gt; ::= lhs &amp;lt;op declare&amp;gt; priorities
priorities ::= alternatives+
    separator =&amp;gt; &amp;lt;op loosen&amp;gt; proper =&amp;gt; 1
&amp;lt;op loosen&amp;gt; ~ '||'
alternatives ::= alternative+
    separator =&amp;gt; &amp;lt;op equal priority&amp;gt; proper =&amp;gt; 1
alternative ::= rhs &amp;lt;adverb list&amp;gt;
&amp;lt;op equal priority&amp;gt; ~ '|'
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Most rules, including most of the rules we've already seen,
      are priority rules.
      Priority rules are
      so-called because in their most complicated form they can express
      a precedence scheme.
      The typical rule in a grammar is a priority rule with only
      one priority -- a &quot;simple&quot; priority rule.
      All priority rules in this grammar will be of the simple kind.
      &lt;/p&gt;
      &lt;p&gt;
      Within priorities, there can be alternatives,
      and we have seen examples of these.
      The self-defining rule that defined a &lt;tt&gt;rule&lt;/tt&gt;
      stated that it was one of a set of 5 possible
      rule types (priority rule being among those types).
      In that self-defining rule,
      the different types of rule were alternatives within a single
      priority.
      &lt;p&gt;And, as long as we are on the subject of self-defining rules,
      there are two of them in this grammar.
      We have just seen the second of these.
      The definition of 
&lt;tt&gt;&amp;lt;priority rule&amp;gt;&lt;/tt&gt; is itself a priority rule.
    &lt;/p&gt;
    &lt;h3&gt;Symbols&lt;/h3&gt;
    &lt;p&gt;We've used
      &lt;tt&gt;symbol&lt;/tt&gt;,
      &lt;tt&gt;&amp;lt;symbol name&amp;gt;&lt;/tt&gt;,
      and
      &lt;tt&gt;&amp;lt;single symbol&amp;gt;&lt;/tt&gt;
      a few times.
      It's time to see how they are defined:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;single symbol&amp;gt; ::=
    symbol
  | &amp;lt;character class&amp;gt;
symbol ::= &amp;lt;symbol name&amp;gt;
&amp;lt;symbol name&amp;gt; ::= &amp;lt;bare name&amp;gt;
&amp;lt;symbol name&amp;gt; ::= &amp;lt;bracketed name&amp;gt;
&amp;lt;bare name&amp;gt; ~ [\w]+
&amp;lt;bracketed name&amp;gt; ~ '&amp;lt;' &amp;lt;bracketed name string&amp;gt; '&amp;gt;'
&amp;lt;bracketed name string&amp;gt; ~ [\s\w]+
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;At this point,
      &lt;tt&gt;symbol&lt;/tt&gt;
      and
      &lt;tt&gt;&amp;lt;symbol name&amp;gt;&lt;/tt&gt;
      are
      essentially the same thing:
      someday there may be another way to specify symbols
      other than by name.
      &lt;tt&gt;&amp;lt;single symbol&amp;gt;&lt;/tt&gt;
      means any expression guaranteed
      to produce a single symbol.
      &lt;tt&gt;symbol&lt;/tt&gt;
      is obviously one;
      a character class is the other.
    &lt;/p&gt;
    &lt;p&gt;The rules above contain our first mention
    of character classes and,
    by coincidence,
    our first use of character classes.
    Character classes are enclosed in square brackets,
    and look exactly like Perl character classes.
    In fact, they are implemented as Perl character classes, memoized for
    efficiency.
    &lt;/p&gt;
    &lt;p&gt;Now that we know what a symbol can be,
      let's look at how right hand sides are built up:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
rhs ::= &amp;lt;rhs primary&amp;gt;+
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;single symbol&amp;gt;
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;single quoted string&amp;gt;
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;parenthesized rhs primary list&amp;gt;
&amp;lt;parenthesized rhs primary list&amp;gt;
  ::= ('(') &amp;lt;rhs primary list&amp;gt; (')')
&amp;lt;rhs primary list&amp;gt; ::= &amp;lt;rhs primary&amp;gt;+
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;A right hand side (RHS) is a sequence of one or more RHS &quot;primaries&quot;.
A RHS primary can be a single symbol, a string in single quotes,
or a sublist of one or more RHS primaries in parentheses.
&lt;h3&gt;Adverbs&lt;/h3&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;adverb list&amp;gt; ::= &amp;lt;adverb item&amp;gt;*
&amp;lt;adverb item&amp;gt; ::=
      action
    | &amp;lt;left association&amp;gt;
    | &amp;lt;right association&amp;gt;
    | &amp;lt;group association&amp;gt;
    | &amp;lt;separator specification&amp;gt;
    | &amp;lt;proper specification&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Adverb lists are lists of zero or more adverbs, which can be of one of six kinds.
Of these six, four do not occur in this grammar:
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;left association&amp;gt; ::= ('assoc' '=&amp;gt;' 'left')
&amp;lt;right association&amp;gt; ::= ('assoc' '=&amp;gt;' 'right')
&amp;lt;group association&amp;gt; ::= ('assoc' '=&amp;gt;' 'group')
action ::= ('action' '=&amp;gt;') &amp;lt;action name&amp;gt;
&amp;lt;action name&amp;gt; ::= &amp;lt;bare name&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;
Three of the adverbs have to do with the associativity (right/left/group)
of priorities.
Since all our &quot;prioritized&quot; rules are trivial (have only one priority),
this grammar does not use them.
(Their use is described in
&lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
the documentation of Marpa's BNF interface&lt;/a&gt;.)
We also will not see &lt;tt&gt;action&lt;/tt&gt; adverbs in this grammar,
for reasons explained below.
&lt;/p&gt;
&lt;p&gt;
Here are two adverbs that we do see:
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;separator specification&amp;gt;
  ::= ('separator' '=&amp;gt;') &amp;lt;single symbol&amp;gt;
&amp;lt;proper specification&amp;gt; ::= ('proper' '=&amp;gt;') boolean
boolean ~ [01]
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;These adverbs are used for quantified rules.
One specifies a &quot;separator&quot; that can go between items of the series.
The other specifies whether separation is &quot;proper&quot; or not.
(When &lt;tt&gt;proper&lt;/tt&gt; is 0, a separator is allowed after the last item of a series.
When that is the case,
the separator does not really always separate two items
and in that sense the separator is not &quot;proper&quot;.)
&lt;h3&gt;Discarded tokens&lt;/h3&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
:discard ~ whitespace
whitespace ~ [\s]+
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;The two rules say that sequences of whitespace are recognized
as tokens, then discarded.
Perl-style comments are handled in the same way:
    &lt;blockquote&gt;
      &lt;pre&gt;
# allow comments
:discard ~ &amp;lt;hash comment&amp;gt;
&amp;lt;hash comment&amp;gt; ~ &amp;lt;terminated hash comment&amp;gt;
  | &amp;lt;unterminated final hash comment&amp;gt;
&amp;lt;terminated hash comment&amp;gt;
  ~ '#' &amp;lt;hash comment body&amp;gt; &amp;lt;vertical space char&amp;gt;
&amp;lt;unterminated final hash comment&amp;gt;
  ~ '#' &amp;lt;hash comment body&amp;gt;
&amp;lt;hash comment body&amp;gt; ~ &amp;lt;hash comment char&amp;gt;*
&amp;lt;vertical space char&amp;gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&amp;lt;hash comment char&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&quot;Unterminated final hash comments&quot; deal with the special
case of hash comments at the end of a file that is not properly
terminated with a newline.
The &lt;tt&gt;&amp;lt;unterminated final hash comment&amp;gt;&lt;/tt&gt; symbol is an example of how
a long angle bracketed symbol name can make things clearer.
Without the long name, it might not be evident what that rule and symbol
were trying to accomplish.
&lt;/p&gt;
&lt;p&gt;
Long symbol names
have a cleaner look than comments,
but they are not a panacea.
They have
the special advantage that the description goes wherever the symbol
name goes.
But when the description is too long,
that advantage becomes a disadvantage.
&lt;h3&gt;Strings&lt;/h3&gt;
&lt;p&gt;In the next snippet, defining single-quoted strings,
the description is clearly too long for the symbol name,
so much of it does go into a comment.
    &lt;blockquote&gt;
      &lt;pre&gt;
# In single quotes strings and character classes
# no escaping or internal newlines, and disallow empty string
&amp;lt;single quoted string&amp;gt;
  ~ ['] &amp;lt;string without single quote or vertical space&amp;gt; [']
&amp;lt;string without single quote or vertical space&amp;gt;
  ~ [^'\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]+
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Note two Unicode vertical whitespace codepoints,
U+2028 and U+2029, are included.
The implementation only supports 7-bit ASCII,
so for the moment these accomplish nothing.
But when Unicode support is added, the grammar won't need to be changed.
&lt;h3&gt;Character classes&lt;/h3&gt;
&lt;p&gt;Finally, there are character classes:
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;character class&amp;gt; ~ '[' &amp;lt;cc string&amp;gt; ']'
&amp;lt;cc string&amp;gt; ~ &amp;lt;cc character&amp;gt;+
&amp;lt;cc character&amp;gt; ~ &amp;lt;escaped cc character&amp;gt;
  | &amp;lt;safe cc character&amp;gt;
&amp;lt;escaped cc character&amp;gt; ~ '\' &amp;lt;horizontal character&amp;gt;

# hex 5d is right square bracket
&amp;lt;safe cc character&amp;gt;
  ~ [^\x{5d}\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]

# a horizontal character is any character that is not vertical space
&amp;lt;horizontal character&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;These are Perl character classes,
to be passed straight to Perl for intrepretation.
The grammar need only recognize strings enclosed by square brackets.
But it must deal with escaped square brackets,
and this is enough to make character
classes the most
complicated lexeme of the grammar.
    &lt;/p&gt;
&lt;h3&gt;Longest tokens matching&lt;/h3&gt;
&lt;p&gt;When there is a choice of lexicals, Marpa follows a longest tokens match strategy.
This means that it mostly does what you mean.
(In part this is because longest token match
is the usual default for regular expressions and
lexical analyzers, which means that programmers have been trained by their tools
to expect it.)
&lt;p&gt;This means that Marpa's Scanless interface will do that obvious stuff, like recognizing
that in &quot;&lt;tt&gt;weeknights ~ 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri'&lt;/tt&gt;&quot;, that
&lt;tt&gt;weeknights&lt;/tt&gt; is one symbol and not, for example, two symbols like
&quot;&lt;tt&gt;wee&lt;/tt&gt;&quot; and &quot;&lt;tt&gt;knights&lt;/tt&gt;&quot;.
It also means that if you have a grammar where you specify both &lt;tt&gt;++&lt;/tt&gt;
and &lt;tt&gt;+&lt;/tt&gt; as operators, Marpa will always prefer
the longer &lt;tt&gt;++&lt;/tt&gt;.
&lt;p&gt;Because this is Marpa, there is a slight difference from the traditional longest
&lt;b&gt;token&lt;/b&gt; matching.
Note that in Marpa's matching strategy, &quot;tokens&quot; is plural.
If more than one possibility has the same length, Marpa will try them all.
This does play a rule in our grammar.
For example, &lt;tt&gt;separator&lt;/tt&gt; is a keyword.
But it is also a valid symbol name.
Marpa allows it to be both, and figures out which is meant at the
structural level, based on context.
    &lt;h3&gt;Semantics&lt;/h3&gt;
    &lt;p&gt;The Scanless interface's meta-grammar, is unusual in its semantics
      because it serves a dual purpose -- it is also the grammar for Marpa's
      BNF interface, which has a different semantics.
      In practice, a grammar is usually tied tightly to one semantics,
      but this is an exception.
    &lt;/p&gt;&lt;p&gt;
      For most grammars in either the Marpa's BNF or Scanless interface,
      the semantics would be specified using
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs.
      For this grammar, there are no
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs -- internally,
      Marpa waits until it knows which interface the grammar will be used for,
      then uses the symbol names to determine the actions on a &quot;just in time&quot;
      basis.
    &lt;/p&gt;&lt;p&gt;
      Standard applications will
      labeling rules and alternatives with
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs.
      Example of this are in the documentation for the BNF
      and Scanless interfaces.
    &lt;/p&gt;&lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Smart whitespace and the Ruby Slippers</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/whitespace.html</link>
    <description>  &lt;h3&gt;Scannerless parsing&lt;/h3&gt;
    &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      I've been working
      on a &quot;scannerless&quot; Marpa interface.
      &quot;Scannerless&quot; means that the user does not need to write
      a separate lexer --
      the lexer (scanner) is included in the parser.
      One of my working examples is
      the synopsis from
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2&quot;&gt;
        the main Marpa::R2 POD page&lt;/a&gt;,
      rewritten to do its own lexing:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
:start ::= Expression
Expression ::=
       Number
    || Expression '*' Expression action =&gt; do_multiply
    || Expression '+' Expression action =&gt; do_add
Number ~ digits '.' digits action =&gt; do_literal
Number ~ digits action =&gt; do_literal
digits ~ [\d]+
    &lt;/tt&gt;
      &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;Here the notation is that of
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/iterative.html&quot;&gt;
        my last post&lt;/a&gt;,
      as
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
        documented here&lt;/a&gt;.
      New for the scannerless parser are
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;
        the
        &lt;tt&gt;:start&lt;/tt&gt;
        pseudo-symbol, which indicates the start rule;
      &lt;/li&gt;&lt;li&gt;
        rules with a tilde (&quot;&lt;tt&gt;~&lt;/tt&gt;&quot;) to separate
        LHS from RHS: these indicate rules whose
        whitespace is to be left as-is
      &lt;/li&gt;&lt;li&gt;single-quoted strings, to tell Marpa which
        character to look for; and
      &lt;/li&gt;&lt;li&gt;square-bracketed character classes, to
        tell Marpa to look for a class of characters.
        Their interpretation is done by Perl,
        and therefore the allowed classes are exactly those
        accepted by your version of Perl.
      &lt;/li&gt;&lt;/ul&gt;
    &lt;p&gt;
      Valid strings in this language are &quot;&lt;tt&gt;15329 + 42 * 290 * 711&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;42*3+7&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;3*3+4* 4&lt;/tt&gt;&quot;,
      along with all their whitespace variants.
    &lt;/p&gt;
    &lt;p&gt;My recent posts have been tutorial.
      My work on scannerless parsing is
      not quite ready for a tutorial presentation,
      so this post will be conceptual.
      It is about an interesting issue that arises in
      scannerless parsing,
      one which Perl 6 also had to solve,
      and which Marpa solves in a new and different way.
      That issue is whitespace.
    &lt;/p&gt;
    &lt;h3&gt;Dealing with whitespace&lt;/h3&gt;
    &lt;p&gt;For the statements with a declaration operator of
      &lt;tt&gt;::=&lt;/tt&gt;,
      whitespace is handled automatically by Marpa.
      Valid strings in the above language are
      &quot;&lt;tt&gt;42*3+7&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;42 * 3 + 7&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;42 * 3+7&lt;/tt&gt;&quot;,
      all of which yield 133 as the answer.
      The trick is to, on one hand, allow whitespace to be optional
      and, on the other hand, recognize that strings like &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;
      must be a single number.
      That is, the parser should not recognize optional whitespace
      between the two digits and decide that
      &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;,
      is actually two numbers:
      &quot;&lt;tt&gt;4&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;2&lt;/tt&gt;&quot;.
    &lt;/p&gt;
    &lt;p&gt;
      The Perl 6 project has already taken on scannerless parsing.
      My methods for dealing with whitespace are based on theirs.
      Central to
      their solution is &quot;smart whitespace&quot;.
      (&quot;Smart whitespace&quot; is my term --
      the
      &lt;a href=&quot;http://perlcabal.org/syn/S05.html&quot;&gt;
        Perl 6 doc&lt;/a&gt;
      is more matter-of-fact.)
      Smart whitespace is whitespace which is optional, except between
      word characters.
      Stated another way, smart whitespace is either explicit whitespace,
      or a word boundary.
      In the case of &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;4&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;2&lt;/tt&gt;&quot; are both word characters, so there is no
      word boundary between them, and therefore no smart whitespace.
    &lt;/p&gt;
    &lt;h3&gt;Implementing smart whitespace&lt;/h3&gt;
    &lt;p&gt;
      Left parsers (like that which Perl 6 uses)
      often know very little about the context of the parse.
      But left parsers do know the current &quot;character transition&quot; --
      what the previous character was,
      and what the current character is.
      In a left parser, finding word boundaries for the
      purpose of detecting smart whitespace fits in
      nicely with the way it works in general.
    &lt;/p&gt;
    &lt;p&gt;Marpa, of course,
      also knows the previous and current characters.
      It is certainly possible for
      Marpa to check every transition for a word boundary.
      But in Marpa's case, this check would
      be an additional overhead, handling just one special case.
      It'd be nice if we could look for word boundaries in a cool Marpa-ish way,
      preferably one with efficiency advantages.
    &lt;/p&gt;
    &lt;h3&gt;Out come the Ruby Slippers&lt;/h3&gt;
    &lt;p&gt;&quot;Ruby Slippers&quot; parsing, as a reminder, is new with Marpa,
      despite seeming a very obvious concept.
      It amounts to adjusting the input to the parser based on what
      the parser wants.
      This can be seen as assuring the parser that whatever it wishes
      for will happen, the same power that was conferred on Dorothy
      in
      &lt;em&gt;Wizard of Oz&lt;/em&gt;
      by a happy choice of footware.
    &lt;/p&gt;
    &lt;p&gt;
      To make the Ruby Slippers work in this case,
      we make a word boundary a special kind of virtual token,
      and we define smart whitespace to be one of two things:
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;
        A sequence of one or more characters of
        real, physical whitespace.
      &lt;/li&gt;&lt;li&gt;
        A virtual word-boundary token.
      &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;
      We then proceed normally with the parse,
      until there's a problem.
      When the parser reports a problem,
      we ask it if it is looking for one
      of the virtual word boundary tokens.
      If so, we give it one and continue.
      Why does life have to be difficult?
    &lt;/p&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Announcing a full release of Marpa::R2</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/announce_r2.html</link>
    <description>  &lt;h3&gt;Announcing Marpa::R2&lt;/h3&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;p&gt;
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
        Marpa::R2&lt;/a&gt;
      is now in full, official release.
      For those new to this blog, Marpa::R2 is an efficient, practical general
      BNF parser, targeted at applications too complex for
      regular expressions.
      Marpa::R2 is based on
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa-web-site/&quot;&gt;
        the Marpa parsing algorithm&lt;/a&gt;.
      New, but squarely based on the published literature,
      the Marpa algorithm
      parses every class of grammar in practical use today
      in linear time.
    &lt;/p&gt;
    &lt;p&gt;Marpa::R2 is the successor to Marpa::XS and
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;installs and runs on Windows.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;has better error reporting.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;is faster.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;
          has a cleaner, simpler interface.
        &lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
    &lt;a href=&quot;https://metacpan.org/module/Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;
    remains available and,
      since changes to it are now on a &quot;bug fix only&quot; basis,
      should be quite stable.
      While Marpa::R2's interface will have a familiar look
      to users of Marpa::XS, it is not fully compatible:
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::Changes&quot;&gt;
      changes are documented here&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Those who have been following this blog may have noticed
      that
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
      a new BNF interface&lt;/a&gt;
      has been added to Marpa::R2.
      This is growing --
      I am currently adding scannerless parsing to it,
      which means that applications will be able to run
      Marpa::R2 without a lexer.
      Because the BNF interface is new
      and still under very active development,
      it is being kept in beta status for the time being.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      The Windows port of Marpa was the work of Jean-Damien Durand,
      who utilized Alberto Sim&amp;otilde;es'
      &lt;a href=&quot;http://search.cpan.org/dist/Config-AutoConf/&quot;&gt;
        Config::AutoConf&lt;/a&gt;.
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>A Marpa tutorial: iterative parser development</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/iterative.html</link>
    <description>  &lt;h3&gt;Developing a parser iteratively&lt;/h3&gt;
    &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      This post describes a manageable way
      to write a complex parser,
      a little bit at a time, testing as you go.
      This tutorial will &quot;iterate&quot; a parser
      through one development step.
      As the first iteration step,
      we will use the example parser from
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/pattern_search.html&quot;&gt;
        the previous tutorial in this series&lt;/a&gt;,
      which parsed a Perl subset.
    &lt;/p&gt;
    &lt;p&gt;
      You may recall that the topic of that previous tutorial was pattern search.
      Pattern search and iterative parser development are
      essentially the same thing,
      and the same approach can be used for both.
      Each development stage of our Perl parser will do a pattern search
      for the Perl subset it parses.
      We can use the accuracy of this pattern search
      to check our progress.
      The subset we are attempting to parse is our &quot;search target&quot;.
      When our &quot;searches&quot; succeed in finding all instances
      of the target,
      we have successfully written a parser for that subset,
      and can move on to the next step of the iteration.
    &lt;/p&gt;
    &lt;h3&gt;What we need to do&lt;/h3&gt;
    &lt;p&gt;
      This tutorial is the latest of
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL&quot;&gt;
        a series&lt;/a&gt;,
      each of which describes one self-contained example of a Marpa-based parser.
      In this tutorial we use the example from
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/pattern_search.html&quot;&gt;
        the previous tutorial&lt;/a&gt;
      as the first iteration step
      in the iterative development of a Perl parser.
      For the iteration step in this example, we will add two features.
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;&lt;p&gt;The previous iteration step was more of a recognizer than a parser.
          In particular, its grammar was too simplified to support a semantics,
          even for the Perl subset it recognized.
          We will fix that.
        &lt;/p&gt;&lt;/li&gt;&lt;li&gt;Having amplified the grammar, we will add a semantics,
        simple, but quite powerful enough to use in checking our progress
        in developing the parser.
      &lt;/li&gt;&lt;/ul&gt;
    &lt;h3&gt;The grammar&lt;/h3&gt;
    &lt;p&gt;
    Here is our grammar from the previous post:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
start ::= prefix target
prefix ::= any_token*
target ::= expression
expression ::=
       number | scalar | scalar postfix_op
    || op_lparen expression op_rparen assoc =&amp;gt; group
    || unop expression
    || expression binop expression
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;&lt;p&gt;
    &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
      The format is documented here&lt;/a&gt;.
      These eight lines were enough to descibe arithmetic expressions sufficiently well
      for a recognizer, as well as to provide the &quot;scaffolding&quot; for the unanchored search.
      Nice compression, but now that we are talking about supporting a Perl semantics,
      we will need more.
    &lt;/p&gt;&lt;p&gt;Adding the appropriate grammar is a matter of turning to the
      &lt;a href=&quot;http://perldoc.perl.org/perlop.html#Operator-Precedence-and-Associativity&quot;&gt;
        appropriate section of the
        &lt;tt&gt;perlop&lt;/tt&gt;
        man page&lt;/a&gt;
      and copying it.
      I needed to change the format and name the operators,
      but the process was pretty much rote, as you can see:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
my $perl_grammar = Marpa::R2::Grammar-&amp;gt;new(
    {   start          =&amp;gt; 'start',
        actions        =&amp;gt; 'main',
        default_action =&amp;gt; 'do_what_I_mean',
        rules          =&amp;gt; [ &amp;lt;&amp;lt;'END_OF_RULES' ]
start ::= prefix target action =&amp;gt; do_arg1
prefix ::= any_token* action =&amp;gt; do_undef
target ::= expression action =&amp;gt; do_target
expression ::=
     number
   | scalar
   | op_lparen expression op_rparen assoc =&amp;gt; group
  || op_predecrement expression
   | op_preincrement expression
   | expression op_postincrement
   | expression op_postdecrement
  || expression op_starstar expression assoc =&amp;gt; right
  || op_uminus expression
   | op_uplus expression
   | op_bang expression
   | op_tilde expression
  || expression op_star expression
   | expression op_slash expression
   | expression op_percent expression
   | expression kw_x expression
  || expression op_plus expression
   | expression op_minus expression
  || expression op_ltlt expression
   | expression op_gtgt expression
  || expression op_ampersand expression
  || expression op_vbar expression
   | expression op_caret expression
  || expression op_equal expression assoc =&amp;gt; right
  || expression op_comma expression
END_OF_RULES
    }
);
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;h3&gt;The lexer&lt;/h3&gt;
    &lt;p&gt;
      The lexer is table-driven.
      I've used this same approach to lexing in every post
      in this tutorial series.
      Those interested in
      an explanation of how the lexer works can
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html&quot;&gt;
        find one in the first tutorial&lt;/a&gt;.
      Having broken out the operators, I had to rewrite
      the lexing table,
      but that was even more rote than rewriting
      the grammar.
      I won't repeat the
      lexer table here --
      it can be found in
      &lt;a href=&quot;https://gist.github.com/4093504&quot;&gt;the Github gist&lt;/a&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Adding the semantics&lt;/h3&gt;
    &lt;p&gt;Our semantics will create a syntax tree.
      Here is that logic.
      (Note that the first argument to these semantic closures
      is a per-parse &quot;object&quot;,
      which we don't use here.)
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
sub do_undef       { undef; }
sub do_arg1        { $_[2]; }
sub do_what_I_mean { shift; return $_[0] if scalar @_ == 1; return \@_ }

sub do_target {
    my $origin = ( Marpa::R2::Context::location() )[0];
    return if $origin != $ORIGIN;
    return $_[1];
} ## end sub do_target
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      There is some special logic in the
      &lt;tt&gt;do_target()&lt;/tt&gt;
      method,
      involving the &quot;origin&quot;, or starting location of the target.
      Perl arithmetic expressions,
      when they are the target of an unanchored search,
      are ambiguous.
      For example, in the string &quot;&lt;tt&gt;abc 1 + 2 + 3 xyz&lt;/tt&gt;&quot;,
      there are two targets ending at the same position:
      &quot;&lt;tt&gt;2 + 3&lt;/tt&gt;&quot; and &quot;&lt;tt&gt;1 + 2 + 3&lt;/tt&gt;&quot;.
      We are interested only in longest of these,
      whose start location is indicated by the
      &lt;tt&gt;$ORIGIN&lt;/tt&gt;
      variable.
    &lt;/p&gt;&lt;p&gt;The next logic will be familiar from our
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/pattern_search.html&quot;&gt;
        pattern search tutorial&lt;/a&gt;.
      It repeatedly looks for non-overlapping occurrences of
      &lt;tt&gt;target&lt;/tt&gt;,
      starting from the end and going back to the beginning of the input.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
my $end_of_search;
my @results = ();
RESULTS: while (1) {
    my ( $origin, $end ) =
        $self-&amp;gt;last_completed_range( 'target', $end_of_search );
    last RESULTS if not defined $origin;
    push @results, [ $origin, $end ];
    $end_of_search = $origin;
} ## end RESULTS: while (1)
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;This final code sample is the logic
      that unites pattern search with incremental
      parsing.
      It is a loop through
      &lt;tt&gt;@results&lt;/tt&gt;
      that prints the original text
      and, depending on a flag,
      its syntax tree.
    &lt;/p&gt;
    &lt;p&gt;
      Near the top of the loop,
      the &quot;&lt;tt&gt;$recce-&amp;gt;set( { end =&amp;gt; $end } )&lt;/tt&gt;&quot;
      call sets the end of parse location to the current
      result.
      At the bottom of the loop,
      we call
      &quot;&lt;tt&gt;$recce-&amp;gt;reset_evaluation()&lt;/tt&gt;&quot;.
      This is necessary to allow us to evaluate the
      input stream again, but with a new
      &lt;tt&gt;$end&lt;/tt&gt;
      location.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
RESULT: for my $result ( reverse @results ) {
    my ( $origin, $end ) = @{$result};

    &lt;big&gt;&lt;b&gt;... Print out the original text ...&lt;/b&gt;&lt;/big&gt;

    $recce-&amp;gt;set( { end =&amp;gt; $end } );
    my $value;
    VALUE: while ( not defined $value ) {
        local $main::ORIGIN = $origin;
        my $value_ref = $recce-&amp;gt;value();
        last VALUE if not defined $value_ref;
        $value = ${$value_ref};
    } ## end VALUE: while ( not defined $value )
    if ( not defined $value ) {
        say 'No parse'
            or die &quot;say() failed: $ERRNO&quot;;
        next RESULT;
    }
    say Data::Dumper::Dumper($value)
        or die &quot;say() failed: $ERRNO&quot;
        if not $quiet_flag;
    $recce-&amp;gt;reset_evaluation();
} ## end RESULT: for my $result ( reverse @results )
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;The
      &lt;tt&gt;VALUE&lt;/tt&gt;
      sub-loop is
      where the
      &lt;tt&gt;$ORIGIN&lt;/tt&gt;
      variable
      was set.
      In the semantics,
      &lt;tt&gt;do_target()&lt;/tt&gt;
      checks this.
      In the case of an ambiguous parse,
      &lt;tt&gt;do_target()&lt;/tt&gt;
      turns any target which does not
      cover the full span from
      &lt;tt&gt;$origin&lt;/tt&gt;
      to
      &lt;tt&gt;$end&lt;/tt&gt;
      into a Perl
      &lt;tt&gt;undef&lt;/tt&gt;,
      which will
      eventually become
      the value of its parse.
      The logic in the
      &lt;tt&gt;VALUE&lt;/tt&gt;
      loop
      ignores parses whose value is a Perl &lt;tt&gt;undef&lt;/tt&gt;,
      so that only the longest target for each
      &lt;tt&gt;$end&lt;/tt&gt;
      location is printed.
    &lt;/p&gt;
    &lt;h3&gt;Code and comments&lt;/h3&gt;
    &lt;p&gt;The example in this post is available as
      &lt;a href=&quot;https://gist.github.com/4093504&quot;&gt;a Github gist&lt;/a&gt;.
      It was run with
      &lt;a href=&quot;https://metacpan.org/release/JKEGL/Marpa-R2-2.024000/&quot;&gt;
        Marpa::R2 2.024000&lt;/a&gt;,
      as of this writing the latest full release.
      Its main test, which is included in the gist,
      used displays from the
      &lt;a href=&quot;http://perldoc.perl.org/perlop.html&quot;&gt;perlop man page&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>A Marpa tutorial: pattern searches</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/pattern_search.html</link>
    <description>  &lt;h3&gt;Pattern searches&lt;/h3&gt;
    &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      We use regular expressions for pattern searching these days.
      But what if your search target is not a regular expression?
      In this post I will show how to use Marpa to search text files for
      arbitrary context-free expressions.
    &lt;/p&gt;
    &lt;p&gt;
      This tutorial builds on earlier tutorials.
      It is possible to simply dive into it,
      but it may be easier
      to start with two of my earlier posts,
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html&quot;&gt;here&lt;/a&gt;
      and
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/error.html&quot;&gt;here&lt;/a&gt;.
    &lt;/p&gt;
    &lt;h3&gt;The grammar&lt;/h3&gt;
    &lt;p&gt;
      I will use arithmetic expressions as
      the example of a search target.
      Even the arithmetic subset of Perl expressions is quite complex,
      but in this case we can get the job done
      with eight lines of grammar and a lexer driven
      by a table of just over a dozen lines.
      Here is the grammar:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
start ::= prefix target
prefix ::= any_token*
target ::= expression
expression ::=
       number | scalar | scalar postfix_op
    || op_lparen expression op_rparen assoc =&amp;gt; group
    || unop expression
    || expression binop expression`
    &lt;/tt&gt;
    &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      This grammar uses
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
        Marpa::R2's BNF interface&lt;/a&gt;.
      It takes considerable advantage of the fact that we are not
      &lt;b&gt;parsing&lt;/b&gt;
      these expressions, but
      &lt;b&gt;recognizing&lt;/b&gt;
      them.
      Because of this, we don't have to specify whether expressions left- or right-associate.
      We can also ignore what operators mean and group them according to syntax only
      -- binary, prefix unary and postfix unary.
      Similarly, we can ignore the precedence within these large groups.
      This leaves us with numbers, scalars,
      parentheses,
      and binary, prefix unary and postfix unary operators.
      (To keep this example simple, we restrict the primaries
      to numeric constants and Perl scalars.)
    &lt;/p&gt;
    &lt;p&gt;
      What we are searching for is defined by the
      &lt;tt&gt;target&lt;/tt&gt;
      symbol.
      For
      &lt;tt&gt;target&lt;/tt&gt;
      you could substitute
      the start symbol of
      any context-free grammar,
      and the structure of this example will still work.
      To turn a parser for
      &lt;tt&gt;target&lt;/tt&gt;
      into a pattern searcher, we add a new start
      symbol (unimaginatively named &quot;&lt;tt&gt;start&lt;/tt&gt;&quot;)
      and two rules that
      allow the target to have a
      &lt;tt&gt;prefix&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Ambiguous parsing&lt;/h3&gt;
    &lt;p&gt;To do an anchorless pattern search,
      this example will use ambiguous parsing.
      This grammar always has at least one parse going,
      representing the prefix for
      the zero or more targets
      that our parser
      expects to find in the future.
      The prefix will never end, because
      any token (as indicated by a token
      named, literally,
      &lt;tt&gt;any_token&lt;/tt&gt;)
      extends it.
    &lt;/p&gt;
    &lt;p&gt;
      If we are in the process of recognizing a
      &lt;tt&gt;target&lt;/tt&gt;,
      we will have one or more other parses going.
      I say &quot;one or more&quot; because the search method
      described in this post
      allows &lt;tt&gt;target&lt;/tt&gt; to be ambiguous.
      But arithmetic expressions,
      the target pattern used in this example,
      are not ambiguous.
      So our example will have
      at most two parses active at any point:
      one for the prefix and another for the target.
    &lt;/p&gt;
    &lt;p&gt;
      Ambiguous parsing has a serious potential downside --
      it is not necessarily linear
      and therefore not necessarily efficient.
      But Marpa can parse many classes of ambiguous grammar in linear time.
      Grammars like the one in this post --
      a prefix and an unambiguous search target --
      fall into one of the linearly parseable classes.
      Keeping the prefix going requires a tiny constant overhead per token.
    &lt;/p&gt;
    &lt;h3&gt;The lexer table&lt;/h3&gt;
    &lt;p&gt;
      The lexer is driven by a table of pairs: token name and regex.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&lt;tt&gt;
my @lexer_table = (
    [ number     =&amp;gt; qr/(?:\d+(?:\.\d*)?|\.\d+)/xms ],
    [ scalar     =&amp;gt; qr/ [\$] \w+ \b/xms ],
    [ postfix_op =&amp;gt; qr/ [-][-] | [+][+] /xms ],
    [ unop       =&amp;gt; qr/ [-][-] | [+][+] /xms ],
    [   binop =&amp;gt; qr/
          [*][*] | [&amp;gt;][&amp;gt;] | [&amp;lt;][&amp;lt;]
        | [*] | [\/] | [%] | [x] \b
        | [+] | [-] | [&amp;amp;] | [|] | [=] | [,]
    /xms
    ],
    [   unop =&amp;gt; qr/ [-] | [+] | [!] | [~] /xms
    ],
    [ op_lparen =&amp;gt; qr/[(]/xms ],
    [ op_rparen =&amp;gt; qr/[)]/xms ],
);
&lt;/tt&gt;
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      Order is significant here.
      In particular
      two-character operators are checked for first.
      This guarantees that
      two consecutive minus signs
      will be seen as an
      decrement operator, and not as a double negation.
    &lt;/p&gt;
    &lt;h3&gt;Ambiguous lexing&lt;/h3&gt;
    &lt;p&gt;The very careful reader may have noticed that
      &lt;tt&gt;any_token&lt;/tt&gt;
      is not in the lexing table.
      The main loop is written so that every token is read as an
      &lt;tt&gt;any_token&lt;/tt&gt;.
      If no token from the lexing table is accepted,
      the next character in the input stream
      is read as an
      &lt;tt&gt;any_token&lt;/tt&gt;.
      If a token from the lexing table
      &lt;b&gt;is&lt;/b&gt;
      accepted,
      then it gets read twice,
      once as an
      &lt;tt&gt;any_token&lt;/tt&gt;,
      and once as the token type taken from the lexing table
      entry.
    &lt;/p&gt;
    &lt;p&gt;Ambiguous lexing is a familiar technique to
      the Natural Language Processing community.
      Engish, in particular, is a language that abounds
      in lexemes that can play multiple roles.
      The word &quot;sort&quot;, for example, can easily be
      an noun, a verb or an adjective.
    &lt;/p&gt;
    &lt;h3&gt;The Ruby Slippers&lt;/h3&gt;
    &lt;p&gt;The main loop will also be a simple case of the use
      of the Ruby Slippers.
      For those unfamiliar,
      the &quot;Ruby Slippers&quot; parsing technique handles difficult lexing
      and parsing problems by asking the parser, at the problem point,
      what it is looking for,
      and providing it.
      This seems a fairly obvious approach,
      but the Ruby Slippers are new with Marpa --
      traditional parsers could not easily
      determine where they were in a parse.
    &lt;/p&gt;
    &lt;p&gt;
      One way to use the Ruby Slippers is to ask the parser in
      advance what it is looking for.
      The code that follows uses another method.
      Instead of determining in advance what tokens to read,
      it simply feeds tokens to the parser.
    &lt;/p&gt;
    &lt;p&gt;
      Token rejection is a &quot;soft&quot; error -- it costs
      little to try, and little to retry.
      The following code can
      efficiently determine which entry in the lexing table is appropriate,
      simply by trying each of them in order.
      If the
      &lt;tt&gt;alternative()&lt;/tt&gt;
      method returns a Perl
      &lt;tt&gt;undef&lt;/tt&gt;,
      indicating that a token was rejected,
      then the main loop will try later entries in the lexing table.
    &lt;/p&gt;
    &lt;p&gt;
      When a token is accepted,
      the main loop can safely assume that it is on the right track.
      Marpa is 100% accurate about
      which tokens can and cannot result in a successful parse.
    &lt;/p&gt;
    &lt;h3&gt;The main loop&lt;/h3&gt;
    &lt;p&gt;
      The main loop iterates through input looking for tokens.
      Whitespace is skipped.
      Comments are not skipped.
      Finding arithmetic expressions in
      strings and/or comments can be useful.
      We will assume that is the case here.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&lt;tt&gt;
my $length = length $string;
pos $string = $positions[-1];
TOKEN: while ( pos $string &amp;lt; $length ) {
    next TOKEN if $string =~ m/\G\s+/gcxms;    # skip whitespace
    my $position = pos $string;
    FIND_ALTERNATIVE: {
        TOKEN_TYPE: for my $t (@lexer_table) {
            my ( $token_name, $regex ) = @{$t};
            next TOKEN_TYPE if not $string =~ m/\G($regex)/gcxms;
            if ( not defined $recce-&amp;gt;alternative($token_name) ) {
                pos $string = $position;       # reset position for matching
                next TOKEN_TYPE;
            }
            $recce-&amp;gt;alternative('any_token');
            last FIND_ALTERNATIVE;
        } ## end TOKEN_TYPE: for my $t (@lexer_table)
        ## Nothing in the lexer table matched
        ## Just read the currrent character as an 'any_token'
        pos $string = $position + 1;
        $recce-&amp;gt;alternative('any_token');
    } ## end FIND_ALTERNATIVE:
    $recce-&amp;gt;earleme_complete();
    my $latest_earley_set_ID = $recce-&amp;gt;latest_earley_set();
    $positions[$latest_earley_set_ID] = pos $string;
} ## end TOKEN: while ( pos $string &amp;lt; $length )
&lt;/tt&gt;
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;
      The
      &lt;tt&gt;earleme_complete()&lt;/tt&gt;
      method tells Marpa that all the alternatives
      at one location have been entered,
      and that the parse should now move on to the next location.
      (Marpa's idea of location is called an &quot;earleme&quot;, in honor of the great
      parsing theorist, Jay Earley.)
    &lt;/p&gt;
    &lt;h3&gt;How to parse without really trying&lt;/h3&gt;
    &lt;p&gt;
    At this point, I want to draw the reader's attention to the code
    that deals with special cases for the minus sign.
    Specifically, to the fact that there is no such code.
    The more familiar you are with PPI and/or
      &lt;tt&gt;perly.y&lt;/tt&gt;,
      the more remarkable this will seem.
      &lt;/p&gt;
      &lt;p&gt;
      To take one example, PPI correctly realizes that the minus
      sign in
      &quot;&lt;tt&gt;1+2-3&lt;/tt&gt;&quot; is a binary operator.
      However PPI fails on &quot;&lt;tt&gt;(1+2)-3&lt;/tt&gt;&quot; --
      it thinks the minus sign is part of the number &quot;-3&quot;.
      Why don't the authors of PPI just look at the Perl
      interpreter and copy the logic there?
      Take a glance at &lt;tt&gt;perly.y&lt;/tt&gt;
      and &lt;tt&gt;toke.c&lt;/tt&gt; 
      and you will know the answer to that question.
      &lt;/p&gt;
      &lt;p&gt;What is PPI's problem here?
      The problem is that,
      without knowing where you are in the expression,
      you cannot tell whether a minus sign is a unary
      operator or a binary operator.
      And the parse engines for PPI and for Perl itself,
      while quite different in many respects,
      share a property common to traditional parsers --
      in determining context
      they offer the lexer, respectively,
      little and no help.
      &lt;/p&gt;
      &lt;p&gt;
      In the code in this example,
      Marpa's &lt;tt&gt;alternative()&lt;/tt&gt; method is, by accepting
      and rejecting tokens, guiding the lexer to the right choice.
      Because of Perl's grammar, a minus sign at a given position
      cannot be both a unary operator and a binary operator.
      And Marpa is 100% accurate in its knowledge of which
      tokens are possible.
      So Marpa's
      &lt;tt&gt;alternative()&lt;/tt&gt; method
      always knows whether a minus sign can be
      a unary or binary operator and accepts
      or rejects the token accordingly.
    &lt;/p&gt;
    &lt;p&gt;
      This is the Ruby Slippers in action --
      a very simple solution to what for the Perl
      interpreter and PPI
      is a very complicated problem.
      When I developed the Ruby Slippers technique,
      my most serious problem 
      was convincing myself that something
      so simple could really work.
    &lt;/p&gt;
    &lt;h3&gt;Finding the targets&lt;/h3&gt;
    &lt;p&gt;
      Once the parse is complete, it remains to find
      and print the &quot;targets&quot; found
      by the search.
      In
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/error.html&quot;&gt;
      a previous post&lt;/a&gt;,
      I showed how, 
      given a symbol name,
      to find the last occurrence of the symbol in a Marpa parse.
      That routine needed to be modified to allow repeated searches,
      but the change was straightforward.
      The code is in the
      &lt;a href=&quot;https://gist.github.com/4057239&quot;&gt;
      gist&lt;/a&gt;,
      and the ideas behind it were explained
      in
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/error.html&quot;&gt;
      the previous post&lt;/a&gt;,
      so I won't repeat them here.
    &lt;/p&gt;
    &lt;h3&gt;Code and comments&lt;/h3&gt;
    &lt;p&gt;The example in this post is available as
    &lt;a href=&quot;https://gist.github.com/4057239&quot;&gt;
      a Github gist&lt;/a&gt;.
      It was run with
      &lt;a href=&quot;https://metacpan.org/release/JKEGL/Marpa-R2-2.024000/&quot;&gt;
      Marpa::R2 2.024000&lt;/a&gt;,
      as of this writing the latest full release.
      My main test, which is included in the gist,
      used displays from the
      &lt;a href=&quot;http://perldoc.perl.org/perlop.html&quot;&gt;perlop man page&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  </channel>
</rss>
