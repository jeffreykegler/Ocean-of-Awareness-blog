<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Reporting mismatched delimiters</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/delimiter.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;p&gt;In many contexts, programs need to identify
      non-overlapping pieces of a text.
      One very direct way to do this
      is to use a pair of delimiters.
      One delimiter of the pair marks the start
      and the other marks the end.
      Delimiters can take many forms:
      Quote marks, parentheses, curly braces, square brackets,
      XML tags, and HTML tags
      are all delimiters in this sense.
    &lt;/p&gt;
    &lt;p&gt;
      Mismatching delimiters is easy to do.
      Traditional parsers are often poor at reporting these errors:
      hopeless after the first mismatch,
      and for that matter none too precise about the first one.
      This post outlines a scaleable method for the accurate
      reporting of mismatched delimiters.
      I will illustrate the method with a simple
      but useable tool --
      a utility which reports mismatched brackets.
    &lt;/p&gt;
    &lt;h3&gt;The example script&lt;/h3&gt;
    &lt;p&gt;The
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;example
      script&lt;/a&gt;,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;,
      reports mismatched brackets in the set:
    &lt;/p&gt;
    &lt;blockquote&gt;&lt;pre&gt;() {} []&lt;/pre&gt;&lt;/blockquote&gt;
      &lt;p&gt;
      They are expected to nest without overlaps.
      Other text is treated as filler.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is not smart about things
      like strings or comments.
      This does have the advantage of making
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      mostly language-agnostic.
    &lt;/p&gt;
    &lt;p&gt;
      Because it's intended primarily to be read
      as an illustration of the technique,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s grammar
      is a basic one.
      The grammar that
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses is so simple that
      an emulator of &lt;tt&gt;bracket.pl&lt;/tt&gt;
      could be written using recursive descent.
      I hope the reader who goes on to look into the details
      will see that this technique scales to more
      complex situations,
      in a way that a solution based on a traditional parser
      will not.
    &lt;/p&gt;
    &lt;h3&gt;Error reports&lt;/h3&gt;
    &lt;p&gt;The description of how the method works will make more
      sense after we've looked at some examples of the diagnostics
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      produces.
      To be truly useful,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      must report mismatches that span
      many lines,
      and it can do this.
      But single-line examples are easier to follow.
      All the examples in this post will be contained in a one line.
      Consider the string '&lt;tt&gt;((([))&lt;/tt&gt;'.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s diagnostics are:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Opening '(' never closed, problem detected at end of string
((([))
^
====================
* Line 1, column 4: Missing close ], problem detected at line 1, column 5
((([))
   ^^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      In the next example
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      realizes that it
      cannot accept the ')' at column 16, without first closing the set of curly braces started at column 5.
      It identifies the problem, along with both of the locations involved.
    &lt;/p&gt;
    &lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 5: Missing close }, problem detected at line 1, column 16
[({({x[]x{}x()x)})]
    ^          ^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      So far, so good.
      But an important advantage of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      has yet to be seen.
      Most compilers,
      once they report a first mismatched delimiter,
      produce error messages that are
      unreliable --
      so unreliable that they are useless in practice.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      repairs a mismatched bracket before continuing,
      so that it can do a reasonable job of analyzing the text
      that follows.
      Consider the text
      '&lt;tt&gt;({]-[(}-[{)&lt;/tt&gt;'.
      The output of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Missing close ), problem detected at line 1, column 3
({]-[(}-[{)
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
({]-[(}-[{)
 ^^
====================
* Line 1, column 3: Missing open [
({]-[(}-[{)
  ^
====================
* Line 1, column 5: Missing close ], problem detected at line 1, column 7
({]-[(}-[{)
    ^ ^
====================
* Line 1, column 6: Missing close ), problem detected at line 1, column 7
({]-[(}-[{)
     ^^
====================
* Line 1, column 7: Missing open {
({]-[(}-[{)
      ^
====================
* Line 1, column 9: Missing close ], problem detected at line 1, column 11
({]-[(}-[{)
        ^ ^
====================
* Line 1, column 10: Missing close }, problem detected at line 1, column 11
({]-[(}-[{)
         ^^
====================
* Line 1, column 11: Missing open (
({]-[(}-[{)
          ^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;Each time,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      corrects itself,
      and accurately reports the next set of problems.
    &lt;/p&gt;&lt;h3&gt;A difficult error report&lt;/h3&gt;
    &lt;p&gt;
      To be 100% accurate,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      would have to guess the programmer's intent.
      This is, of course, not possible.
      Let's look at a text where
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s guesses are not so good:
      &lt;tt&gt;{{]}&lt;/tt&gt;.
      Here we will assume the closing square bracket is a typo for a closing parenthesis.
      Here's the result:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Missing close }, problem detected at line 1, column 3
{{]}
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
{{]}
 ^^
====================
* Line 1, column 3: Missing open [
{{]}
  ^
====================
* Line 1, column 4: Missing open {
{{]}
   ^
&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      Instead of one error,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      finds four.
    &lt;/p&gt;&lt;p&gt;
      But even in this case, the method is fairly good, especially when
      compared with current practice.
      The problem is at line 1, column 3,
      and the first three messages all identify this as one of their
      potential problem locations.
      It is reasonable to believe that a programmer, especially once
      he becomes used to this kind of mismatch reporting,
      will quickly find the first mismatch and fix it.
      For this difficult case,
      &lt;tt&gt;bracket.pl&lt;/tt&gt; may not be much better than the state of the art,
      but it is certainly no worse.
    &lt;/p&gt;
    &lt;h3&gt;How it works&lt;/h3&gt;
    &lt;p&gt;
      For full details of the workings of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      there is
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;the code&lt;/a&gt;,
      which is heavily commented.
      This section provides a conceptual overview.
    &lt;/p&gt;&lt;p&gt;
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses two features of Marpa:
      left-eideticism and the Ruby Slippers.
      By left-eidetic, I mean that Marpa knows everything there is to know
      about the parse at, and to left of, the current position.
      As a consequence,
      Marpa
      also knows exactly which of its input symbols
      can lead to a successful parse,
      and is able to stop as soon as it knows that the parse cannot succeed.
    &lt;/p&gt;
    &lt;p&gt;
      In the Ruby Slippers technique, we arrange for parsing to stop
      whenever we encounter an input which
      would cause parsing to fail.
      The application then
      asks Marpa, &quot;OK.  What input would allow the
      parse to continue?&quot;
      The application takes Marpa's answer to this
      question, and uses it to concoct
      an input that Marpa will accept.
    &lt;/p&gt;
    &lt;p&gt;
      In this case,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      creates a virtual token which fixes the mismatch
      of brackets.
      Whatever the missing bracket may be,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      invents a bracket of that kind,
      and adds it to the virtual input.
      This done,
      parsing and error detection
      can proceed as if there was no problem.
      Of course,
      the error which made the Ruby Slippers token necessary
      is recorded, and those records are the source of the
      error reports we saw above.
    &lt;/p&gt;
    &lt;p&gt;
      To make its error messages as informative as possible
      in the case of missing closing brackets,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      needs to report the exact location of
      the opening bracket.
      Left-eideticism again comes in handy here.
      Once the virtual closing bracket is supplied to Marpa,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      asks, &quot;That bracketed text that I just closed -- where did it begin?&quot;
      The Marpa parser tracks the start location
      of all symbol and rule instances,
      so it is able to provide the application
      with the exact location of
      the starting bracket.
    &lt;/p&gt;&lt;p&gt;
      When
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      encounters a problem at a point where there are unclosed opening
      brackets, it has two choices.
      It can be optimistic or it can be pessimistic.
      &quot;Optimistic&quot; means it can hope that something later in the input will close
      the opening bracket.
      &quot;Pessimistic&quot; means it can decide that &quot;all bets are off&quot; and use
      Ruby Slippers tokens to close all the currently active open brackets.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses the pessimistic strategy.
      While the optimistic strategy sounds better, in practice
      the pessimistic one seems to provide better diagnostics.
      The pessimistic strategy does report some fixable problems
      as errors.
      But the optimistic one can introduce spurious fixes.
      These hide the real errors,
      and it is worse to miss errors
      than it is to overreport them.
      Even when the pessimistic strategy overreports,
      its first error message will always accurately identify
      the first problem location.
    &lt;/p&gt;
    &lt;p&gt;
      While
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is already useable,
      I think of it as a prototype.
      Beyond that,
      the problem of matching delimiters
      is in fact very general, and I believe these techniques may have very wide application.
    &lt;/p&gt;
    &lt;h3&gt;For more&lt;/h3&gt;
    &lt;p&gt;
      The example script of this post is
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;a Github gist&lt;/a&gt;.
      For more about Marpa,
      there's
      &lt;a href=http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Parsing: a timeline</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/09/chron.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;p&gt;[ Revised 22 Oct 2014 ]
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1960&lt;/b&gt;:
      The ALGOL 60 spec comes out.
      It specifies, for the first time, a block structured
      language.
      The ALGOL committee is well aware
      that
      nobody knows how to parse such a language.
      But they believe that,
      if they specify a block-structured
      language, a parser for it will be invented.
      Risky as this approach is, it pays off ...
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1961&lt;/b&gt;: Ned Irons publishes his ALGOL parser.
      In fact, the Irons parser
      is the first parser of any kind to be described
      in print.
      Ned's algorithm is a left parser --
      a form of recursive descent.
      Unlike modern
      recursive descent,
      the Irons algorithm
      is general and syntax-driven.
      &quot;General&quot; means it can parse anything written in BNF.
      &quot;Syntax-driven&quot; (aka declarative) means that parser is
      actually created from the BNF --
      the parser does not need
      to be hand-written.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1961&lt;/b&gt;:
      Almost simultaneously, hand-coded approaches to left parsing
      appear.
      These we would now recognize as recursive descent.
      Over the following years, hand-coding approaches
      will become more popular for left parsers
      than syntax-driven algorithms.
      Three factors are at work:
      &lt;ul&gt;
      &lt;li&gt;
      In 1960's, memory and CPU are both extremely limited.
      Hand-coding pays off, even when the gains are small.
      &lt;li&gt;
      Pure left parsing is a very weak parsing technique.
      Hand-coding is often necessary
      to overcome its limits.
      This is
      as true today as it is in 1961.
      &lt;li&gt;
      Left parsing works well in combination with hand-coding --
      they are a very good fit.
      &lt;/ul&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1965&lt;/b&gt;:
    Don Knuth invents LR parsing.
      Knuth is primarily interested
      in the mathematics.
      Knuth describes a parsing algorithm,
      but it is not thought practical.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1968&lt;/b&gt;: Jay Earley invents the algorithm named after him.
      Like the Irons algorithm,
      Earley's algorithm is syntax-driven and fully general.
      Unlike the Irons algorithm, it does not backtrack.
      Earley's core idea is to
      track everything about the parse in tables.
      Earley's algorithm is enticing, but it has three major issues:
      &lt;ul&gt;
      &lt;li&gt;First, there is a bug in the handling of zero-length rules.
      &lt;li&gt;Second, it is quadratic for right recursions.
      &lt;li&gt;Third, the bookkeeping required to set up the tables is,
      by the standards of 1968 hardware, daunting.
      &lt;/ul&gt;
    &lt;p&gt;&lt;b&gt;1969&lt;/b&gt;:
      Frank DeRemer describes a new variant of Knuth's LR
      parsing.
      DeRemer's LALR algorithm requires only
      a stack and a state table of quite
      manageable size.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1972&lt;/b&gt;:
      Aho and Ullmann describe
      a straightforward fix to the zero-length rule bug in Earley's original algorithm.
      Unfortunately, this fix involves adding even more bookkeeping to Earley's.
    &lt;p&gt;&lt;b&gt;1975&lt;/b&gt;:
      Bell Labs converts its C compiler from hand-written recursive
      descent to DeRemer's LALR algorithm.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1977&lt;/b&gt;:
      The first &quot;Dragon book&quot; comes out.
      This soon-to-be classic textbook is nicknamed after
      the drawing on the front cover,
      in which a knight takes on a dragon.
      Emblazoned on the knight's lance are the letters &quot;LALR&quot;.
      From here on out,
      to speak lightly of LALR will be to besmirch the escutcheon
      of parsing theory.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1979&lt;/b&gt;: Bell Laboratories releases Version 7 UNIX.
	V7 includes what is, by far,
		the most comprehensive, useable and easily available
		compiler writing toolkit yet developed.
	 Central to the toolkit is
	 yacc, an LALR based parser generator.
	  With a bit of hackery,
	  yacc parses its own input language,
	  as well as the language of V7's main compiler,
	  the portable C compiler.
	  After two decades of research,
	  it seems that the parsing problem is solved.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1987&lt;/b&gt;:
      Larry Wall introduces Perl 1.
      Perl embraces complexity like no previous language.
      Larry uses LALR very aggressively --
      to my knowledge more aggressively than anyone before
      or since.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1991&lt;/b&gt;:
      Joop Leo discovers a way of speeding up right
      recursions in Earley's algorithm.
      Leo's algorithm
      is linear for just about every unambiguous grammar of
      practical interest, and many ambiguous ones as well.
      In 1991 hardware is six orders of magnitude faster
      than 1968 hardware, so that the
      issue of bookkeeping overhead had receded
      in importance.
      This is a major discovery.
      When it comes to speed,
      the game has changed in favor of Earley algorithm.
      But Earley parsing is almost forgotten.
      It will be 20 years before anyone writes a practical
      implementation of Leo's algorithm.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;1990's&lt;/b&gt;:
      Earley's is forgotten.
      So everyone in LALR-land is content, right?
      Wrong. Far from it, in fact.
      Users of LALR are making unpleasant discoveries.
      While LALR automatically
      generates their parsers,
      debugging them
      is so hard they could just as easily
      write the parser by hand.
      Once debugged, their LALR parsers are fast for correct inputs.
      But almost all they tell the users about incorrect inputs
      is that they are incorrect.
      In Larry's words, LALR is &quot;fast but stupid&quot;.
    &lt;/p&gt;&lt;b&gt;2000&lt;/b&gt;:
    Larry Wall decides on a radical reimplementation
      of Perl -- Perl 6.
      Larry does not even consider using LALR again.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;2002&lt;/b&gt;:
      Aycock&amp;Horspool publish their attempt at a fast, practical Earley's parser.
      Missing from it is Joop Leo's improvement --
      they seem not to be aware of it.
      Their own speedup is limited in what it achieves
      and the complications it introduces
      can be counter-productive at evaluation time.
      But buried in their paper is a solution to the zero-length rule bug.
      And this time the solution requires no additional bookkeeping.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;2006&lt;/b&gt;:
      GNU announces that the GCC compiler's parser has been rewritten.
      For three decades,
      the industry's flagship C compilers have used
      LALR as their parser --
      proof of the claim that LALR and serious
      parsing are equivalent.
      Now, GNU replaces
      LALR with the technology that
      it replaced a quarter century earlier:
      recursive descent.
    &lt;/p&gt;
    &lt;p&gt;&lt;b&gt;2000 to today&lt;/b&gt;:
    With the retreat from LALR comes a collapse in the
      prestige of parsing theory.
      After a half century,
      we seem to be back
      where we started.
      If you took Ned Iron's original 1961 algorithm,
      changed the names and dates,
      and translated the code from the mix of assembler and
      ALGOL into Haskell,
      you would easily republish it today,
      and bill it as 
      as revolutionary and new.
    &lt;/p&gt;
    &lt;p&gt;
    &lt;h3&gt;Marpa&lt;/h3&gt;
      Over the years,
      I had come back to Earley's algorithm again and again.
      Around 2010, I realized
      that the original, long-abandoned vision --
      an efficient, practical, general and syntax-driven parser --
      was now, in fact, quite possible.
      The necessary pieces had fallen into place.
    &lt;/p&gt;
    &lt;p&gt;
      Aycock&amp;Hospool has solved the zero-length rule bug.
      Joop Leo had found the speedup for right recursion.
      And the issue of bookkeeping overhead had pretty much evaporated on its
      own.
      Machine operations are now a billion times faster than in 1968,
      and probably no longer relevant in any case --
      caches misses are now the bottleneck.
    &lt;/p&gt;
    &lt;p&gt;But while the original issues with Earley's disappeared,
      a new issue emerged.
      With a parsing algorithm as powerful as Earley's behind it,
      a syntax-driven approach can do much more than it can with
      a left parser.
      But with the experience with LALR in their collective consciousness,
      few modern programmers are prepared
      to trust a purely declarative parser.
      As Lincoln said, &quot;Once a cat's been burned,
      he won't even sit on a cold stove.&quot;
    &lt;/p&gt;
    &lt;p&gt;
      To be accepted, Marpa needed to allow
      procedure parsing,
      not just declarative parsing.
      So Marpa allows the user to specify events --
      occurrences of symbols and rules --
      at which declarative parsing pauses.
      While paused,
      the application can call procedural logic
      and single-step forward token by token.
      The procedural logic can hand control back
      over to syntax-driven parsing at any point it likes.
      The Earley tables can provide the procedural logic with
      full knowledge of the state of the
      parse so far:
      all rules recognized
      in all possible parses so far,
      and all symbols expected.
      Earley's algorithm is now a even better companion
      for hand-written procedural logic than recursive descent.
    &lt;/p&gt;
    &lt;h3&gt;For more&lt;/h3&gt;
    &lt;p&gt;
      For more about Marpa,
      there's
      &lt;a href=http://savage.net.au/Marpa.html&quot;&gt;the
      official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Marpa has a new web page</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/09/website.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      Marpa has
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;a
      new official public website&lt;/a&gt;,
      which Ron Savage has generously agreed to manage.
      For those who have not heard of it,
      Marpa is a parsing algorithm.
      It is new, but very much based
      on earlier work by Jay Earley, Joop Leo, John Aycock and R. Nigel Horspool.
      Marpa is intended to replace, and to go well beyond,
      recursive descent and the yacc family of parsers.
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;
        Marpa is fast. It parses in linear time:
        &lt;ul&gt;
          &lt;li&gt;all the grammar classes that recursive descent parses;&lt;/li&gt;
          &lt;li&gt;the grammar class that the yacc family parses;&lt;/li&gt;
          &lt;li&gt;in fact, all unambiguous grammars, as long as they are free of unmarked middle recursions;
	  and&lt;/li&gt;
	  &lt;li&gt;all
	  ambiguous grammars that are unions of a finite set of any of the above grammars.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        Marpa is powerful. Marpa will parse anything that can be
	written in BNF.
	This includes any mixture of left, right and middle recursions.
      &lt;/li&gt;
      &lt;li&gt;Marpa is convenient.
      Unlike recursive descent, you do not have to write a parser --
      Marpa generates one from BNF.
      Unlike PEG or yacc, parser generation is unrestricted and exact.
      Marpa converts any grammar which can be written as BNF
      into a parser which recognizes everything
      in the language described by that BNF, and which rejects everything that is
      not in that language.
      The programmer is not forced to make arbitrary choices while parsing.
      If a rule has several alternatives,
      all of the alternatives are considered for as long as they might yield a valid parse.
      &lt;/li&gt;
      &lt;li&gt;
        Marpa is flexible. Like recursive descent, Marpa allows you to stop and
        do your own custom processing. Unlike recursive descent, Marpa makes available
        to you detailed information about the parse so far --
        which rules and symbols have been recognized, with their locations,
        and which rules and symbols are expected next.
      &lt;/li&gt;
      &lt;/ul&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Language design: Exploiting ambiguity</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/08/ambig.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      Currently, in designing languages,
      we don't allow ambiguities --
      not even potential ones.
      We insist that it must not be
      even
      &lt;b&gt;possible&lt;/b&gt;
      to write an ambiguous program.
      This is unnecessarily restrictive.
    &lt;/p&gt;
    &lt;p&gt;
      This post is written in English, which is full of ambiguities.
      Natural languages are always ambiguous,
      because human beings find that that's best way for versatile,
      rapid, easy communication.
      Human beings arrange things so that every
      sentence is unambiguous in context.
      Mistakes happen, and ambiguous sentences occur,
      but in practice, the problem is manageable.
      In a conversation, for example,
      we would just ask for clarification.
    &lt;/p&gt;
    &lt;p&gt;
      If we allow our computer languages to take their most natural forms,
      they will often have the
      &lt;b&gt;potential&lt;/b&gt;
      for ambiguity.
      This is even less of a problem on a computer than it is in
      conversation -- a computer can always spot an actual ambiguity
      immediately.
      When
      &lt;b&gt;actual&lt;/b&gt;
      ambiguities occur, we can deal with them
      in exactly the same way that we deal with
      any other syntax problem:
      The computer catches it and reports it,
      and we fix it.
    &lt;/p&gt;
    &lt;h3&gt;An example&lt;/h3&gt;
    &lt;p&gt;
      To illustrate,
      I'll use a DSL-writing DSL language.
      It'll be tiny -- just lexeme declarations and BNF rules.
      Newlines will
      &lt;b&gt;not&lt;/b&gt;
      be significant.
      Statements can end with a semicolon, but that's optional.
      (The code for this post is in
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/ed64bf00983f7be666bc&quot;&gt;
        a Github gist&lt;/a&gt;.)
    &lt;/p&gt;
    &lt;p&gt;Here is a toy calculator written in our tiny DSL-writing language:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
  Number matches '\d+'
  E ::= T '*' F
  E ::= T
  T ::= F '+' Number
  T ::= Number
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;h3&gt;Trying an improvement&lt;/h3&gt;
    &lt;p&gt;With a grammar this small, just about
      &lt;b&gt;anything&lt;/b&gt;
      is readable.
      But let's assume we want to improve it, and that we decide
      that the lexeme declaration of
      &lt;tt&gt;Number&lt;/tt&gt;
      really belongs
      after the rules which use it.
      (If our grammar was longer, this could make a real difference.)
      So we move the lexeme declaration to the end:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
  E ::= T '*' F
  E ::= T
  T ::= F '+' Number
  T ::= Number
  Number matches '\d+'
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;h3&gt;But there's an issue&lt;/h3&gt;
    &lt;p&gt;
      It turns out the grammar for our toy DSL-writer is ambiguous.
      When a lexeme declaration follows a BNF rule,
      there's no way to tell whether or not it is actually a
      lexeme declaration, or part of the BNF rule.
      Our parser catches that:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
Parse of BNF/Scanless source is ambiguous
Length of symbol &quot;Statement&quot; at line 4, column 1 is ambiguous
  Choices start with: T ::= Number
  Choice 1, length=12, ends at line 4, column 12
  Choice 1: T ::= Number
  Choice 2, length=33, ends at line 5, column 20
  Choice 2: T ::= Number\nNumber matches '\\d
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Here Marpa tells you why it thinks your script is ambiguous.
      Two different statements can start at line 4.
      Both of them are BNF rules, but one is longer than the other.
    &lt;/p&gt;
    &lt;h3&gt;Just another syntax error&lt;/h3&gt;
    &lt;p&gt;Instead of having to design a language where ambiguity was not
      even possible, we designed one where ambiguities can happen.
      This allows us to design a much more flexible language,
      like the ones we choose when we humans communicate with each other.
      The downside is that actual ambiguities will occur,
      but they can be reported, and fixed,
      just like any other syntax error.
    &lt;/p&gt;&lt;p&gt;In this case, we
      recall we allowed semi-colons to terminate a rule,
      and our fix is easy:
    &lt;/p&gt;
    &lt;p&gt;
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
  E ::= T '*' F
  E ::= T
  T ::= F '+' Number
  T ::= Number ;
  Number matches '\d+'
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;h3&gt;To learn more&lt;/h3&gt;
    &lt;p&gt;
      The code for this post is
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/ed64bf00983f7be666bc&quot;&gt;
        a gist on Github&lt;/a&gt;.
      It was written using
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2&quot;&gt;Marpa::R2,
        which is available on CPAN&lt;/a&gt;.
      A list of my Marpa tutorials can be found
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL&quot;&gt;
        here&lt;/a&gt;.
      There are
      new tutorials by
      &lt;a href=&quot;http://marpa-guide.github.io/chapter1.html&quot;&gt;Peter Stuifzand&lt;/a&gt;
      and
      &lt;a href=&quot;http://longanswers.blogspot.de/2013/06/transforming-syntax.html&quot;&gt;amon&lt;/a&gt;.
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/&quot;&gt;
        The Ocean of Awareness blog&lt;/a&gt;
      focuses on Marpa,
      and it has
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html&quot;&gt;an annotated guide&lt;/a&gt;.
      Marpa has
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa-web-site/&quot;&gt;a web page that I maintain&lt;/a&gt;
      and Ron Savage maintains
      &lt;a href=&quot;http://savage.net.au/Perl-modules/html/marpa.papers/index.html&quot;&gt;
        another&lt;/a&gt;.
      For questions, support and discussion, there is
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        a &quot;marpa parser&quot;
        Google Group&lt;/a&gt;
      and an IRC channel:
      &lt;tt&gt;#marpa&lt;/tt&gt;
      at
      &lt;tt&gt;irc.freenode.net&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Evolvable languages</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/03/kv.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      Ideally, if a syntax is useful and clear,
      and a programmer can easily read it at a glance,
      you should be able to add it to an existing language.
      In this post, I will describe
      a modest incremental change to the Perl syntax.
    &lt;/p&gt;
    &lt;p&gt;
      It's one I like, because that's beside the point, for two
      reasons.
      First, it's simply intended as an example of language evolution.
      Second, regardless of its merits, it is unlikely to happen,
      because of the way that Perl 5 is parsed.
      In this post I will demonstrate a way of writing a parser,
      so that this change,
      or others, can be made in a straightforward way,
      and without designing your language into a corner.
    &lt;/p&gt;
    &lt;p&gt;
      When initializing a hash, Perl 5 allows you to use not just commas,
      but also the so-called &quot;wide comma&quot; (&lt;tt&gt;=&amp;gt;&lt;/tt&gt;).
      The wide comma is suggestive visually, and it also has some smarts
      about what a hash key is:
      The hash key is always converted into a string, so that wide comma
      knows that in a key-value pair like this:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
    key1 =&gt; 711,
&lt;/pre&gt;
    &lt;/blockquote&gt;&lt;p&gt;
      that
      &lt;tt&gt;key1&lt;/tt&gt;
      is intended as a string.
    &lt;/p&gt;
    &lt;p&gt;
      But what about something like this?
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
  {
   company name =&gt; 'Kamamaya Technology',
   employee 1 =&gt; first name =&gt; 'Jane',
   employee 1 =&gt; last name =&gt; 'Doe',
   employee 1 =&gt; title =&gt; 'President',
   employee 2 =&gt; first name =&gt; 'John',
   employee 2 =&gt; last name =&gt; 'Smith',
   employee 3 =&gt; first name =&gt; 'Clarence',
   employee 3 =&gt; last name =&gt; 'Darrow',
  }
&lt;/pre&gt;
    &lt;/blockquote&gt;&lt;p&gt;
      Here I think the intent is obvious -- to create an employee database in the form
      of a hash of hashes, allowing spaces in the keys.
      In Data::Dumper format, the result would look like:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
{
              'employee 2' =&gt; {
                                'last name' =&gt; '\'Smith\'',
                                'first name' =&gt; '\'John\''
                              },
              'company name' =&gt; '\'Kamamaya Technology\'',
              'employee 3' =&gt; {
                                'last name' =&gt; '\'Darrow\'',
                                'first name' =&gt; '\'Clarence\''
                              },
              'employee 1' =&gt; {
                                'title' =&gt; '\'President\'',
                                'last name' =&gt; '\'Doe\'',
                                'first name' =&gt; '\'Jane\''
                              }
            }
&lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;And in fact, that is the output of the script in
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/9478391&quot;&gt;
    this Github gist&lt;/a&gt;,
        which parses the previous &quot;extended Perl 5&quot; snippet using a Marpa
        grammar before passing it on to Perl.
      &lt;/p&gt;
      &lt;p&gt;Perl 5 does not allow a syntax like this,
      and looking at its parsing code will tell you why -- it's already
      a maintenance nightmare.
      The extension I've described above could, in theory, be added to Perl
      5, but doing so would aggravate an already desperate maintenance situation.
    &lt;p&gt;
      Now, depending on taste,
      you may be just as happy that you'll never
      see the extensions I have just outlined in Perl 5.
      But I don't think it is as easy to
      be happy about a parsing technology that
      quickly paints the languages which use it into a corner.
    &lt;/p&gt;
    &lt;h3&gt;How it works&lt;/h3&gt;
    &lt;p&gt;
      The code is in
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/9478391&quot;&gt;
        a Github gist&lt;/a&gt;.
	For the purposes of the example, I've implemented
	a toy subset of Perl.
	But this approach has been shown to scale.
	There are full Marpa-powered parsers of
	&lt;a href=&quot;https://metacpan.org/release/MarpaX-Languages-C-AST&quot;&gt;C&lt;/a&gt;,
	&lt;a href=&quot;https://metacpan.org/release/MarpaX-Languages-ECMAScript-AST&quot;&gt;ECMAScript&lt;/a&gt;,
	&lt;a href=&quot;https://metacpan.org/release/MarpaX-xPathLike&quot;&gt;XPath&lt;/a&gt;, and
	&lt;a href=&quot;https://metacpan.org/pod/distribution/Marpa-R2/html/pod/HTML.pod&quot;&gt;liberal HTML&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;Marpa is a general BNF parser, which means that anything you can write in BNF, Marpa can parse.
    For practical parsing, what matters are those grammars that can be parsed in linear time,
    and with Marpa that class is vast, including all the classes of grammar currently in practical use.
    To describe the class of grammars that Marpa parses in linear time,
    assume that you have either a left or right parser,
    with infinite lookahead,
    that uses regular expressions.
    (A parser like this is called LR-regular.)
    Assume that this LR-regular parser parses your grammar.
    In that case,
    you can be sure that
    Marpa will parse that grammar in linear time, and without doing the lookahead.
    (Instead Marpa tracks possibilities in a highly-optimized table.)
    Marpa also parses many grammars that are not LR-regular in linear time,
    but just LR-regular is very likely to include any class of grammar that you will be
    interested in parsing.
    The LR-regular grammars easily include all those that can be
    parsed using yacc, recursive descent or regular expressions.
    &lt;/p&gt;
    &lt;p&gt;
    Marpa excels at those special hacks so necessary in recursive descent and other techniques.
    Marpa allows you to define events that will stop it at symbols or rules, both before and after.
    While stopped,
    you can hand processing over to your own custom code.
    Your custom code can feed your own tokens to the parse for as long as you like.
    In doing so, it can
    consult Marpa to determine exactly what symbols and rules have been recognized and
    which ones are expected.
    Once finished with custom processing,
    you can then ask Marpa to pick up again at any point you wish.
    &lt;/p&gt;
    &lt;h3&gt;The craps game is over&lt;/h3&gt;
    &lt;p&gt;The bottom line is that if you can describe your language extension in BNF,
    or in BNF plus some hacks,
    you can rely on Marpa parsing it in reasonable time.
    Language design has been like shooting crap in a casino
    that sets you up to
    win a lot of the first rolls before
    the laws of probability grind you down.
    Marpa changes the game.
    &lt;/p&gt;
    &lt;h3&gt;To learn more&lt;/h3&gt;
    &lt;p&gt;
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2&quot;&gt;Marpa::R2
        is available on CPAN&lt;/a&gt;.
      A list of my Marpa tutorials can be found
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html#TUTORIAL&quot;&gt;
        here&lt;/a&gt;.
      There are
      new tutorials by
      &lt;a href=&quot;http://marpa-guide.github.io/chapter1.html&quot;&gt;Peter Stuifzand&lt;/a&gt;
      and
      &lt;a href=&quot;http://longanswers.blogspot.de/2013/06/transforming-syntax.html&quot;&gt;amon&lt;/a&gt;.
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/&quot;&gt;
        The Ocean of Awareness blog&lt;/a&gt;
      focuses on Marpa,
      and it has
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html&quot;&gt;an annotated guide&lt;/a&gt;.
      Marpa has
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa-web-site/&quot;&gt;a web page that I maintain&lt;/a&gt;
      and Ron Savage maintains
      &lt;a href=&quot;http://savage.net.au/Perl-modules/html/marpa.papers/index.html&quot;&gt;
        another&lt;/a&gt;.
      For questions, support and discussion, there is
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        the &quot;marpa parser&quot;
        Google Group.&lt;/a&gt;
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
      Marpa's Google group&lt;/a&gt;.
      &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  </channel>
</rss>
