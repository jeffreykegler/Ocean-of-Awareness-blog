<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>PEG: Ambiguity, precision and confusion</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2015/03/peg.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;h3&gt;Precise?&lt;/h3&gt;
    &lt;p&gt;&lt;a href=&quot;http://bford.info/packrat/&quot;&gt;PEG parsing&lt;/a&gt;
      is a new notation
      for a notorously tricky algorithm that goes back
      to the earliest computers.
      In its PEG form,
      this algorithm acquired an seductive new interface,
      one that looks like the best of
      extended BNF combined with the best of regular expressions.
      Looking at a sample of it, you are tempted to imagine
      that writing a parser has suddenly become a very straightforward
      matter. Not so.
    &lt;/p&gt;
    &lt;p&gt;For those not yet in the know on this,
      I'll illustrate with a pair of examples from
      &lt;a href=&quot;http://www.romanredz.se/papers/FI2008.pdf&quot;&gt;
        an excellent 2008 paper by Redziejowski&lt;/a&gt;.
      Let's start with these two PEG specifications.
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    (&quot;a&quot;|&quot;aa&quot;)&quot;a&quot;
    (&quot;aa&quot;|&quot;a&quot;)&quot;a&quot;
    &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      One of these two PEG grammars accepts
      the string &quot;&lt;tt&gt;aaa&lt;/tt&gt;&quot; but not the string &quot;&lt;tt&gt;aa&lt;/tt&gt;&quot;.
      The other does the opposite -- it accepts the string
      the string &quot;&lt;tt&gt;aa&lt;/tt&gt;&quot; but not the string &quot;&lt;tt&gt;aaa&lt;/tt&gt;&quot;.
      Can you tell which one?
      (For the answer,
      see page 4 of
      &lt;a href=&quot;http://www.romanredz.se/papers/FI2008.pdf&quot;&gt;
        Redziejowski 2008&lt;/a&gt;.)
    &lt;/p&gt;&lt;p&gt;
      Here is another example:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    A = &quot;a&quot;A&quot;a&quot;/&quot;aa&quot;
    &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      What language does this describe?
      All the strings in the
      language are obviously
      the letter &quot;&lt;tt&gt;a&lt;/tt&gt;&quot;,
      repeated some number of times.
      But which string lengths are in the language,
      and which are not?
      Again the answer is on
      page 4 of
      &lt;a href=&quot;http://www.romanredz.se/papers/FI2008.pdf&quot;&gt;
        Redziejowski 2008&lt;/a&gt;
      -- it's exactly those strings
      whose length is a power of 2.
    &lt;/p&gt;
    &lt;p&gt;With PEG, what you see in the extended BNF
      is not what you get.
      PEG parsing has been called &quot;precise&quot;,
      apparently based on
      the idea that PEG parsing is in a certain sense unambiguous.
      In this case &quot;precise&quot; is taken as synonymous with
      &quot;unique&quot;.
      That is, PEG parsing is precise in exactly the same
      sense that Jimmy Hoffa's body
      is at a precise location.
      There is (presumably) exactly one such place,
      but we are hard put to be any more specific about the matter.
    &lt;/p&gt;
    &lt;h3&gt;Syntax-driven?&lt;/h3&gt;
    &lt;p&gt;The advantage of using
      a syntax-driven parser generator is that
      the syntax you specify describes
      the language that will be parsed.
      For most practical grammars, PEG is not syntax-driven
      in this sense.
      Several important
      PEG researchers understand this issue,
      and have tried to deal with it.
      I will talk about their work below.
      This is much more at stake than bragging rights
      over which algorithm is really syntax-driven and
      which is not.
    &lt;/p&gt;
    &lt;p&gt;When you do not know the language your parser is
      parsing, you of course have the problem that
      your parser
      might not parse all the strings in your language.
      That can be dealt with by
      fixing the parser to accept the correct input,
      as you encounter problems.
    &lt;/p&gt;
    &lt;p&gt;A second, more serious, problem is often forgotten.
      Your PEG parser might accept strings that are
      &lt;b&gt;not&lt;/b&gt;
      in your language.
      At worst, this creates a security loophole.
      At best, it leaves with a choice:
      break compatiblity,
      or leave the problem unfixed.
    &lt;/p&gt;
    &lt;p&gt;It's important to be able to be able to convince
      yourself
      that your code is correct by examining and thinking
      about the code.
      Beginning programmers often simply hack things,
      and call code complete once it passes the test suite.
      Test suites don't catch everything,
      but there is a worse problem with the beginner's approach.
    &lt;/p&gt;
    &lt;p&gt;
      Since the beginner has no clear idea of why his code
      works, even when it does,
      it is unlikely to be well-organized or readable.
      Programming techniques like PEG,
      where the code can be made to work,
      but where it is much harder,
      and in practice usually not possible,
      to be sure why the code works,
      become maintenance nightmares.
    &lt;/p&gt;
    &lt;p&gt;
      The maintenance implications are especially worrisome if
      the PEG parser is for a language with a life cycle that may
      involves bug fixes or other changes.
      The impact of even
      small changes to a PEG specification
      is hard to predict and
      hard to discover after the fact.
    &lt;/p&gt;
    &lt;h3&gt;Is PEG unambiguous?&lt;/h3&gt;
    &lt;p&gt;PEG is not unambiguous in any
      helpful sense of that word.
      BNF allows you to specify ambiguous grammars,
      and that feature is tied to its power and flexibility
      and often useful in itself.
      PEG will only deliver one of those parses.
      But without
      an easy way of knowing which parse,
      the underlying ambiguity is not addressed --
      it is just ignored.
    &lt;/p&gt;
    &lt;p&gt;My Marpa parser
      is a general BNF parser based on Earley's.
      It also can simply throw all but one of the parses in an ambiguous
      parse away.
      But I would not feel justified in saying to a user who has an
      issue with ambiguity,
      that Marpa has solved her problem
      by throwing all but one arbitrarily chosen result.
    &lt;/p&gt;
    &lt;p&gt;
      Sticking with Marpa for a moment,
      we can see one
      example of a more helpful approach
      to ambiguity.
      Marpa allows a user to rank rules,
      so that all but the highest ranking rules are not used
      in a parse.
      Marpa's rule rankings are specified in its BNF,
      and they work together with the BNF
      in an intuitive way.
      In every case,
      Marpa delivers precisely the parses its BNF and its rule
      rankings specify.
      And it
      is &quot;precision&quot; in this sense that a parser writer is looking for.
    &lt;/p&gt;
    &lt;h3&gt;Is there a sensible way to use PEG?&lt;/h3&gt;
    &lt;p&gt;
      I'll return to Marpa at the end of this post.
      For now,
      let's assume
      that you are not interested in using Marpa --
      you are committed to PEG,
      and you want to make the best of PEG.
      Several excellent programmers have focused
      on PEG,
      without blinding themselves to its limitations.
      I've already mentioned one important paper
      by Redziejowski.
      Many of
      &lt;a href=&quot;http://www.romanredz.se/pubs.htm&quot;&gt;
        Redziejowski's collected papers&lt;/a&gt;
      are about PEG,
      and Redziejowski, in his attempts to use PEG,
      does not sugarcoat its problems.
    &lt;/p&gt;
    &lt;p&gt;Roberto Ierusalimschy, author of Lua and one of the best
      programmers of our time,
      has written a PEG-based parser of his own.
      Roberto is fully aware of PEG's limits,
      but he makes a very good case for choosing PEG
      as the basis of LPEG, his parser generator.
      LPEG is intended for use with Lua,
      a ruthlessly minimal language.
      Roberto's minimalist implementation limits the power of his parser,
      but his aim is to extend regular expressions in a disciplined way,
      and a compact parser of limited power is quite acceptable for his
      purposes.
    &lt;/p&gt;
    &lt;h3&gt;Matching the BNF to the PEG spec&lt;/h3&gt;
    &lt;p&gt;
      As Redziejowski and Ierusalimschy and the other authors
      of
      &lt;a href=&quot;http://arxiv.org/abs/1304.3177&quot;&gt;Mascarenhas et al, 2013&lt;/a&gt;
      recognize,
      inability to know the the language you are
      parsing is more than an annoyance.
      We can call a language
      &quot;well-behaved for PEG&quot;
      if the PEG spec delivers exactly
      the language the BNF describes.
    &lt;/p&gt;
    &lt;p&gt;Which languages are are well-behaved for PEG?
      According to
      &lt;a href=&quot;http://arxiv.org/abs/1304.3177&quot;&gt;Mascarenhas et al, 2013&lt;/a&gt;,
      the LL(1) languages are well-behaved.
      (The LL(1) languages are the languages
      a top-down parser can parse based on at
      most one character of input.)
      Syntax-driven parsers for LL(1) have been around
      for much longer than PEG --
      one such parser is described
      in the first paper to describe recursive descent
      (&lt;a href=&quot;http://archive.computerhistory.org/resources/text/algol/algol_bulletin/AS16/AS16.HTM&quot;&gt;Peter
        Lucas, 1961&lt;/a&gt;).
      But most practical languages are not LL(1).
      &lt;a href=&quot;http://www.romanredz.se/papers/FI2013.pdf&quot;&gt;Redziejowski 2013&lt;/a&gt;
      and
      &lt;a href=&quot;http://www.romanredz.se/papers/FI2014.pdf&quot;&gt;Redziejowski 2014&lt;/a&gt;
      seek to extend this result by defining the language class LL(1p) --
      those top-down languages with one
      &quot;parsing procedure&quot;
      of lookahead.
      The LL(1p) languages are also well-behaved for PEG.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;a href=&quot;http://arxiv.org/abs/1304.3177&quot;&gt;Mascarenhas et al, 2013&lt;/a&gt;
      also look at a different approach -- instead of writing a PEG specification
      and trying to keep it well-behaved,
      they look at taking languages from larger top-down classes
      and translating them to PEG.
      I don't know of any followup,
      but it's possible this approach could produce
      well-behaved top-down parsers which are
      an improvement over direct-from-PEG parsing.
      But for those who are open to leaving top-down parsing behind,
      a parser which handles languages in all these classes
      and more is already available.
    &lt;/p&gt;
    &lt;h3&gt;Marpa&lt;/h3&gt;
    &lt;p&gt;
      In this post,
      I have adopted the point of view of programmers using PEG,
      or thinking of doing so.
      My own belief in this matter is that
      very few programmers
      should want to bother with the issues I've just described.
      My reason for this is the Marpa parser --
      a general BNF Earley-drived parser that
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;has an implementation you can use today;&lt;/li&gt;
      &lt;li&gt;allows the application to combine syntax-driven parsing
        with custom procedural logic;&lt;/li&gt;
      &lt;li&gt;makes available full, left-eidetic knowledge of the parse to
        the procedural logic;&lt;/li&gt;
      &lt;li&gt;and parses a vast class of grammars in linear time,
        including all the LR-regular grammars.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
      The LR-regular grammars include the LR(k) and LL(k)
      grammars for all
      &lt;i&gt;k&lt;/i&gt;.
      LR-regular includes all the languages
      which are well-behaved under PEG,
      and all of those that
      &lt;a href=&quot;http://arxiv.org/abs/1304.3177&quot;&gt;Mascarenhas et al, 2013&lt;/a&gt;
      consider translating into PEG.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Parsing: Top-down versus bottom-up</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/ll.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;&lt;p&gt;Comparisons between top-down and bottom-up parsing
      are often either too high-level or too low-level.
      Overly high-level treatments reduce the two approaches to buzzwords,
      and the comparison to a recitation of received wisdom.
      Overly low-level treatments get immersed in the minutiae of implementation,
      and the resulting comparison is as revealing as placing
      two abstractly related code listings side by side.
      In this post I hope to find the middle level;
      to shed light on why advocates of bottom-up
      and top-down parsing approaches take the positions
      they do;
      and to speculate about the way forward.
    &lt;/p&gt;
    &lt;h3&gt;Top-down parsing&lt;/h3&gt;
    &lt;p&gt;The basic idea of top-down parsing is
      as brutally simple as anything in programming:
      Starting at the top, we add pieces.
      We do this by looking at the next token and deciding then and there
      where it fits into the parse tree.
      Once we've looked at every token,
      we have our parse tree.
    &lt;/p&gt;&lt;p&gt;
      In its purest form,
      this idea is too simple for practical parsing,
      so top-down parsing is almost
      always combined with lookahead.
      Lookahead of one token helps a lot.
      Longer lookaheads
      are very sparsely used.
      They just aren't that helpful,
      and since
      the number of possible lookaheads grows exponentially,
      they get very expensive very fast.
    &lt;/p&gt;&lt;p&gt;Top-down parsing has an issue with left recursion.
      It's straightforward to see why.
      Take
      an open-ended expression like
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    a + b + c + d + e + f + [....]&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Here the plus signs continue off to the right,
      and adding any of them to the parse tree
      requires a dedicated node which
      must be above the node for the first plus sign.
      We cannot put that first plus sign into a top-down parse
      tree without having first dealt with all those plus signs that follow it.
      For a top-down strategy, this is a big, big problem.
    &lt;/p&gt;&lt;p&gt;
      Even in the simplest expression,
      there is no way of counting the plus signs
      without looking to the right,
      quite possibly a very long way to the right.
      When we are not dealing with simple expressions,
      this rightward-looking needs to get
      sophisticated.
      There are ways of dealing with this difficulty,
      but all of them share one thing in common --
      they are trying to make top-down parsing into
      something that it is not.
    &lt;/p&gt;&lt;h3&gt;Advantages of top-down parsing&lt;/h3&gt;
    &lt;p&gt;Top-down parsing does not look at the right context in any systematic way,
      and in the 1970's it was hard to believe that
      top-down was as good as we can do.
      (It's not all that easy to believe today.)
      But its extreme simplicity
      is also top-down parsing's great strength.
      Because a top-down parser is extremely simple,
      it is very easy to figure out what it is doing.
      And easy to figure out means easy to customize.
    &lt;/p&gt;&lt;p&gt;
      Take another of the many constructs incomprehensible to
      a top-down parser:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    2 * 3 * 4 + 5 * 6
    &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      How do top-down parsers typically handle this?
      Simple: as soon as they realize they are faced
      with an expression, they give up on top-down
      parsing and switch to a special-purpose algorithm.
    &lt;/p&gt;&lt;p&gt;These two properties -- easy to understand
      and easy to customize --
      have catapulted top-down parsing
      to the top of the heap.
      Behind their different presentations,
      combinator parsing, PEG, and recursive descent are
      all top-down parsers.
    &lt;/p&gt;&lt;h3&gt;Bottom-up parsing&lt;/h3&gt;
    &lt;p&gt;Few theoreticians of the 1970's imagined that top-down parsing might
      be the end of the parsing story.
      Looking to the right in ad hoc ways clearly does help.
      It would be almost paradoxical if
      there was no systematic way to exploit the right context.
    &lt;/p&gt;&lt;p&gt;In 1965, Don Knuth found an algorithm to exploit
      right context.
      Knuth's LR algorithm was,
      like top-down parsing as I have described it,
      deterministic.
      Determinism was thought to be essential --
      allowing more than one choice easily leads to
      a combinatorial explosion in the
      number of possibilities that have to be considered at once.
      When parsers are restricted to dealing with a single choice,
      it is much easier to guarantee that
      they will run in linear time.
    &lt;/p&gt;
    &lt;p&gt;Knuth's algorithm did &lt;b&gt;not&lt;/b&gt;
      try to hang
      each token from a branch of a top-down parse tree
      as soon as it was encountered.
      Instead, Knuth suggested delaying that decision.
      Knuth's algorithm collected
      &quot;subparses&quot;.
      &lt;p&gt;
      When I say &quot;subparses&quot; in this discussion,
      I mean pieces of the parse that 
      contain all the decisions necessary to construct
      the part of the parse tree that is below them.
      But subparses do not contain any decisions about what is above them
      in the parse tree.
      Put another way, subparses know who they are,
      but not where they belong.
    &lt;p&gt;&lt;/p&gt;
      Subparses may not know where they belong,
      but knowing who they are is enough for them
      to be assembled into larger subparses.
      And, if we keep assembling the subparses,
      eventually we will have a &quot;subparse&quot; that
      is the full parse tree.
      And at that point we will
      know both who everyone is 
      and where everyone belongs.
    &lt;/p&gt;&lt;p&gt;
      Knuth's algorithm stored subparses by shifting them onto a stack.
      The operation to do this was called a &quot;shift&quot;.
      (Single tokens of the input are treated as subparses with a single node.)
      When there was enough context to build a larger subparse,
      the algorithm popped one or more subparses off the stack,
      assembled a larger subparse,
      and put the resulting subparse back on the stack.
      This operation was called a &quot;reduce&quot;,
      based on the idea that its repeated application
      eventually &quot;reduces&quot; the parse tree to its root node.
    &lt;/p&gt;&lt;p&gt;
      In handling the stack, we will often be faced with
      choices.
      One kind of choice is between using what we already have
      on top of the stack to assemble a larger subparse;
      or pushing more subparses on top of the stack instead (&quot;shift/reduce&quot;).
      When we decide to reduce,
      we may encounter the other kind of choice --
      we have to decide which rule to use (&quot;reduce/reduce&quot;).
    &lt;/p&gt;
    &lt;p&gt;Like top-down parsing, bottom-up parsing is usually combined with lookahead.
      For the same lookahead, a bottom-up parser parses everything that a
      top-down parser can handle,
      and more.
    &lt;/p&gt;&lt;p&gt;Formally, Knuth's approach is now called shift/reduce parsing.
      I want to demonstrate why theoreticians,
      and for a long time almost everybody else as well,
      was so taken with this method.
      I'll describe how it works on some examples,
      including two very important ones that
      stump top-down parsers: arithmetic expressions and left-recursion.
      My purpose here is bring to light the basic concepts,
      and not to guide an implementor.
      There are excellent implementation-oriented presentations in many other places.
      &lt;a href=http://en.wikipedia.org/wiki/Shift-reduce_parser&gt;The Wikipedia article&lt;/a&gt;,
      for example, is excellent.
    &lt;/p&gt;
    &lt;p&gt;
      Bottom-up parsing solved
      the problem of left recursion.
      In the example from above,
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    a + b + c + d + e + f + [....]&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      we simply build one subparse after another,
      as rapidly as we can.
      In the terminology of shift/reduce,
      whenever we can reduce, we do.
      Eventually we will have run out of tokens,
      and will have reduced until there is only one element on the stack.
      That one remaining element is the subparse that is also,
      in fact, our full parse tree.
    &lt;/p&gt;&lt;p&gt;
      The top-down parser had a problem with left recursion
      precisely because it needed to build top-down.
      To build top-down, it needed to know about all the plus signs to come,
      because these needed to be fitted into the parse tree above the current plus
      sign.
      But when building bottom-up,
      we don't need to know anything about
      the plus signs that will be above the current one in the parse tree.
      We can afford to wait until we encounter them.
    &lt;/p&gt;
    &lt;p&gt;But if working bottom-up solves the left recursion problem,
      doesn't it create a right recursion problem?
      In fact,
      for a bottom-up parser, right recursion is harder, but not much.
      That's because of the stack.
      For a right recursion like this:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    a = b = c = d = e = f = [....]&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      we use a strategy opposite to the one we used for the
      left recursion.
      For left recursion, we reduced whenever we could.
      For right recursion, when we have a choice, we always shift.
      This means we will immediately shift the entire input onto the stack.
      Once the entire input is on the stack,
      we have no choice but to start reducing.
      Eventually we will reduce the stack to a single element.
      At that point, we are done.
      Essentially, what we are doing is exactly what we did for left recursion,
      except that we use the stack to reverse the order.
    &lt;/p&gt;&lt;p&gt;
      Arithmetic expressions like
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
    2 * 3 * 4 + 5 * 6&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      require a mixed strategy.
      Whenever we have a shift/reduce choice,
      and one of the operators is on the stack,
      we check to see if the topmost operator is a multiply or an addition operator.
      If it is a multiply operator, we reduce.
      In all other cases, if there is a shift/reduce choice, we shift.
    &lt;/p&gt;
    &lt;p&gt;
      In the discussion above,
      I have pulled the strategy for making stack decisions
      (shift/reduce and reduce/reduce)
      out of thin air.
      Clearly, if bottom-up parsing was going to be
      a practical parsing algorithm,
      the stack decisions
      would have to be
      made algorithmically.
      In fact, discovering a practical way to do this
      was a far from trivial task.
      The solution in Knuth's paper was considered (and apparently intended)
      to be mathematically provocative, rather than practical.
      But by 1979, it was thought a practical way to make stack decisions
      had been found
      and yacc, a parser generator based on bottom-up parsing, was released.
      (Readers today may be more familiar with yacc's successor, bison.)
    &lt;/p&gt;
    &lt;h3&gt;The fate of bottom-up parsing&lt;/h3&gt;
    &lt;p&gt;
      With yacc, it looked as if the limitations of top-down parsing were past us.
      We now had a parsing algorithm that could readily and directly
      parse left and right recursions, as well as arithmetic expressions.
      Theoreticians thought they'd found the Holy Grail.
    &lt;/p&gt;&lt;p&gt;But not all of the medieval romances had happy endings.
      And as I've
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html&quot;&gt;described
        elsewhere&lt;/a&gt;,
      this story ended badly.
      Bottom-up parsing was driven by tables which made the algorithm fast
      for correct inputs, but unable to accurately diagnose faulty ones.
      The subset of grammars parsed was still not quite large enough,
      even for conservative language designers.
      And bottom-up parsing was very unfriendly to custom hacks,
      which made every shortcoming loom large.
      It is much harder to work around a problem in a bottom-up
      parser than than it is to deal with a similar shortcoming
      in a top-down parser.
      After decades of experience with bottom-up parsing,
      top-down parsing has re-emerged as the
      algorithm of choice.
    &lt;/p&gt;
    &lt;h3&gt;Non-determinism&lt;/h3&gt;
    &lt;p&gt;For many, the return to top-down parsing
      answers the question that we posed earlier:
      &quot;Is there any systematic way to exploit right context when parsing?&quot;
      So far, the answer seems to be a rather startling &quot;No&quot;.
      Can this really be the end of the story?
    &lt;/p&gt;&lt;p&gt;
      It would be very strange if the best basic parsing algorithm we know is top-down.
      Above, I described at some length some very important grammars that
      can be parsed bottom-up
      but not top-down, at least not directly.
      Progress like this seems like a lot to walk away from,
      and especially to walk back all the way to what is
      essentially a brute force algorithm.
      This perhaps explains why lectures
      and textbooks persist in teaching bottom-up parsing to
      students who are very unlikely to use it.
      Because the verdict from practitioners seems to be in,
      and likely to hold up on appeal.
    &lt;/p&gt;
    &lt;p&gt;Fans of deterministic top-down parsing,
      and proponents of deterministic bottom-up parsing share
      an assumption:
      For a practical algorithm to be linear,
      it has to be deterministic.
      But is this actually the case?
    &lt;/p&gt;
    &lt;p&gt;It's not, in fact.
      To keep bottom-up parsing deterministic, we restricted ourselves to a stack.
      But what if we track all possible subpieces of parses?
      For efficiency, we can link them and put them into tables,
      making the final decisions in a second pass,
      once the tables are complete.
      (The second pass replaces the stack-driven
      see-sawing back and forth of the deterministic bottom-up algorithm,
      so it's not an inefficiency.)
      Jay Earley in 1968 came up with an algorithm to do this,
      and in 1991 Joop Leo added a memoization to Earley's
      algorithm which made it linear for all deterministic grammars.
    &lt;/p&gt;&lt;p&gt;The &quot;deterministic grammars&quot;
      are exactly the bottom-up parseable grammars
      with lookahead -- the set of grammars parsed by Knuth's algorithm.
      So that means the Earley/Leo algorithm parses,
      in linear time,
      everything that a deterministic bottom-up parser can parse,
      and therefore every grammar that
      a deterministic top-down parser can parse.
      (In fact, the Earley/Leo algorithm is linear for a lot of
      ambiguous grammars as well.)
    &lt;/p&gt;&lt;p&gt;Top-down parsing had the advantage that it was easy to know where
      you are.  The Earley/Leo algorithm has an equivalent advantage -- its
      tables know where it is, and it is easy to query them programmatically.
      In 2010, this blogger modified the Earley/Leo algorithm
      to have the other big advantage of top-down parsing:
      The Marpa algorithm rearranges the Earley/Leo parse engine so that we can
      stop it, perform our own logic, and restart where we left off.
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;A quite useable parser based on the Marpa algorithm&lt;/a&gt;
      is available as open source.
    &lt;/p&gt;&lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      &lt;a href=&quot;http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>What makes a parsing algorithm successful?</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/successful.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;p&gt;What makes a parsing algorithm successful?
      Two factors, I think.
      First, does the algorithm parse a workably-defined set of grammars in linear time?
      Second, does it allow the application to intervene in the parse
      with custom code?
      When parsing algorithms are compared,
      typically neither of these gets much attention.
      But the successful algorithms do one or the other.
    &lt;/p&gt;
    &lt;h3&gt;Does the algorithm parse a workably-defined set of grammars in linear time?&lt;/h3&gt;
    &lt;p&gt;&quot;Workably-defined&quot; means more than well-defined
      in the mathematical sense --
      the definition has to be &lt;b&gt;workable&lt;/b&gt;.
      That is, the
      definition must be something that,
      with reasonable effort,
      a programmer can use in practice.
    &lt;/p&gt;&lt;p&gt;
      The algorithms in regular expression engines are workably-defined.
      A regular expression, in the pure sense consists of a sequence of symbols,
      usually shown by concatenation:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;a b c&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      or a choice among sequences, usually shown by a vertical bar:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;a | b | c&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      or a repetition of any of the above, typically shown with a star:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;a*&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      or any recursive combination of these.
      True, if this definition is new to you, it can take time to get
      used to.
      But vast numbers of working programming are very much &quot;used to it&quot;,
      can think in terms of regular expressions,
      and can determine if a particular problem will yield to treatment
      as a regular expression, or not.
      &lt;p&gt;
      Parsers in the LALR family (yacc, bison, etc.)
      do &lt;b&gt;not&lt;/b&gt;
      have a workably defined set of grammars.
      LALR is perfectly well-defined mathematically,
      but even experts in parsing theory are hard put to decide
      if a particular grammar is LALR.
    &lt;/p&gt;&lt;p&gt;
      Recursive descent also does not have a workably defined
      set of grammars.
      Recursive descent doesn't even have a precise mathematical description --
      you can say that recursive descent is LL,
      but in practice LL tables are rarely used.
      Also in practice, the LL logic is extended with every other trick
      imaginable, up to and including switching to other parsing algorithms.
    &lt;/p&gt;
    &lt;h3&gt;Does it allow the user to intervene in the parse?&lt;/h3&gt;
    &lt;p&gt;It is not easy for users to intervene in the processing
      of a regular expression, though some implementations attempt to
      allow such efforts.
      LALR parsers are notoriously opaque.
      Those who maintain the LALR-driven Perl parser have tried
      to supplement its abilities with
      custom code, with results that will not encourage
      others making the same attempt.
    &lt;/p&gt;&lt;p&gt;Recursive descent, on the other hand, has no parse engine --
      it is 100% custom code.
      You don't get much friendlier than that.
    &lt;/p&gt;&lt;h3&gt;Conclusions&lt;/h3&gt;&lt;p&gt;
      Regular expressions are a success,
      and will remain so,
      because the set of grammars
      they handle is very workably-defined.
      Applications using regular expressions have to take what the algorithm
      gives them, but what it gives them is very predictable.
      &lt;p&gt;
      For example, an application can write regular expressions on the fly, and
      the programmer can be confident they will run as long as they are well-formed.
      And it is easy to determine if the regular expression is well-formed.
      (Whether it actually does what you want is a separate issue.)
      &lt;p&gt;
      Recursive descent does not handle a workably-defined set of grammars,
      and it also has to be hand-written.
      But it makes up for this by allowing the user to step into the parsing process
      anywhere, and &quot;get his hands dirty&quot;.
      Recursive descent does nothing for you, but it does allow you complete control.
      This is enough to make recursive descent the current algorithm of choice
      for major parsing projects.
      &lt;p&gt;
      As I have
      &lt;a href=&quot;http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html&quot;&gt;chronicled
      elsewhere&lt;/a&gt;,
      LALR was once,
      on highly convincing theoretical grounds,
      seen as
      &lt;b&gt;the&lt;/b&gt; solution to the parsing problem.
      But while mathematically well-defined,
      LALR was not workably defined.
      And it was very hostile to applications that tried to alter,
      or even examine, its syntax-driven workings.
      After decades of trying to make it work,
      the profession has abandoned LALR almost totally.
    &lt;/p&gt;
    &lt;h3&gt;What about Marpa?&lt;/h3&gt;
    &lt;p&gt;Marpa has both properties:
      its set of grammars is workably-defined.
      And, while Marpa is syntax-driven like LALR and regular expressions,
      it also allows the user to stop the parse engine,
      communicate with it about the state of the parse,
      do her own parsing for a while,
      and restart the parse engine at any point she wants.
    &lt;/p&gt;
    &lt;p&gt;Marpa's workable definition has a nuance that the one
    for regular expressions does not.
    For regular expressions, linearity is a given --
    they parse in linear time or fail.
      Marpa parses a much larger class of grammars, the context-free grammars --
      anything that can be written in BNF.
      BNF is used to describe languages in standards,
      and is therefore itself a kind of &quot;gold standard&quot;
      for a workable definition of a
      set of grammars.
      However, Marpa does &lt;b&gt;not&lt;/b&gt;
      parse everything that can be written in BNF in linear time.
    &lt;/p&gt;
    &lt;p&gt;Marpa linearly-parsed set of grammars is smaller than the context-free
    grammars, but it is still very large, and it is still workably-defined.
      Marpa will parse any unambiguous language in linear time,
      unless it contains unmarked middle recursions.
      An example of a &quot;marked&quot; middle recursion is the language described
      by
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;S ::= a S a | x&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
    a string of which is &quot;&lt;tt&gt;aaaxaaa&lt;/tt&gt;&quot;,
      where the &quot;&lt;tt&gt;x&lt;/tt&gt;&quot; marks the middle.
      An example of an &quot;unmarked&quot; middle recursion is the language described
      by
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;S ::= a S a | a&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
    a string of which is &quot;&lt;tt&gt;aaaaaaa&lt;/tt&gt;&quot;,
      where nothing marks the middle, so that you don't know until the end where the
      middle of the recursion is.
      If a human can reliably find the middle by eyeball, the middle recursion is marked.
      If a human can't, then the middle recursion might be unmarked.
    &lt;/p&gt;
    &lt;p&gt;Marpa also parses a large set of unambiguous grammars linearly,
      and this set of grammars is also workably-defined.
      Marpa parses an ambiguous grammar in linear time if
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;It has no unmarked middle recursions.
      &lt;/li&gt;
      &lt;li&gt;All right recursions are unambiguous.
      &lt;/li&gt;
      &lt;li&gt;There are no cycles.
      A cycle occurs, for example, if there is a rule &lt;tt&gt;A ::= A&lt;/tt&gt;
      in the grammar.
      &lt;/li&gt;
      &lt;li&gt;Marpa's level of ambiguity at any location is bounded by a constant.
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;The term &quot;level of ambiguity&quot; requires a bit of explanation.
	At any given location,
        there can be as many rules &quot;in play&quot; as you like,
	without affecting the level of ambiguity.
        The key question: What is the maximum number of different origins
	that a rule might have?
	(The &quot;origin&quot; of a rule is the location where it begins.)
        That is, can a rule currently in play
	have at most 20 different origins?
        Or could it have its origin at every location so far?
        If the maximum number of origins is 20 or any other fixed constant, the level of
        ambiguity is &quot;bounded&quot;.
	But if the maximum number of origins keeps growing as the length of the input
	grows, the level of ambiguity is unbounded.
    &lt;p&gt;For the unambiguous case, Marpa's workable definition encompasses
    a much larger class of grammars, but is no more
      complex than that for regular expressions.
      If you want to extend even further,
      and work with ambiguous grammars,
      the definition remains quite workable.
      Of the four restrictions needed to ensure linearity,
      the one requiring a bounded level of ambiguity is the only one
      that might force you to exercise real vigliance --
      once you get into ambiguity, unboundedness is easy to slip into.
      &lt;p&gt;
      As for the other three,
      cycles never occur in a practical grammars,
      and Marpa reports them,
      so that you simply fix them when they happen.
      Most recursions will be left recursions,
      which are unrestricted.
      My experience has been that, in practical grammars,
      unmarked middle recursions
      and ambiguous right recursions are not especially
      tempting features.
      If you note
      whenever you use a right recursion,
      checking that it is not ambiguous,
      and if you note whenever you use a middle recursion,
      checking that it is marked,
      then you will stay linear.
    &lt;/p&gt;
      To learn more about Marpa,
      there's
      &lt;a href=http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
    &lt;/p&gt;&lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Removing obsolete versions of Marpa from CPAN</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/backpan.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;p&gt;Marpa::XS, Marpa::PP, and Marpa::HTML are obsolete versions of
      Marpa, which I have been keeping on CPAN for the convenience of legacy
      users.
      All new users should look only at
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;Marpa::R2&lt;/a&gt;.
    &lt;/p&gt;&lt;p&gt;
      I plan to delete the obsolete releases from CPAN soon.
      For legacy users who need copies, they will still be available on backPAN.
    &lt;/p&gt;&lt;p&gt;
      I do this because their placement on CPAN placement makes them &quot;attractive nuisances&quot; --
      they show up in searches and generally make it harder to find
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;Marpa::R2&lt;/a&gt;,
      which is the version that new users should be interested in.
      There is also some danger a new user could, by mistake, use the
      obsolete versions instead of Marpa::R2.
    &lt;/p&gt;&lt;p&gt;
      It's been some time since someone has reported a bug in their code,
      so they should be stable for legacy applications.
      I would usually promise to fix serious bugs that affect legacy users,
      but unfortunately, especially in the case of Marpa::XS,
      it is a promise I would have trouble keeping.
      Marpa::XS depends on Glib, and uses a complex build which I last performed
      on a machine I no longer use for development.
    &lt;/p&gt;&lt;p&gt;
      For this reason, a re-release to CPAN with deprecatory language is also not an option.
      I probably would not want to do so anyway -- the CPAN infrastructure by default
      pushes legacy
      users into upgrading, which always carries some risk.
      New deprecatory language would add no
      value for the legacy users,
      and they are the only audience these releases exist to serve.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      &lt;a href=http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  <item>
    <title>Reporting mismatched delimiters</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/delimiter.html</link>
    <description>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;/p&gt;
    &lt;p&gt;In many contexts, programs need to identify
      non-overlapping pieces of a text.
      One very direct way to do this
      is to use a pair of delimiters.
      One delimiter of the pair marks the start
      and the other marks the end.
      Delimiters can take many forms:
      Quote marks, parentheses, curly braces, square brackets,
      XML tags, and HTML tags
      are all delimiters in this sense.
    &lt;/p&gt;
    &lt;p&gt;
      Mismatching delimiters is easy to do.
      Traditional parsers are often poor at reporting these errors:
      hopeless after the first mismatch,
      and for that matter none too precise about the first one.
      This post outlines a scaleable method for the accurate
      reporting of mismatched delimiters.
      I will illustrate the method with a simple
      but useable tool --
      a utility which reports mismatched brackets.
    &lt;/p&gt;
    &lt;h3&gt;The example script&lt;/h3&gt;
    &lt;p&gt;The
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;example
      script&lt;/a&gt;,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;,
      reports mismatched brackets in the set:
    &lt;/p&gt;
    &lt;blockquote&gt;&lt;pre&gt;() {} []&lt;/pre&gt;&lt;/blockquote&gt;
      &lt;p&gt;
      They are expected to nest without overlaps.
      Other text is treated as filler.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is not smart about things
      like strings or comments.
      This does have the advantage of making
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      mostly language-agnostic.
    &lt;/p&gt;
    &lt;p&gt;
      Because it's intended primarily to be read
      as an illustration of the technique,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s grammar
      is a basic one.
      The grammar that
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses is so simple that
      an emulator of &lt;tt&gt;bracket.pl&lt;/tt&gt;
      could be written using recursive descent.
      I hope the reader who goes on to look into the details
      will see that this technique scales to more
      complex situations,
      in a way that a solution based on a traditional parser
      will not.
    &lt;/p&gt;
    &lt;h3&gt;Error reports&lt;/h3&gt;
    &lt;p&gt;The description of how the method works will make more
      sense after we've looked at some examples of the diagnostics
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      produces.
      To be truly useful,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      must report mismatches that span
      many lines,
      and it can do this.
      But single-line examples are easier to follow.
      All the examples in this post will be contained in a one line.
      Consider the string '&lt;tt&gt;((([))&lt;/tt&gt;'.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s diagnostics are:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Opening '(' never closed, problem detected at end of string
((([))
^
====================
* Line 1, column 4: Missing close ], problem detected at line 1, column 5
((([))
   ^^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      In the next example
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      realizes that it
      cannot accept the ')' at column 16, without first closing the set of curly braces started at column 5.
      It identifies the problem, along with both of the locations involved.
    &lt;/p&gt;
    &lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 5: Missing close }, problem detected at line 1, column 16
[({({x[]x{}x()x)})]
    ^          ^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      So far, so good.
      But an important advantage of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      has yet to be seen.
      Most compilers,
      once they report a first mismatched delimiter,
      produce error messages that are
      unreliable --
      so unreliable that they are useless in practice.
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      repairs a mismatched bracket before continuing,
      so that it can do a reasonable job of analyzing the text
      that follows.
      Consider the text
      '&lt;tt&gt;({]-[(}-[{)&lt;/tt&gt;'.
      The output of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Missing close ), problem detected at line 1, column 3
({]-[(}-[{)
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
({]-[(}-[{)
 ^^
====================
* Line 1, column 3: Missing open [
({]-[(}-[{)
  ^
====================
* Line 1, column 5: Missing close ], problem detected at line 1, column 7
({]-[(}-[{)
    ^ ^
====================
* Line 1, column 6: Missing close ), problem detected at line 1, column 7
({]-[(}-[{)
     ^^
====================
* Line 1, column 7: Missing open {
({]-[(}-[{)
      ^
====================
* Line 1, column 9: Missing close ], problem detected at line 1, column 11
({]-[(}-[{)
        ^ ^
====================
* Line 1, column 10: Missing close }, problem detected at line 1, column 11
({]-[(}-[{)
         ^^
====================
* Line 1, column 11: Missing open (
({]-[(}-[{)
          ^
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;Each time,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      corrects itself,
      and accurately reports the next set of problems.
    &lt;/p&gt;&lt;h3&gt;A difficult error report&lt;/h3&gt;
    &lt;p&gt;
      To be 100% accurate,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      would have to guess the programmer's intent.
      This is, of course, not possible.
      Let's look at a text where
      &lt;tt&gt;bracket.pl&lt;/tt&gt;'s guesses are not so good:
      &lt;tt&gt;{{]}&lt;/tt&gt;.
      Here we will assume the closing square bracket is a typo for a closing parenthesis.
      Here's the result:
    &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;
* Line 1, column 1: Missing close }, problem detected at line 1, column 3
{{]}
^ ^
====================
* Line 1, column 2: Missing close }, problem detected at line 1, column 3
{{]}
 ^^
====================
* Line 1, column 3: Missing open [
{{]}
  ^
====================
* Line 1, column 4: Missing open {
{{]}
   ^
&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
      Instead of one error,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      finds four.
    &lt;/p&gt;&lt;p&gt;
      But even in this case, the method is fairly good, especially when
      compared with current practice.
      The problem is at line 1, column 3,
      and the first three messages all identify this as one of their
      potential problem locations.
      It is reasonable to believe that a programmer, especially once
      he becomes used to this kind of mismatch reporting,
      will quickly find the first mismatch and fix it.
      For this difficult case,
      &lt;tt&gt;bracket.pl&lt;/tt&gt; may not be much better than the state of the art,
      but it is certainly no worse.
    &lt;/p&gt;
    &lt;h3&gt;How it works&lt;/h3&gt;
    &lt;p&gt;
      For full details of the workings of
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      there is
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;the code&lt;/a&gt;,
      which is heavily commented.
      This section provides a conceptual overview.
    &lt;/p&gt;&lt;p&gt;
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses two features of Marpa:
      left-eideticism and the Ruby Slippers.
      By left-eidetic, I mean that Marpa knows everything there is to know
      about the parse at, and to left of, the current position.
      As a consequence,
      Marpa
      also knows exactly which of its input symbols
      can lead to a successful parse,
      and is able to stop as soon as it knows that the parse cannot succeed.
    &lt;/p&gt;
    &lt;p&gt;
      In the Ruby Slippers technique, we arrange for parsing to stop
      whenever we encounter an input which
      would cause parsing to fail.
      The application then
      asks Marpa, &quot;OK.  What input would allow the
      parse to continue?&quot;
      The application takes Marpa's answer to this
      question, and uses it to concoct
      an input that Marpa will accept.
    &lt;/p&gt;
    &lt;p&gt;
      In this case,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      creates a virtual token which fixes the mismatch
      of brackets.
      Whatever the missing bracket may be,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      invents a bracket of that kind,
      and adds it to the virtual input.
      This done,
      parsing and error detection
      can proceed as if there was no problem.
      Of course,
      the error which made the Ruby Slippers token necessary
      is recorded, and those records are the source of the
      error reports we saw above.
    &lt;/p&gt;
    &lt;p&gt;
      To make its error messages as informative as possible
      in the case of missing closing brackets,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      needs to report the exact location of
      the opening bracket.
      Left-eideticism again comes in handy here.
      Once the virtual closing bracket is supplied to Marpa,
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      asks, &quot;That bracketed text that I just closed -- where did it begin?&quot;
      The Marpa parser tracks the start location
      of all symbol and rule instances,
      so it is able to provide the application
      with the exact location of
      the starting bracket.
    &lt;/p&gt;&lt;p&gt;
      When
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      encounters a problem at a point where there are unclosed opening
      brackets, it has two choices.
      It can be optimistic or it can be pessimistic.
      &quot;Optimistic&quot; means it can hope that something later in the input will close
      the opening bracket.
      &quot;Pessimistic&quot; means it can decide that &quot;all bets are off&quot; and use
      Ruby Slippers tokens to close all the currently active open brackets.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      uses the pessimistic strategy.
      While the optimistic strategy sounds better, in practice
      the pessimistic one seems to provide better diagnostics.
      The pessimistic strategy does report some fixable problems
      as errors.
      But the optimistic one can introduce spurious fixes.
      These hide the real errors,
      and it is worse to miss errors
      than it is to overreport them.
      Even when the pessimistic strategy overreports,
      its first error message will always accurately identify
      the first problem location.
    &lt;/p&gt;
    &lt;p&gt;
      While
      &lt;tt&gt;bracket.pl&lt;/tt&gt;
      is already useable,
      I think of it as a prototype.
      Beyond that,
      the problem of matching delimiters
      is in fact very general, and I believe these techniques may have very wide application.
    &lt;/p&gt;
    &lt;h3&gt;For more&lt;/h3&gt;
    &lt;p&gt;
      The example script of this post is
      &lt;a href=&quot;https://gist.github.com/jeffreykegler/b6bfeeadfcedeade6519&quot;&gt;a Github gist&lt;/a&gt;.
      For more about Marpa,
      there's
      &lt;a href=http://savage.net.au/Marpa.html&quot;&gt;the
        official web site maintained by Ron Savage&lt;/a&gt;.
      I also have
      &lt;a href=&quot;http://jeffreykegler.github.io/Marpa-web-site/&quot;&gt;a Marpa web site&lt;/a&gt;.
      Comments on this post can be made in
      &lt;a href=&quot;http://groups.google.com/group/marpa-parser&quot;&gt;
        Marpa's Google group&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</description>
  </item>
  </channel>
</rss>
