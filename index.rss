<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Making DSL's even simpler</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html</link>
    <description>  &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html&quot;&gt;
        In a previous post&lt;/a&gt;, I showed how to make it easier to write
      domain-specific languages (DSLs).
      This post takes things one step further.
      With Marpa's new Scanless interface, the programmer does not
      need to write a separate lexer.
    &lt;/p&gt;&lt;p&gt;
      When it comes to dealing with a programming problem,
      no tool is as powerful and flexible as
      a custom language targeted to the problem domain.
      But writing a domain specific language (DSL) is among the
      least used approaches,
      and for what has been a very good reason --
      DSL's have been very difficult to write.
    &lt;/p&gt;
    &lt;p&gt;This post takes a tutorial approach.
      It does
      &lt;b&gt;not&lt;/b&gt;
      assume any knowledge of the previous tutorials
      on this blog.
    &lt;/p&gt;&lt;p&gt;
      The full code for this post is in
      &lt;a href=&quot;https://gist.github.com/4480523&quot;&gt;
        a Github gist&lt;/a&gt;.
      Our example DSL is a calculator.
      While better than shell arithmetic,
      this calculator is designed to more to act as a good example,
      more than as something you'd want to use.
      But it is not a &quot;toy&quot; example
      -- its 300 lines include good error reporting and a test suite.
    &lt;/p&gt;
    &lt;h3&gt;The Grammar&lt;/h3&gt;
    &lt;p&gt;
      Let's start right in, by showing the grammar for our calculator.
      It divides naturally into two parts.  Here is the first:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
:start ::= script
script ::= expression
script ::= script ';' expression action =&amp;gt; do_arg2
&amp;lt;reduce op&amp;gt; ::= '+' | '-' | '/' | '*'
expression ::=
     number
   | variable action =&amp;gt; do_is_var
   | '(' expression ')' assoc =&amp;gt; group action =&amp;gt; do_arg1
  || '-' expression action =&amp;gt; do_negate
  || expression '^' expression action =&amp;gt; do_caret assoc =&amp;gt; right
  || expression '*' expression action =&amp;gt; do_star
   | expression '/' expression action =&amp;gt; do_slash
  || expression '+' expression action =&amp;gt; do_plus
   | expression '-' expression action =&amp;gt; do_minus
  || expression ',' expression action =&amp;gt; do_array
  || &amp;lt;reduce op&amp;gt; 'reduce' expression action =&amp;gt; do_reduce
  || variable '=' expression action =&amp;gt; do_set_var
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The format of the grammar is documented
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.040000/pod/Scanless.pod&quot;&gt;
        here&lt;/a&gt;.
      It consists of BNF rules, whose left hand side (LHS) and right hand side (RHS)
      can be separated by the BNF operator (&lt;tt&gt;::=&lt;/tt&gt;).
      The first rule is a pseudo-rule -- its LHS is the pseudo-symbol
      &lt;tt&gt;:start&lt;/tt&gt;,
      and indicates that
      &lt;tt&gt;script&lt;/tt&gt;
      is the grammar's start symbol.
      The next two rules indicate that
      &lt;tt&gt;script&lt;/tt&gt;
      is a series of one
      or more
      &lt;tt&gt;expression&lt;/tt&gt;'s, separated by a semicolon.
    &lt;/p&gt;&lt;p&gt;
      Rules can have action &quot;adverbs&quot;
      to describe the semantics.
      For example, the adverb &quot;&lt;tt&gt;action =&amp;gt; do_args&lt;/tt&gt;&quot;
      says that the semantics for
      the preceding RHS are implemented by a Perl closure named
      &lt;tt&gt;do_args&lt;/tt&gt;.
    &lt;/p&gt;&lt;p&gt;The rule for
      &lt;tt&gt;&amp;lt;reduce op&amp;gt;&lt;/tt&gt;
      introduces two new features: symbols names
      in angle brackets, and alternatives,
      separated by a veritcal bar, (&quot;&lt;tt&gt;|&lt;/tt&gt;&quot;).
    &lt;/p&gt;
    &lt;p&gt;The last and longest rule, defined an
      &lt;tt&gt;expression&lt;/tt&gt;,
      is a precedence rule.
      It is a series of alternatives, some separated by
      a single vertical bar,
      and others separated by a double vertical bar (&quot;&lt;tt&gt;||&lt;/tt&gt;&quot;).
      The double vertical bar indicates that the alternatives after it
      are at a looser (&quot;lower&quot;) precedence than the alternatives before it.
      The single vertical bar separates alternatives at the same precedence level.
    &lt;/p&gt;&lt;p&gt;
      While Marpa's Scanless interface allows lexical and structural rules
      to be intermixed,
      it is usually convenient to have the lexical rules come after
      the structural rules:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
number ~ [\d]+
variable ~ [\w]+
:discard ~ whitespace
whitespace ~ [\s]+
# allow comments
:discard ~ &amp;lt;hash comment&amp;gt;
&amp;lt;hash comment&amp;gt; ~ &amp;lt;terminated hash comment&amp;gt; | &amp;lt;unterminated
   final hash comment&amp;gt;
&amp;lt;terminated hash comment&amp;gt; ~ '#' &amp;lt;hash comment body&amp;gt; &amp;lt;vertical space char&amp;gt;
&amp;lt;unterminated final hash comment&amp;gt; ~ '#' &amp;lt;hash comment body&amp;gt;
&amp;lt;hash comment body&amp;gt; ~ &amp;lt;hash comment char&amp;gt;*
&amp;lt;vertical space char&amp;gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&amp;lt;hash comment char&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
END_OF_GRAMMAR
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Rules in this second set of rules have
      the same syntax as rules in the first set,
      but instead of the BNF operator (&lt;tt&gt;::=&lt;/tt&gt;),
      they have a match operator (&lt;tt&gt;~&lt;/tt&gt;) separating the LHS and RHS.
      The BNF operator can be seen as telling Marpa, &quot;When it comes to whitespace and comments,
      do what I
      &lt;b&gt;mean&lt;/b&gt;&quot;.
      The match operator tells Marpa to &quot;Do exactly what I
      &lt;b&gt;say&lt;/b&gt;
      on a literal,
      character-by-characcter basis.&quot;
    &lt;/p&gt;&lt;p&gt;
      The first two lines indicate how
      &lt;tt&gt;number&lt;/tt&gt;'s and
      &lt;tt&gt;variable&lt;/tt&gt;'s
      are formed.
      The square bracketed character classes accept anything acceptable to Perl.
      &lt;tt&gt;:discard&lt;/tt&gt;
      is another pseudo-symbol -- any lexeme recognized as a
      &lt;tt&gt;:discard&lt;/tt&gt;
      symbol is thrown away.
    &lt;/p&gt;&lt;p&gt;
      This is how whitespace and comments are dealt with.
      Note that our calculator recognizes &quot;hash comments&quot;,
      and takes some care to do the right thing even when the hash comment is at
      the end of a string which does not end in vertical whitespace.
      It is interesting to compare the representation of hash comments here with
      the usual regular expression notation.
      Regular expressions are much more concise, but the BNF-ish form
      can be easier to read.
      In this example,
      long descriptive angle-bracketed symbol names
      save the reader the trouble of
      puzzling out the purpose of some of the more obscure cases.
    &lt;/p&gt;
    &lt;p&gt;
      Now that we have defined the grammar, we need to pre-process it:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
      my $grammar = Marpa::R2::Scanless::G-&amp;gt;new(
	{ action_object  =&amp;gt; 'My_Actions',
	  default_action =&amp;gt; 'do_arg0',
	  source =&amp;gt; \$rules,
	}
      );
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      The
      &lt;tt&gt;action_object&lt;/tt&gt;
      named argument specifies a package to implement
      the semantics -- Marpa will look up the names of the Perl closures in that
      package.
      The
      &lt;tt&gt;default_action&lt;/tt&gt;
      named argument specified the action name for RHS's
      which do not explicitly specify one with an
      &lt;tt&gt;action&lt;/tt&gt;
      adverb.
    &lt;/p&gt;
    &lt;h3&gt;Running a parse&lt;/h3&gt;
    &lt;p&gt;
      The next closure shows how to use the grammar to parse a string:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
sub calculate {
    my ($p_string) = @_;

    my $recce = Marpa::R2::Scanless::R-&amp;gt;new( { grammar =&amp;gt; $grammar } );

    my $self = bless { grammar =&amp;gt; $grammar }, 'My_Actions';
    $self-&amp;gt;{recce}        = $recce;
    $self-&amp;gt;{symbol_table} = {};
    local $My_Actions::SELF = $self;

    if ( not defined eval { $recce-&amp;gt;read($p_string); 1 } ) {

        # Add last expression found, and rethrow
        my $eval_error = $EVAL_ERROR;
        chomp $eval_error;
        die $self-&amp;gt;show_last_expression(), &quot;\n&quot;, $eval_error, &quot;\n&quot;;
    } ## end if ( not defined eval { $recce-&amp;gt;read($p_string); 1 })
    my $value_ref = $recce-&amp;gt;value();
    if ( not defined $value_ref ) {
        die $self-&amp;gt;show_last_expression(), &quot;\n&quot;,
            &quot;No parse was found, after reading the entire input\n&quot;;
    }
    return ${$value_ref}, $self-&amp;gt;{symbol_table};

} ## end sub calculate

&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;First we create a recognizer (aka a &quot;recce&quot;) from our grammar.
      Next we defined a parse object named &quot;&lt;tt&gt;$self&lt;/tt&gt;&quot;.
      (Object enthusiasts will, I hope, forgive a certain awkwardness at this stage.)
    &lt;/p&gt;&lt;p&gt;We call the
      &lt;tt&gt;read()&lt;/tt&gt;
      method on the recognizer with our string as
      its argument, check for errors,
      and then return the result.
      The calculator allows variables, whose values it keeps in a symbol table.
      These can be important side effect, so the symbol table is also returned
      by
      &lt;tt&gt;calculate()&lt;/tt&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Dealing with errors&lt;/h3&gt;
    &lt;p&gt;This calculator has error reporting that compares favorably with
      production languages.
      (Unfortunately, they often do not set the bar very high.)
      The Scanless interface, in its diagnostics will pinpoint where things
      went wrong from the technical point of view,
      and what it saw as the problem.
      This is often adequate as a diagnostic, but not always --
      the parsing may have ceased to reflect the programmer's intent before
      there was an actual parse error.
    &lt;/p&gt;&lt;p&gt;To help the programmer sync his intent with what Marpa saw,
      this calculator also prints the last
      &lt;tt&gt;expression&lt;/tt&gt;
      successfully
      recognized.
      Here's the code that finds it:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
sub show_last_expression {
    my ($self) = @_;
    my $recce = $self-&amp;gt;{recce};
    my ( $start, $end ) = $recce-&amp;gt;last_completed_range('expression');
    return 'No expression was successfully parsed' if not defined $start;
    my $last_expression = $recce-&amp;gt;range_to_string( $start, $end );
    return &quot;Last expression successfully parsed was: $last_expression&quot;;
} ## end sub show_last_expression
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;h3&gt;The semantics&lt;/h3&gt;
    &lt;p&gt;Here are a few of the simpler semantic closures:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
sub do_set_var {
    my ( $self, $var, undef, $value ) = @_;
    return $self-&amp;gt;{symbol_table}-&amp;gt;{$var} = $value;
}

sub do_negate {
    return -$_[2];
}

sub do_arg0 { return $_[1]; }
sub do_arg1 { return $_[2]; }
sub do_arg2 { return $_[3]; }
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;I have found modern programmers
      are usually very comfortable with procedural coding.
      (As an aside, this accounts for the popularity of recursive descent
      and left parsing in general -- it makes parsing look procedural.)
      Things get more complicated than examples above,
      but the full code can be found in the gist.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Announcing Marpa's Scanless interface</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/announce_scanless.html</link>
    <description>&lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
  &lt;p&gt;
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
        Marpa::R2&lt;/a&gt;'s
      Scanless interface is now out of beta and
      available in full release on CPAN.
      This interface allows Marpa to be used without the need to create
      a separate lexer (scanner),
      and increases Marpa's level of &quot;whipitupitude&quot;.
      Here's what a simple calculator looks like in the Scanless interface:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
:start ::= Script
Script ::= Expression+ separator =&amp;gt; comma action =&amp;gt; do_script
comma ~ [,]
Expression ::=
    Number
    | '(' Expression ')' action =&amp;gt; do_parens assoc =&amp;gt; group
   || Expression '**' Expression action =&amp;gt; do_pow assoc =&amp;gt; right
   || Expression '*' Expression action =&amp;gt; do_multiply
    | Expression '/' Expression action =&amp;gt; do_divide
   || Expression '+' Expression action =&amp;gt; do_add
    | Expression '-' Expression action =&amp;gt; do_subtract
Number ~ [\d]+
 
:discard ~ whitespace
whitespace ~ [\s]+
# allow comments
:discard ~ &amp;lt;hash comment&amp;gt;
&amp;lt;hash comment&amp;gt; ~ &amp;lt;terminated hash comment&amp;gt; | &amp;lt;unterminated
   final hash comment&amp;gt;
&amp;lt;terminated hash comment&amp;gt; ~ '#' &amp;lt;hash comment body&amp;gt; &amp;lt;vertical space char&amp;gt;
&amp;lt;unterminated final hash comment&amp;gt; ~ '#' &amp;lt;hash comment body&amp;gt;
&amp;lt;hash comment body&amp;gt; ~ &amp;lt;hash comment char&amp;gt;*
&amp;lt;vertical space char&amp;gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&amp;lt;hash comment char&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The full example, with semantics,
      is in
      &lt;a href=&quot;https://gist.github.com/4440418&quot;&gt;
        a Github gist&lt;/a&gt;.
      It is almost identical to the example in
      the Scanless interface documents, and to a test in Marpa::R2's test suite.
    &lt;/p&gt;&lt;p&gt;
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.038000/pod/BNF.pod&quot;&gt;
        Marpa's BNF interface&lt;/a&gt;
	came out of beta and into full release at the same time as the Scanless interface.
      Like the Scanless interface,
      the BNF interface allows you to write your grammar in a BNF variant.
      Unlike the Scanless interface, it requires you to do your own lexing.
    &lt;/p&gt;&lt;p&gt;The Scanless interface is a superset of the BNF interface, so
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.038000/pod/BNF.pod&quot;&gt;
    the documentation of the BNF interface&lt;/a&gt;
      is the best place to start for learning both.
      However, to work with either, you probably should already
      have at least some familiarity with
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.038000/pod/Marpa_R2.pod&quot;&gt;Marpa's
        standard interface&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Not long ago, my work on Marpa was a lone endeavour.
      One sign of Marpa's emergence is that my work
      now is often based on insights gained by others who have used Marpa.
      The BNF interface is based on one written by Peter Stuifzand.
      And the approach to scannerless parsing that I finally settled on
      was suggested to me by Andrew Rodland's prior work on pairing Marpa grammars.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>A self-parsing and self-lexing grammar</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/self_lex.html</link>
    <description>  &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/self_parse.html&quot;&gt;In
        a previous post&lt;/a&gt;, I showed a self-parsing grammar,
      written in Marpa's new BNF interface.
      That grammar was in a tradition going back to the 70's.
      Following the tradition, I cheated a bit.
      That grammar required,
      but did not include, a lexer to make a prepass over
      its input.
    &lt;/p&gt;&lt;p&gt;
      This post contains a self-parsing
      and self-lexing grammar,
      the one for Marpa's forthcoming Scanless interface.
      This grammar is about as self-contained as a grammar can get,
      short of being encoded into a
      &lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Turing_machine&quot;&gt;Universal
        Turing machine&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Many readers will
      prefer to be introduced to the Scanless interface
      by way of
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.035_003/pod/Scanless.pod&quot;&gt;
        a simpler example&lt;/a&gt;,
      but based on the response to the previous post I know
      there are others who share my fascination with
      self-description and self-exemplification.
      And there is something to be said for reading an example
      that is a final authority on itself.
    &lt;/p&gt;
    &lt;p&gt;
      This is certainly a practical example.
      The grammar that follows is used
      to parse itself and all other grammars written for the
      Marpa's Scanless interface.
      It is also used to parse the strings written
      for Marpa's BNF interface,
      the Scanless interface's predecessor.
    &lt;/p&gt;
    &lt;h3&gt;Starting out&lt;/h3&gt;
    &lt;p&gt;
      The grammar in this blog post is abridged a bit,
      and rearranged for ease of explanation.
      The original is
      &lt;a href=&quot;https://metacpan.org/source/JKEGL/Marpa-R2-2.035_003/lib/Marpa/R2/meta/metag.bnf&quot;&gt;
        here&lt;/a&gt;.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
# Copyright 2012 Jeffrey Kegler
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The file starts with legalese, which I've cut.
      (The grammar is under GNU's LGPL 3.0.)
      Note the hash comment -- since this is a self-describing self-lexer,
      the grammar will eventually tell us how it deals with hash comments.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
:start ::= rules
rules ::= rule+
rule ::= &amp;lt;start rule&amp;gt;
  | &amp;lt;empty rule&amp;gt;
  | &amp;lt;priority rule&amp;gt;
  | &amp;lt;quantified rule&amp;gt;
  | &amp;lt;discard rule&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The
      &lt;tt&gt;rules&lt;/tt&gt;
      symbol is the start symbol.
      Our grammar consists of a series of one or more rules,
      each one of which falls into one of five types.
    &lt;/p&gt;
    &lt;p&gt;
    &lt;/p&gt;&lt;p&gt;
      By my count,
      three of the rules in our self-describing grammar are
      themselves self-describing.
      The first and last rule above are two of them.
      The definition of
      &lt;tt&gt;rules&lt;/tt&gt;
      is itself a series
      of one or more
      &lt;tt&gt;rule&lt;/tt&gt;'s.
      And the definition of
      &lt;tt&gt;rule&lt;/tt&gt;
      is a
      &lt;tt&gt;&amp;lt;priority rule&amp;gt;&lt;/tt&gt;,
      which is
      one of the 5 types of
      &lt;tt&gt;rule&lt;/tt&gt;
      that are allowed.
    &lt;/p&gt;
    &lt;p&gt;
      The first two rules exemplify two of the other rule types:
      the first is a
      &lt;tt&gt;&amp;lt;start rule&amp;gt;&lt;/tt&gt;
      and the second is a
      &lt;tt&gt;&amp;lt;quantified rule&amp;gt;&lt;/tt&gt;.
      A start rule is defined as
      consisting of the
      &lt;tt&gt;:start&lt;/tt&gt;
      pseudo-symbol,
      followed by a
      &lt;tt&gt;::=&lt;/tt&gt;
      operator,
      followed by a
      &lt;tt&gt;symbol&lt;/tt&gt;:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;start rule&amp;gt; ::= (':start' &amp;lt;op declare bnf&amp;gt;) symbol
&amp;lt;op declare bnf&amp;gt; ~ '::='
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      The parentheses can be ignored.
      Their purpose is to make life easier on the semantics
      -- they surround symbols
      that are hidden from the semantics.
    &lt;/p&gt;
    &lt;h3&gt;&quot;What I say&quot; versus &quot;what I mean&quot;&lt;/h3&gt;
    &lt;p&gt;When we define a grammar rule,
      sometimes we are asking Marpa to do exactly what
      we say, character for character.
      For example, in the
      &quot;&lt;tt&gt;&amp;lt;op declare bnf&amp;gt; ~ '::='&lt;/tt&gt;&quot; rule above,
      we are saying that the symbol
      &lt;tt&gt;&amp;lt;op declare bnf&amp;gt;&lt;/tt&gt;
      is exactly the string '::=',
      nothing more and nothing less.
      &quot;Do exactly what I say&quot; rules are called lexical rules,
      and for them we use the match operator (&quot;&lt;tt&gt;~&lt;/tt&gt;&quot;).
    &lt;/p&gt;
    &lt;p&gt;In other cases, we are asking Marpa to &quot;do what I mean&quot;.
      That is, we are saying that &quot;the rule essentially consists of these symbols,
      but I also want you
      to do what is reasonable with whitespace and comments.&quot;
      An example of a &quot;do what I mean&quot; rule was
      &quot;&lt;tt&gt;rules ::= rule+&lt;/tt&gt;&quot;.
      Within, between, before and after the
      &lt;tt&gt;rule&lt;/tt&gt;
      symbols,
      there will be comments and whitespace.
      The whitespace will sometimes be optional,
      and will sometimes be required.
    &lt;/p&gt;
    &lt;p&gt;
      Spelling all the comment and whitespace handling
      out would be very tedious and error-prone.
      We want there to be rules of a kind that &quot;do what we mean&quot;.
      Marpa's &quot;do what I mean&quot; rules are called &quot;structural&quot; rules,
      and are identified by the BNF operator (&quot;&lt;tt&gt;::=&lt;/tt&gt;&quot;).
    &lt;/p&gt;&lt;p&gt;Some structural rules have lexical content within them.
      An example was
      &quot;&lt;tt&gt;&amp;lt;start rule&amp;gt; ::= (':start' &amp;lt;op declare bnf&amp;gt;) symbol&lt;/tt&gt;&quot;.
      That is basically a structural rule, where Marpa should &quot;do what I mean&quot;
      with whitespace and comments.
      But it also contains a string,
      &lt;tt&gt;':start'&lt;/tt&gt;.
      When a string or a character class
      occurs inside a structural rule,
      Marpa knows how to treat them properly.
      Marpa knows, for example,
      that whitespace is not OK
      between the &quot;&lt;tt&gt;a&lt;/tt&gt;&quot; and the &quot;&lt;tt&gt;r&lt;/tt&gt;&quot; of &quot;&lt;tt&gt;:start&lt;/tt&gt;&quot;.
    &lt;/p&gt;
    &lt;p&gt;
      The &quot;what I mean&quot; versus &quot;what I say&quot; distinction
      corresponds very closely to the distinction in Perl 6 grammars
      between the &quot;rule&quot; and &quot;token&quot;.
      It also corresponds to the traditional division of labor in compilers,
      between the lexer and the parser proper.
    &lt;/p&gt;
    &lt;h3&gt;Rules&lt;/h3&gt;
    &lt;p&gt;Above we saw an example of a quantified rule: &quot;&lt;tt&gt;rules ::= rule+&lt;/tt&gt;&quot;.
      Here is the definition:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;quantified rule&amp;gt;
  ::= lhs &amp;lt;op declare&amp;gt;
    &amp;lt;single symbol&amp;gt; quantifier &amp;lt;adverb list&amp;gt;
lhs ::= &amp;lt;symbol name&amp;gt;
&amp;lt;op declare&amp;gt;
  ::= &amp;lt;op declare bnf&amp;gt; | &amp;lt;op declare match&amp;gt;
&amp;lt;op declare match&amp;gt; ~ '~'
quantifier ::= '*' | '+'
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      A quantified rule contains a left hand side (LHS) symbol name,
      one of the two declaration operators,
      a
      &lt;tt&gt;single symbol&lt;/tt&gt;,
      a plus or minus &quot;quantifier&quot;,
      and an adverb list.
      The adverb list can be empty, as it was in our example.
      (In fact the adverb list has been empty in every rule so far.)
    &lt;/p&gt;
    &lt;p&gt;
      Next come the two rule types that we've yet to see:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;discard rule&amp;gt;
  ::= (':discard' &amp;lt;op declare match&amp;gt;) &amp;lt;single symbol&amp;gt;
&amp;lt;empty rule&amp;gt; ::= lhs &amp;lt;op declare&amp;gt; &amp;lt;adverb list&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      We'll explain what a &quot;discard rule&quot; is when we encounter one.
      An empty rule indicates that its LHS symbol is nullable.
      We won't encounter an empty rule in this grammar.
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;priority rule&amp;gt; ::= lhs &amp;lt;op declare&amp;gt; priorities
priorities ::= alternatives+
    separator =&amp;gt; &amp;lt;op loosen&amp;gt; proper =&amp;gt; 1
&amp;lt;op loosen&amp;gt; ~ '||'
alternatives ::= alternative+
    separator =&amp;gt; &amp;lt;op equal priority&amp;gt; proper =&amp;gt; 1
alternative ::= rhs &amp;lt;adverb list&amp;gt;
&amp;lt;op equal priority&amp;gt; ~ '|'
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Most rules, including most of the rules we've already seen,
      are priority rules.
      Priority rules are
      so-called because in their most complicated form they can express
      a precedence scheme.
      The typical rule in a grammar is a priority rule with only
      one priority -- a &quot;simple&quot; priority rule.
      All priority rules in this grammar will be of the simple kind.
    &lt;/p&gt;
    &lt;p&gt;
      Within priorities, there can be alternatives,
      and we have seen examples of these.
      The self-defining rule that defined a
      &lt;tt&gt;rule&lt;/tt&gt;
      stated that it was one of a set of 5 possible
      rule types (priority rule being among those types).
      In that self-defining rule,
      the different types of rule were alternatives within a single
      priority.
    &lt;/p&gt;&lt;p&gt;And, as long as we are on the subject of self-defining rules,
      there are three of them in this grammar, of which we have previously
      identified two.
      The definition of
      &lt;tt&gt;&amp;lt;priority rule&amp;gt;&lt;/tt&gt;
      is the third and last self-defining rule --
      it is itself a priority rule.
    &lt;/p&gt;
    &lt;h3&gt;Symbols&lt;/h3&gt;
    &lt;p&gt;We've used
      &lt;tt&gt;symbol&lt;/tt&gt;,
      &lt;tt&gt;&amp;lt;symbol name&amp;gt;&lt;/tt&gt;,
      and
      &lt;tt&gt;&amp;lt;single symbol&amp;gt;&lt;/tt&gt;
      a few times.
      It's time to see how they are defined:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;single symbol&amp;gt; ::=
    symbol
  | &amp;lt;character class&amp;gt;
symbol ::= &amp;lt;symbol name&amp;gt;
&amp;lt;symbol name&amp;gt; ::= &amp;lt;bare name&amp;gt;
&amp;lt;symbol name&amp;gt; ::= &amp;lt;bracketed name&amp;gt;
&amp;lt;bare name&amp;gt; ~ [\w]+
&amp;lt;bracketed name&amp;gt; ~ '&amp;lt;' &amp;lt;bracketed name string&amp;gt; '&amp;gt;'
&amp;lt;bracketed name string&amp;gt; ~ [\s\w]+
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;At this point,
      &lt;tt&gt;symbol&lt;/tt&gt;
      and
      &lt;tt&gt;&amp;lt;symbol name&amp;gt;&lt;/tt&gt;
      are
      essentially the same thing:
      someday there may be another way to specify symbols
      other than by name.
      &lt;tt&gt;&amp;lt;single symbol&amp;gt;&lt;/tt&gt;
      means any expression guaranteed
      to produce a single symbol.
      &lt;tt&gt;symbol&lt;/tt&gt;
      is obviously one;
      a character class is the other.
    &lt;/p&gt;
    &lt;p&gt;The rules above contain our first mention
      of character classes and,
      by coincidence,
      our first use of character classes.
      Character classes are enclosed in square brackets,
      and look exactly like Perl character classes.
      In fact, they are implemented as Perl character classes, memoized for
      efficiency.
    &lt;/p&gt;
    &lt;p&gt;Now that we know what a symbol can be,
      let's look at how right hand sides are built up:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
rhs ::= &amp;lt;rhs primary&amp;gt;+
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;single symbol&amp;gt;
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;single quoted string&amp;gt;
&amp;lt;rhs primary&amp;gt; ::= &amp;lt;parenthesized rhs primary list&amp;gt;
&amp;lt;parenthesized rhs primary list&amp;gt;
  ::= ('(') &amp;lt;rhs primary list&amp;gt; (')')
&amp;lt;rhs primary list&amp;gt; ::= &amp;lt;rhs primary&amp;gt;+
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;A right hand side (RHS) is a sequence of one or more RHS &quot;primaries&quot;.
      A RHS primary can be a single symbol, a string in single quotes,
      or a sublist of one or more RHS primaries in parentheses.
    &lt;/p&gt;&lt;h3&gt;Adverbs&lt;/h3&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;adverb list&amp;gt; ::= &amp;lt;adverb item&amp;gt;*
&amp;lt;adverb item&amp;gt; ::=
      action
    | &amp;lt;left association&amp;gt;
    | &amp;lt;right association&amp;gt;
    | &amp;lt;group association&amp;gt;
    | &amp;lt;separator specification&amp;gt;
    | &amp;lt;proper specification&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;Adverb lists are lists of zero or more adverbs, which can be of one of six kinds.
      Of these six, four do not occur in this grammar:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;left association&amp;gt; ::= ('assoc' '=&amp;gt;' 'left')
&amp;lt;right association&amp;gt; ::= ('assoc' '=&amp;gt;' 'right')
&amp;lt;group association&amp;gt; ::= ('assoc' '=&amp;gt;' 'group')
action ::= ('action' '=&amp;gt;') &amp;lt;action name&amp;gt;
&amp;lt;action name&amp;gt; ::= &amp;lt;bare name&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;
      Three of the unused
      adverbs have to do with the associativity (right/left/group)
      of priorities.
      Since all our &quot;prioritized&quot; rules are trivial (have only one priority),
      this grammar does not use them.
      (Their use is described in
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
        the documentation of Marpa's BNF interface&lt;/a&gt;.)
      We also will not see
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs in this grammar,
      for reasons explained below.
    &lt;/p&gt;
    &lt;p&gt;
      Here are the two adverbs that we do see:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;separator specification&amp;gt;
  ::= ('separator' '=&amp;gt;') &amp;lt;single symbol&amp;gt;
&amp;lt;proper specification&amp;gt; ::= ('proper' '=&amp;gt;') boolean
boolean ~ [01]
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;These adverbs are used for quantified rules.
      One specifies a &quot;separator&quot; that can go between items of the series.
      The other specifies whether separation is &quot;proper&quot; or not.
      (When
      &lt;tt&gt;proper&lt;/tt&gt;
      is 0, a separator is allowed after the last item of a series.
      When that is the case,
      the separator does not really always separate two items
      and in that sense the separator is not &quot;proper&quot;.)
    &lt;/p&gt;&lt;h3&gt;Discarded tokens&lt;/h3&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
:discard ~ whitespace
whitespace ~ [\s]+
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;The two rules say that sequences of whitespace are recognized
      as tokens, then discarded.
      Perl-style comments are handled in the same way:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
# allow comments
:discard ~ &amp;lt;hash comment&amp;gt;
&amp;lt;hash comment&amp;gt; ~ &amp;lt;terminated hash comment&amp;gt;
  | &amp;lt;unterminated final hash comment&amp;gt;
&amp;lt;terminated hash comment&amp;gt;
  ~ '#' &amp;lt;hash comment body&amp;gt; &amp;lt;vertical space char&amp;gt;
&amp;lt;unterminated final hash comment&amp;gt;
  ~ '#' &amp;lt;hash comment body&amp;gt;
&amp;lt;hash comment body&amp;gt; ~ &amp;lt;hash comment char&amp;gt;*
&amp;lt;vertical space char&amp;gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&amp;lt;hash comment char&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;&quot;Unterminated final hash comments&quot; deal with the special
      case of hash comments at the end of a file,
      when that file is not properly
      terminated with a newline.
      The
      &lt;tt&gt;&amp;lt;unterminated final hash comment&amp;gt;&lt;/tt&gt;
      symbol is an example of how
      a long angle bracketed symbol name can make things clearer.
      Without the long name, it might not be evident what that rule and symbol
      were trying to accomplish.
    &lt;/p&gt;
    &lt;p&gt;
      Long symbol names
      have a cleaner look than comments,
      but they are not a panacea.
      They have
      the special advantage that the description goes wherever the symbol
      name goes.
      But when the description is too long,
      that advantage becomes a disadvantage.
    &lt;/p&gt;&lt;h3&gt;Strings&lt;/h3&gt;
    &lt;p&gt;In the next snippet, defining single-quoted strings,
      the description is clearly too long for the symbol name,
      so much of it does go into a comment.
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
# In single quotes strings and character classes
# no escaping or internal newlines, and disallow empty string
&amp;lt;single quoted string&amp;gt;
  ~ ['] &amp;lt;string without single quote or vertical space&amp;gt; [']
&amp;lt;string without single quote or vertical space&amp;gt;
  ~ [^'\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]+
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;Note two Unicode vertical whitespace codepoints,
      U+2028 and U+2029, are included.
      The implementation only supports 7-bit ASCII,
      so for the moment these accomplish nothing.
      But when Unicode support is added, the grammar won't need to be changed.
    &lt;/p&gt;&lt;h3&gt;Character classes&lt;/h3&gt;
    &lt;p&gt;Finally, there are character classes:
    &lt;/p&gt;&lt;blockquote&gt;
      &lt;pre&gt;
&amp;lt;character class&amp;gt; ~ '[' &amp;lt;cc string&amp;gt; ']'
&amp;lt;cc string&amp;gt; ~ &amp;lt;cc character&amp;gt;+
&amp;lt;cc character&amp;gt; ~ &amp;lt;escaped cc character&amp;gt;
  | &amp;lt;safe cc character&amp;gt;
&amp;lt;escaped cc character&amp;gt; ~ '\' &amp;lt;horizontal character&amp;gt;

# hex 5d is right square bracket
&amp;lt;safe cc character&amp;gt;
  ~ [^\x{5d}\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]

# a horizontal character is any character that is not vertical space
&amp;lt;horizontal character&amp;gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;/pre&gt;&lt;/blockquote&gt;
    &lt;p&gt;These are Perl character classes,
      and are passed unaltered to Perl for interpretation.
      Marpa needs to recognize that they start and end with square brackets.
      And it also must recognize enough of their internals
      to deal with escaped square brackets,
      which makes
      them the most
      complicated lexeme of the grammar.
    &lt;/p&gt;
    &lt;h3&gt;Longest tokens matching&lt;/h3&gt;
    &lt;p&gt;When there is a choice of lexicals, Marpa follows a longest tokens matching strategy.
      The effect is usually that it does what you mean.
      (In part this is because longest token match
      is the usual default for regular expressions and
      lexical analyzers, so that programmers are trained by their tools
      to really mean a longest match
      whenever they specify a match.)
    &lt;/p&gt;&lt;p&gt;Most of what longest-token-match does is obvious.
      For example,
      in the rule &quot;&lt;tt&gt;weeknights ~ 'Mon' | 'Tue' | 'Wed' | 'Thu'&lt;/tt&gt;&quot;,
      it recognizes that
      &lt;tt&gt;weeknights&lt;/tt&gt;
      is one symbol and not two symbols like
      &quot;&lt;tt&gt;wee&lt;/tt&gt;&quot; and &quot;&lt;tt&gt;knights&lt;/tt&gt;&quot;.
      Longest tokens match
      means that if you have a grammar where you specify both
      &lt;tt&gt;++&lt;/tt&gt;
      and
      &lt;tt&gt;+&lt;/tt&gt;
      as operators, Marpa will always prefer
      the longer operator:
      &lt;tt&gt;++&lt;/tt&gt;.
    &lt;/p&gt;&lt;p&gt;Because this is Marpa, there is a slight difference from the traditional longest
      &lt;b&gt;token&lt;/b&gt;
      matching.
      Note that in Marpa's matching strategy, &quot;tokens&quot; is plural.
      If more than one possibility has the same length, Marpa will try them all.
      This plays a role in our meta-grammar.
      For example,
      &lt;tt&gt;separator&lt;/tt&gt;
      is a keyword.
      But it is also a valid symbol name.
      Marpa allows it to be both, and figures out which is meant at the
      structural level, based on context.
    &lt;/p&gt;&lt;h3&gt;Semantics&lt;/h3&gt;
    &lt;p&gt;
      In practice, a grammar is usually tied tightly to a single semantics.
      This is an exception.
      The Scanless interface's meta-grammar is also the grammar for Marpa's
      BNF interface, and the BNF interface has a different semantics.
    &lt;/p&gt;
    &lt;p&gt;
      For most grammars in Marpa's BNF or Scanless interface,
      the semantics would be specified using
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs.
      Examples of the normal method of specifying
      semantics are in the documentation for
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
        the BNF interface&lt;/a&gt;
      and for
      &lt;a href=&quot;https://metacpan.org/module/JKEGL/Marpa-R2-2.035_003/pod/Scanless.pod&quot;&gt;
        the Scanless interface&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      In this special-case grammar,
      there are no
      &lt;tt&gt;action&lt;/tt&gt;
      adverbs.
      Marpa waits until it knows which interface the grammar will be used for.
      At that point the internals use the symbol names to map rules to
      actions on a &quot;just in time&quot;
      basis.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      Comments on this post can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Smart whitespace and the Ruby Slippers</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/whitespace.html</link>
    <description>  &lt;h3&gt;Scannerless parsing&lt;/h3&gt;
    &lt;p&gt;
      &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
      I've been working
      on a &quot;scannerless&quot; Marpa interface.
      &quot;Scannerless&quot; means that the user does not need to write
      a separate lexer --
      the lexer (scanner) is included in the parser.
      One of my working examples is
      the synopsis from
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2&quot;&gt;
        the main Marpa::R2 POD page&lt;/a&gt;,
      rewritten to do its own lexing:
    &lt;/p&gt;
    &lt;blockquote&gt;
      &lt;pre&gt;
    &lt;tt&gt;
:start ::= Expression
Expression ::=
       Number
    || Expression '*' Expression action =&gt; do_multiply
    || Expression '+' Expression action =&gt; do_add
Number ~ digits '.' digits action =&gt; do_literal
Number ~ digits action =&gt; do_literal
digits ~ [\d]+
    &lt;/tt&gt;
      &lt;/pre&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;Here the notation is that of
      &lt;a href=&quot;http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/iterative.html&quot;&gt;
        my last post&lt;/a&gt;,
      as
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
        documented here&lt;/a&gt;.
      New for the scannerless parser are
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;
        the
        &lt;tt&gt;:start&lt;/tt&gt;
        pseudo-symbol, which indicates the start rule;
      &lt;/li&gt;&lt;li&gt;
        rules with a tilde (&quot;&lt;tt&gt;~&lt;/tt&gt;&quot;) to separate
        LHS from RHS: these indicate rules whose
        whitespace is to be left as-is
      &lt;/li&gt;&lt;li&gt;single-quoted strings, to tell Marpa which
        character to look for; and
      &lt;/li&gt;&lt;li&gt;square-bracketed character classes, to
        tell Marpa to look for a class of characters.
        Their interpretation is done by Perl,
        and therefore the allowed classes are exactly those
        accepted by your version of Perl.
      &lt;/li&gt;&lt;/ul&gt;
    &lt;p&gt;
      Valid strings in this language are &quot;&lt;tt&gt;15329 + 42 * 290 * 711&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;42*3+7&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;3*3+4* 4&lt;/tt&gt;&quot;,
      along with all their whitespace variants.
    &lt;/p&gt;
    &lt;p&gt;My recent posts have been tutorial.
      My work on scannerless parsing is
      not quite ready for a tutorial presentation,
      so this post will be conceptual.
      It is about an interesting issue that arises in
      scannerless parsing,
      one which Perl 6 also had to solve,
      and which Marpa solves in a new and different way.
      That issue is whitespace.
    &lt;/p&gt;
    &lt;h3&gt;Dealing with whitespace&lt;/h3&gt;
    &lt;p&gt;For the statements with a declaration operator of
      &lt;tt&gt;::=&lt;/tt&gt;,
      whitespace is handled automatically by Marpa.
      Valid strings in the above language are
      &quot;&lt;tt&gt;42*3+7&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;42 * 3 + 7&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;42 * 3+7&lt;/tt&gt;&quot;,
      all of which yield 133 as the answer.
      The trick is to, on one hand, allow whitespace to be optional
      and, on the other hand, recognize that strings like &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;
      must be a single number.
      That is, the parser should not recognize optional whitespace
      between the two digits and decide that
      &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;,
      is actually two numbers:
      &quot;&lt;tt&gt;4&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;2&lt;/tt&gt;&quot;.
    &lt;/p&gt;
    &lt;p&gt;
      The Perl 6 project has already taken on scannerless parsing.
      My methods for dealing with whitespace are based on theirs.
      Central to
      their solution is &quot;smart whitespace&quot;.
      (&quot;Smart whitespace&quot; is my term --
      the
      &lt;a href=&quot;http://perlcabal.org/syn/S05.html&quot;&gt;
        Perl 6 doc&lt;/a&gt;
      is more matter-of-fact.)
      Smart whitespace is whitespace which is optional, except between
      word characters.
      Stated another way, smart whitespace is either explicit whitespace,
      or a word boundary.
      In the case of &quot;&lt;tt&gt;42&lt;/tt&gt;&quot;,
      &quot;&lt;tt&gt;4&lt;/tt&gt;&quot; and
      &quot;&lt;tt&gt;2&lt;/tt&gt;&quot; are both word characters, so there is no
      word boundary between them, and therefore no smart whitespace.
    &lt;/p&gt;
    &lt;h3&gt;Implementing smart whitespace&lt;/h3&gt;
    &lt;p&gt;
      Left parsers (like that which Perl 6 uses)
      often know very little about the context of the parse.
      But left parsers do know the current &quot;character transition&quot; --
      what the previous character was,
      and what the current character is.
      In a left parser, finding word boundaries for the
      purpose of detecting smart whitespace fits in
      nicely with the way it works in general.
    &lt;/p&gt;
    &lt;p&gt;Marpa, of course,
      also knows the previous and current characters.
      It is certainly possible for
      Marpa to check every transition for a word boundary.
      But in Marpa's case, this check would
      be an additional overhead, handling just one special case.
      It'd be nice if we could look for word boundaries in a cool Marpa-ish way,
      preferably one with efficiency advantages.
    &lt;/p&gt;
    &lt;h3&gt;Out come the Ruby Slippers&lt;/h3&gt;
    &lt;p&gt;&quot;Ruby Slippers&quot; parsing, as a reminder, is new with Marpa,
      despite seeming a very obvious concept.
      It amounts to adjusting the input to the parser based on what
      the parser wants.
      This can be seen as assuring the parser that whatever it wishes
      for will happen, the same power that was conferred on Dorothy
      in
      &lt;em&gt;Wizard of Oz&lt;/em&gt;
      by a happy choice of footware.
    &lt;/p&gt;
    &lt;p&gt;
      To make the Ruby Slippers work in this case,
      we make a word boundary a special kind of virtual token,
      and we define smart whitespace to be one of two things:
    &lt;/p&gt;&lt;ul&gt;
      &lt;li&gt;
        A sequence of one or more characters of
        real, physical whitespace.
      &lt;/li&gt;&lt;li&gt;
        A virtual word-boundary token.
      &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;
      We then proceed normally with the parse,
      until there's a problem.
      When the parser reports a problem,
      we ask it if it is looking for one
      of the virtual word boundary tokens.
      If so, we give it one and continue.
      Why does life have to be difficult?
    &lt;/p&gt;
    &lt;p&gt;
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  <item>
    <title>Announcing a full release of Marpa::R2</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/11/announce_r2.html</link>
    <description>  &lt;h3&gt;Announcing Marpa::R2&lt;/h3&gt;
    &lt;!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      --&gt;
    &lt;p&gt;
      &lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
        Marpa::R2&lt;/a&gt;
      is now in full, official release.
      For those new to this blog, Marpa::R2 is an efficient, practical general
      BNF parser, targeted at applications too complex for
      regular expressions.
      Marpa::R2 is based on
      &lt;a href=&quot;http://jeffreykegler.github.com/Marpa-web-site/&quot;&gt;
        the Marpa parsing algorithm&lt;/a&gt;.
      New, but squarely based on the published literature,
      the Marpa algorithm
      parses every class of grammar in practical use today
      in linear time.
    &lt;/p&gt;
    &lt;p&gt;Marpa::R2 is the successor to Marpa::XS and
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;installs and runs on Windows.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;has better error reporting.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;is faster.
        &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;
          has a cleaner, simpler interface.
        &lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
    &lt;a href=&quot;https://metacpan.org/module/Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;
    remains available and,
      since changes to it are now on a &quot;bug fix only&quot; basis,
      should be quite stable.
      While Marpa::R2's interface will have a familiar look
      to users of Marpa::XS, it is not fully compatible:
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::Changes&quot;&gt;
      changes are documented here&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Those who have been following this blog may have noticed
      that
      &lt;a href=&quot;https://metacpan.org/module/Marpa::R2::BNF&quot;&gt;
      a new BNF interface&lt;/a&gt;
      has been added to Marpa::R2.
      This is growing --
      I am currently adding scannerless parsing to it,
      which means that applications will be able to run
      Marpa::R2 without a lexer.
      Because the BNF interface is new
      and still under very active development,
      it is being kept in beta status for the time being.
    &lt;/p&gt;
    &lt;h3&gt;Comments&lt;/h3&gt;
    &lt;p&gt;
      The Windows port of Marpa was the work of Jean-Damien Durand,
      who utilized Alberto Sim&amp;otilde;es'
      &lt;a href=&quot;http://search.cpan.org/dist/Config-AutoConf/&quot;&gt;
        Config::AutoConf&lt;/a&gt;.
      Comments on this post
      can be sent to the Marpa Google Group:
      &lt;code&gt;marpa-parser@googlegroups.com&lt;/code&gt;
    &lt;/p&gt;</description>
  </item>
  </channel>
</rss>
