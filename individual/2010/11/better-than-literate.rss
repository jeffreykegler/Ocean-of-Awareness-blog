<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Better than Literate!</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2010/11/17#better-than-literate</link>
    <description>&lt;p&gt;I'm converting Marpa
to XS and have started to use Cweb.
Cweb is
the C version of the &quot;literate programming&quot; system pioneered
by Don Knuth.
I'm pleasantly surprised by it.
Cweb adds fun to the programming experience
and is helping in more ways than the phrase
&quot;literate programming&quot; would suggest.

&lt;p&gt;
One very important feature of Cweb
is something that would seem to be a nuisance,
or at best an implementation detail.
The &lt;file&gt;.w&lt;/file&gt; file
which contains the Cweb is now the &quot;source&quot;.
The
&lt;file&gt;.c&lt;/file&gt; and
&lt;file&gt;.h&lt;/file&gt; files are now &quot;built files&quot;.
I am no longer working with the C language
&quot;translation units&quot;.
(&quot;Translation unit&quot;
is standards-committee-speak for
the text which is
directly input into the C compiler.
The term is used in attempt to distance the standard from
file conventions.)

&lt;p&gt;
Moving one step back from the &quot;translation unit&quot;
separates the presentation of the code
from the issues of linkage and scope.
Over the years,
I'd gotten used to
organizing my code
around the visibility rules for the compiler and
the linker.
With Cweb,
I can
lay out C code
in the same way that I think about it.
It surprises me how liberating this is.

&lt;p&gt;Suppose we are adding an element to a C structure.
Typically required might be:
&lt;ol&gt;
&lt;li&gt;A &lt;var&gt;typedef&lt;/var&gt; for a type
that is particularly complex.

&lt;li&gt;The entries in the &lt;var&gt;struct&lt;/var&gt;.
&lt;li&gt;Initialization of these entries.
&lt;li&gt;&quot;Destruction&quot; of those entries: freeing any memory or other resources
they use.
&lt;li&gt;Definition of the function bodies for mutators, accessors, etc.
&lt;li&gt;Public prototypes for some of the functions.
&lt;li&gt;Private prototypes for other functions.
&lt;/ol&gt;
Often, each of these would be put at a different location.
But all these bits of code are written and debugged together.
If you ever want to change the data structures,
all these bits of code would have to be tracked down again.
True, skill at picking good names
and at performing searches on
the source can make this sort of thing tractable.
But it is also true that some of the programming skills
we've developed over the years could 
aptly be called symptoms.

&lt;p&gt;Here is some C logic which, while very small, nonetheless has 6 of the 7 
components listed above.
In Cweb I was able to put them all together.  Here's the bottom of one page of my &quot;woven&quot; Cweb code:
&lt;img alt=&quot;callback1.png&quot; src=&quot;http://blogs.perl.org/users/jeffrey_kegler/callback1.png&quot; width=&quot;723&quot; height=&quot;169&quot; class=&quot;mt-image-none&quot; style=&quot;&quot; /&gt;
&lt;p&gt;... and here is the top of the next:
&lt;img alt=&quot;callback2.png&quot; src=&quot;http://blogs.perl.org/users/jeffrey_kegler/callback2.png&quot; 
width=&quot;723&quot; height=&quot;623&quot; class=&quot;mt-image-none&quot; style=&quot;&quot; /&gt;
&lt;p&gt;For some readers, these samples may adequately illustrate my point.
For those curious about the code, I'll close with a few
explanations.  The code, as I said, is for the XS version of Marpa.
For those not familiar, &lt;a href=&quot;http://search.cpan.org/~jkegl/Marpa-0.200000/&quot;&gt;Marpa&lt;/a&gt;
is a general BNF parser generator -- it parses from any grammar that you can write in BNF.
If the grammar is of any of the kinds currently in practical use
(yacc, LR(k), LALR, LL, recursive descent, etc.), this parsing is in linear
time.

&lt;p&gt;Marpa uses Perl callbacks, and so the XS version must be able to call back
to Perl closures.
So where is all the Perl logic in my example?

&lt;p&gt;For the XS conversion, I'm separating the code into three layers:

&lt;ol&gt;
&lt;li&gt;
&lt;var&gt;libmarpa&lt;/var&gt;
is a &quot;pure C&quot; library, which implements the core
of the Marpa algorithm.
&lt;var&gt;libmarpa&lt;/var&gt;
is agnostic about whether it is called from Perl,
from another high level language, and even from other C code.
&lt;li&gt;There's a &quot;glue&quot; layer to tie the Perl code to &lt;var&gt;libmarpa&lt;/var&gt;.
This is in Perl's XS language.
XS can be thought of as a C dialect.
Special preprocessing converts XS into C code,
which is then compiled.
&lt;li&gt;Finally, there's a &quot;pure Perl&quot; wrapper.  User interface
issues are handled at this level.
&lt;/ol&gt;

&lt;p&gt;I am only using Cweb for &lt;var&gt;libmarpa&lt;/var&gt;.
(Cweb only understands C language.)

&lt;p&gt;Since &lt;var&gt;libmarpa&lt;/var&gt; has
no Perl-specific logic, its role in dealing with Perl callbacks is very simple.
&lt;var&gt;libmarpa&lt;/var&gt; needs code to store the callback (which from its point
of view is just a C function pointer),
and some other code to perform the callback.
C does not have closures, so to implement a poor man's version
of these, the callback is allowed an argment,
which can be examined and set.
It comes out to a couple of dozen lines of code,
the majority of which are declarations and data definitions.

&lt;p&gt;One thing is missing from the example -- &quot;destructor&quot; logic.
The pointers in the example do not &quot;own&quot; the things that they point to,
so there is no need to deallocate anything.
When allocation and deallocation are separate, it is easy to forget
whether you omitted deallocation logic because it was unnecessary,
or because you forgot.
Using Cweb, I always put allocation and deallocation together.
Perhaps that's not enough to make memory leaks a thing of the past,
but it certainly makes life easier.</description>
  </item>
  </channel>
</rss>
