<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title> Why the Bovicidal Rage? (Killing Yacc: 4)</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2010/12/26#why-the-bovicidal-rage-killing-yacc-4</link>
    <description>&lt;p&gt;
&lt;a href=&quot;http://www.flickr.com/photos/publicenergy/3299967437/in/set-72157614350778728/&quot;&gt;&lt;img alt=&quot;3299967437_6bae3ce6a8_z.jpg&quot; src=&quot;http://blogs.perl.org/users/jeffrey_kegler/3299967437_6bae3ce6a8_z.jpg&quot; width=&quot;640&quot; height=&quot;426&quot; class=&quot;mt-image-none&quot; style=&quot;&quot; /&gt;&lt;/a&gt;
&lt;kbd&gt;yacc&lt;/kbd&gt;
was a
major breakthrough.
For the first time, automatic generation of
of efficient, production-quality parsers was possible
for languages of practical interest.
Yacc-generated parsers had reasonable memory footprints.
They ran in linear time.

&lt;p&gt;&lt;a href=&quot;#NOTE1&quot;&gt;But error reporting was overlooked.&lt;/a&gt;
Then as now, the focus in analyzing algorithms was on power
-- what kinds of grammar an algorithm can parse --
and on resource consumption.
This leaves out something big.

&lt;p&gt;Our frameworks for analyzing things affect what we believe.
We find it hard to recognize a problem if our
framework makes us unable to  articulate it.
Complaints about &lt;var&gt;yacc&lt;/var&gt; tended to be kept to oneself.
But while &lt;var&gt;yacc&lt;/var&gt;'s
overt reputation flourished,
programmers were undergoing an almost Pavlovian
conditioning against it --
a conditioning through pain.

&lt;p&gt;With &lt;var&gt;yacc&lt;/var&gt;, you no longer need to write
your own parser.
If you put your grammar into a form that &lt;var&gt;yacc&lt;/var&gt; will accept,

&lt;var&gt;yacc&lt;/var&gt; writes your parser for you.
But over the years, people noticed -- it usually takes longer
to put a grammar into a form that &lt;var&gt;yacc&lt;/var&gt; will accept
than it does to write a recursive descent parser from scratch.
This is almost always true when someone was using &lt;var&gt;yacc&lt;/var&gt;
for the first time.
&lt;a href=&quot;#NOTE2&quot;&gt;
But it is usually true for &lt;var&gt;yacc&lt;/var&gt;
experts as well.&lt;/a&gt;

&lt;p&gt;Certain tools do have a high initial cost.
They make this acceptable with a payoff over
the lifetime of the software.
But in this respect also,

&lt;var&gt;yacc&lt;/var&gt; does worse than hand-written recursive descent --
much worse.

&lt;p&gt;The structure of a recursive descent parser reflects the structure
of the language being parsed.
Small changes in the language tend to require only small changes in the parser.
Major changes usually affect only that part of the grammar actually changed.
And how the recursive descent parser must change, and why,
is usually obvious even to a programmer
who does not make a specialty of parsing.

&lt;p&gt;
For a &lt;var&gt;yacc&lt;/var&gt; grammar, the change process
is not incremental -- each iteration is almost like
starting from scratch.
&lt;var&gt;yacc&lt;/var&gt; parsers work using LALR automata.
Small changes in the grammar often cause big changes to the LALR states.
Tracing the logic behind these changes is a challenge
even to those
familiar with the underlying math --
one which they usually find not worth the time and effort.
This is one reason that those experienced with &lt;var&gt;yacc&lt;/var&gt; find it nearly
as hard to use as beginners did -- for real-world problems,
understanding the LALR states is simply too hard for anyone.
Experts, like non-experts, are forced to fix &lt;var&gt;yacc&lt;/var&gt;

grammars using trial and error.

&lt;p&gt;&lt;var&gt;yacc&lt;/var&gt;'s demands
follow the nearly incomprehensible logic of the LALR
automaton.
Adapting a grammar to &lt;var&gt;yacc&lt;/var&gt; is a
struggle, during which you
watch your grammar become less and less a
reflection of what you were originally trying to do.
One of the most difficult tasks
in programming, it is almost one of the most unsatisifying
and unrewarding.

&lt;h2&gt;The Fourth Requirement for Replacing &lt;var&gt;yacc&lt;/var&gt;:
Easy Diagnosis of Grammar Problems&lt;/h2&gt;

&lt;p&gt;The easiest way to deal with grammar problems is to arrange for them
not to happen.
You can do this if you have a notation for the grammar which is
&lt;ol&gt;
&lt;li&gt;A natural and intuitive way to express the grammar, and which
&lt;li&gt;Makes it literally impossible to specify a problem grammar.
&lt;/ol&gt;

&lt;p&gt;The notation for
&lt;a href=&quot;#NOTE3&quot;&gt;regular expressions&lt;/a&gt;
has these two properties,
and that is a major reason for the enduring popularity
of regular expressions.
Once you get used to its limits,
regular expression notation becomes a natural way to
describe languages.
And regular expression notation
makes it impossible to specify
anything that is &lt;b&gt;not&lt;/b&gt; a regular expression.

&lt;p&gt;More powerful parsing algorithms have these same two properties
when they accept all context-free grammars (as
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;
does).
The context-free grammars are those you can write in BNF, and vice versa.
BNF is  (again, modulo some getting-used-to) a natural and intuitive way
to express a language, and you don't have to worry about specifying a language
which is harder than context-free -- the BNF notation makes that impossible.

&lt;p&gt;&lt;var&gt;yacc&lt;/var&gt; uses BNF as its notation
for expressing grammars, but the most natural way to express a practical
grammar in BNF is almost never an LALR grammar.
No natural or intutive notation is known
that describes only LALR grammars, even after 40 years of
considerable interest in them.
I have to doubt that such a notation ever will be found.

&lt;h2&gt;Notes&lt;/h2&gt;

&lt;p&gt;&lt;a name=&quot;NOTE1&quot;&gt;Note 1: &lt;/a&gt;
It has definitely been the tradition to
understate the importance of error reporting,
or even to ignore it entirely.
But I should point out
that I have not consulted Knuth's and DeRemer's original papers,
which are behind paywalls.
Also, things seem to be getting better, particularly with the arrival
of the
&lt;a href=&quot;http://www.few.vu.nl/~dick/PT2Ed.html&quot;&gt;
very important textbook by Grune and Jacobs&lt;/a&gt;,
which does devote significant attention to the error
reporting properties of the various algorithms.

&lt;p&gt;&lt;a name=&quot;NOTE2&quot;&gt;Note 2: &lt;/a&gt;
Perhaps because reporting that you found it impossible to
use one of the standard
tools in our field
was more likely to produce conclusions
about your competence than about the tool,
the tradition among &lt;var&gt;yacc&lt;/var&gt; users was to suffer in silence.
One good 1995 account of trials with &lt;var&gt;yacc&lt;/var&gt; is
&lt;a href=&quot;http://groups.google.com/group/comp.compilers/msg/a5d260aa50c05685?hl=en&amp;dmode=source&quot;&gt;
this contribution to comp.compilers&lt;/a&gt;.
And there is one person who I
believe has an intuitive understanding of LALR: Larry Wall.
Certainly I doubt there is anyone alive whose practical knowledge
of LALR is better than Larry's.
That makes it very significant that
Perl 6 does not use

&lt;var&gt;yacc&lt;/var&gt; or any other LALR based parser.

&lt;p&gt;&lt;a name=&quot;NOTE3&quot;&gt;Note 3: &lt;/a&gt;
Here I am talking about pure regular expressions.
Perl regexes are much more powerful than regular expressions,
and the power comes with tradeoffs:
The notation is no longer
as simple or intuitive.</description>
  </item>
  </channel>
</rss>
