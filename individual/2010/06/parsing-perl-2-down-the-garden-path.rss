<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Parsing Perl 2: Down the Garden Path</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2010/06/28#parsing-perl-2-down-the-garden-path</link>
    <description>&lt;h2&gt;The Garden Path&lt;/h2&gt;

&lt;p&gt;In Perl 5.10, the following code is a syntax error:
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;{42;{1,2,3;4}}
&lt;/code&gt;&lt;/pre&gt;
If you try it,
what you'll see 
is something like this:
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;syntax error at (eval 25) line 1, near &quot;;4&quot;
syntax error at (eval 25) line 1, near &quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TPP is based on an algorithm called LALR.
(To avoid confusion when discussing various programs which parse Perl,
I will call the one that comes with the Perl distribution
the Tradition Perl Parser, or TPP.)
If you look at 
&lt;kbd&gt;perly.y&lt;/kbd&gt;,
you will find a real achievement
in LALR parsing.
and therefore in computer language parsing in general.
But LALR has its limits and even in the TPP
these show up every now and then.

&lt;p&gt;Let's call our first example the Garden Path Code Block.
What is happening here?
Perl is being taken
&quot;down the garden path&quot; between the inner set of
curly braces.
TPP starts out down the path and, based on what it sees,
decides that it is parsing an anonymous hash.
TPP commits to that choice and then trainwrecks on the semicolon.
&lt;a href=&quot;http://search.cpan.org/dist/PPI/&quot;&gt;PPI&lt;/a&gt;
does no better.
PPI recognizes the Garden Path Code Block, but it parses it
as an anonymous hash, which is wrong.

&lt;p&gt;I am prototyping a new Perl syntax analyzer using
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;,
my new parser.
Marpa parses anything you can write in BNF, using ideas based on those
by Jay Earley.
Marpa::Perl is still a prototype,
but it has no difficulty in
recognizing the Garden Path Code Block as a code block.

&lt;p&gt;LALR's problem is that it is based on a state machine.
LALR's state machine ran at speeds and used memory
in keeping with the computer technology of 1969, which is
when LALR was invented.
But the LALR state machine needs to make decisions based
on limited context.
When the LALR parser in
&lt;a href=&quot;http://cpansearch.perl.org/src/JESSE/perl-5.12.1/perly.y&quot;&gt;perly.y&lt;/a&gt;
sees that semicolon, it is pretty much game over.

&lt;p&gt;LALR has always been
a tight squeeze
for the grammars of practical programming languages.
This is despite the fact that LALR has had decades to
condition 
language designers to accept its idea of what
&quot;practical&quot; means in a programming language.

&lt;p&gt;For Marpa, the Garden Path Code Block is not
even a serious challenge.
Marpa is based on Jay Earley's ideas.
These were the subject of 
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/jay-earleys-idea.html&quot;&gt;my last post&lt;/a&gt;. 
Briefly, the core idea is to create a table of &quot;Earley items&quot;.
Earley items are short records indicating parsing progress,
keyed to locations in the input.
For an Earley-based parser, a &quot;garden path&quot; is dealt with by having
Earley items record the multiple possibilities.
This need to deal with alternative possibilities
is not dissimilar to the one
which motivates other parsers to use more expensive strategies,
such as backtracking or parallel processing.

&lt;h2&gt;What the Man Page Says&lt;/h2&gt;

Suppose we go all the way down the &quot;garden path&quot;,
and it still is not clear whether the curly braces
enclose an anonymous hash or a code block?
If we alter our example to replace the deadly semicolon
with an insidious comma, this is what it looks like:
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;{42;{1,2,3,4}}
&lt;/code&gt;&lt;/pre&gt;
And for Perl 5.10, this is the result:
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;{'1' =&gt; 2,'3' =&gt; 4}
&lt;/code&gt;&lt;/pre&gt;
PPI seems to agree with Perl 5.10.

&lt;p&gt;Marpa::Perl, on the other hand, sees that this code is ambiguous.
It recognizes two parses.
The first parse is the one Perl and PPI see: an anonymous hash.
Marpa::Perl's second parse treats both sets of curlies as surrounding
code blocks.
In scalar context, the value which results from this second parse
is the number 4.

&lt;p&gt;In cases of desperation,
we look at the documentation.
It takes some searching to find it,
but there is
a very relevant discussion in
a section of the perlref man page.
&lt;a href=&quot;http://perldoc.perl.org/perlref.html#Making-References&quot;&gt;
It is worth reading&lt;/a&gt;.
Of its several examples,
this is the most interesting:
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;sub showem {       { @_ } }   # ambiguous (currently ok, but may change)
&lt;/code&gt;&lt;/pre&gt;
Here Perl's rules of thumb result in the &quot;&lt;tt&gt;{ @_ }&lt;/tt&gt;&quot;
being parsed as a code block --
the opposite of the behavior in our previous example.

&lt;p&gt;The threat made in the comment --
that TPP's current behavior may change --
would be a hard thing to make good on.
Assuming array context,
the effect of having the
&lt;a href=&quot;http://perldoc.perl.org/perlref.html&quot;&gt;perlref&lt;/a&gt;
example flip semantics
would be to change
the return value from an
array into a hash ref.
That kind of silent change is not the kind
of thing I like to see in production code.

&lt;p&gt;Most Perl programmers are probably not aware of this gotcha.
Even well-informed programmers
can easily write ambiguous code by accident,
and will receive no warning of their mistake.
Perhaps a good application for Marpa::Perl
would be spotting ambiguities like these.

&lt;h2&gt;How to Disambiguate&lt;/h2&gt;

&lt;p&gt;Once spotted, ambiguous curlies are easy to fix.
A standard way to disambiguate
an anonymous hash
is to prefix the
curly braces
with a plus sign:

&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;{42;+{1,2,3,4}}
&lt;/code&gt;&lt;/pre&gt;
TPP, PPI and Marpa::Perl have no trouble
recognizing that the inner curly brackets enclose an anonymous hash in
the above.

&lt;p&gt;A programmer can disambiguate code blocks by
placing a semicolon as the first thing inside the curly brackets.
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;{42;{;1,2,3;4}}
&lt;/code&gt;&lt;/pre&gt;
The inner curlies in the above are recognized
as defining a code block by all three parsers:
TPP, PPI and Marpa::Perl.</description>
  </item>
  </channel>
</rss>
