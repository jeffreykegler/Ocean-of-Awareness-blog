<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Sun, 06 Jan 2013</h3>
<br />
<center><a name="dsl_simpler2"> <h2>Making DSL's even simpler</h2> </a>
</center>
<!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
  <p><a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">
  In a previous post</a>, I showed how to make it easier to write
      domain-specific languages (DSLs).
      This post takes things one step further.
      With Marpa's new Scanless interface, the programmer does not
      need to write a separate lexer.
    </p><p>
      When it comes to dealing with a programming problem,
      no tool is as powerful and flexible as
      a custom language targeted to the problem domain.
      But writing a domain specific language (DSL) is among the
      least used approaches,
      and for what has been a very good reason --
      DSL's have been very difficult to write.
    </p>
    <p>This post takes a tutorial approach.
      It does
      <b>not</b>
      assume any knowledge of the previous tutorials
      on this blog.
      <p>
      The full code for this post is in a Github gist.
      A very similar example is part of Marpa::R2's test suite.
      Our example DSL is a calculator.
      While better than shell arithmetic,
      this calculator is designed to more to act as a good example,
      more than as something you'd want to use.
      But it is not a "toy" example
      -- its 300 lines include good error reporting and a test suite.
    </p>
    <h3>The Grammar</h3>
    <p>
      Let's start right in, by showing the grammar for our calculator.
      It natural divides into two parts.  Here is the first:
    </p><blockquote>
      <pre>
:start ::= script
script ::= expression
script ::= script ';' expression action =&gt; do_arg2
&lt;reduce op&gt; ::= '+' | '-' | '/' | '*'
expression ::=
     number
   | variable action =&gt; do_is_var
   | '(' expression ')' assoc =&gt; group action =&gt; do_arg1
  || '-' expression action =&gt; do_negate
  || expression '^' expression action =&gt; do_caret assoc =&gt; right
  || expression '*' expression action =&gt; do_star
   | expression '/' expression action =&gt; do_slash
  || expression '+' expression action =&gt; do_plus
   | expression '-' expression action =&gt; do_minus
  || expression ',' expression action =&gt; do_array
  || &lt;reduce op&gt; 'reduce' expression action =&gt; do_reduce
  || variable '=' expression action =&gt; do_set_var
</pre></blockquote>
    <p>The format of the grammar is documented
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.040000/pod/Scanless.pod">
        here</a>.
      It consists of BNF rules, whose left hand side (LHS) and right hand side (RHS)
      can be separated by the BNF operator (<tt>::=</tt>).
      The first rule is a pseudo-rule -- its LHS is the psuedo-symbol
      <tt>:start</tt>,
      and it indicates that
      <tt>script</tt>
      is that start symbol.
      The next two rules indicate that
      <tt>script</tt>
      is a series of one
      or more
      <tt>expression</tt>, separated by semicolon.
    </p><p>
      Rules can have action "adverbs"
      to describe the semantics.
      For example, the adverb "<tt>action =&gt; do_args</tt>
      says that the semantics for
      the preceding RHS are implemented by a Perl closure named
      <tt>do_args</tt>.
    </p><p>The rules for
      <tt>&lt;reduce op&gt;</tt>
      introduces two new features: symbols names
      in angle brackets, and alternatives,
      separated by a veritcal bar, ("<tt>|</tt>").
    </p><p>The last statement is a precedence rule.
      It is a series of alternatives, some separated by
      a single vertical bar,
      but others separated by a double vertical ("<tt>||</tt>").
      The double vertical bar indicates that the alternatives after it
      are at a looser ("lower") precedence than the alternatives before it.
      The single vertical bar separates alternatives as the same precedence level.
    </p><p>
      So far, we have been assuming that Marpa will "do the right
      thing" about whitespace in our calculator.
      The next set of rules deal with lexical issues, and specify
      how this works.
    </p>
    <blockquote>
      <pre>
number ~ [\d]+
variable ~ [\w]+
:discard ~ whitespace
whitespace ~ [\s]+
# allow comments
:discard ~ &lt;hash comment&gt;
&lt;hash comment&gt; ~ &lt;terminated hash comment&gt; | &lt;unterminated
   final hash comment&gt;
&lt;terminated hash comment&gt; ~ '#' &lt;hash comment body&gt; &lt;vertical space char&gt;
&lt;unterminated final hash comment&gt; ~ '#' &lt;hash comment body&gt;
&lt;hash comment body&gt; ~ &lt;hash comment char&gt;*
&lt;vertical space char&gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;hash comment char&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
END_OF_GRAMMAR
</pre></blockquote>
    <p>
      This second set of rules take the same form as rules in the earlier set,
      but instead of the BNF operator (<tt>::=</tt>),
      they have a match operator (<tt>~</tt>) separating the LHS and RHS.
      The BNF operator can be seen as telling Marpa, "When it comes to whitespace and comments,
      do what I
      <b>mean</b>".
      The match operator instead tells Marpa to "Do exactly what I
      <b>say</b>
      on a literal,
      character-by-characcter basis."
    </p><p>
      The first two lines indicate how
      <tt>number</tt>'s and
      <tt>variable</tt>
      are formed.
      The square bracketed character classes accept anything acceptable to Perl.
      <tt>:discard</tt>
      is another pseudo-symbol -- any lexeme recognized as a
      <tt>:discard</tt>
      symbol is thrown away.
    </p><p>
      This is how whitespace and comments are dealt with.
      Note that our calculator recognizes "hash comments",
      and takes some care to do the right thing even when the hash comment is at
      the end of a string which does not end in vertical whitespace.
      It is interesting to compare the representation of hash comments here with
      the usual regular expression notation.
      Regular expressions are much more concise, but the BNF-ish form is
      easier to read and,
      with long desciptive angle-bracketed symbol names,
      the reader can be saved from having to
      guess the purpose of some of the more obscure cases.
    </p><p>
      Now that we have defined the grammar, we need to pre-process it:
    </p><pre>
<!--
        html_fmt: An missing end tag was added to close the preceding <pre> element
      --><blockquote>
      my $grammar = Marpa::R2::Scanless::G-&gt;new(
      { action_object  =&gt; 'My_Actions',
      default_action =&gt; 'do_arg0',
      source =&gt; \$rules,
      }
      );
    </blockquote><!--
        html_fmt: Next end tag is cruft
      --></pre><!--
        html_fmt: Next end tag is cruft
      --></blockquote>
    <p>
      The
      <tt>action_object</tt>
      named argument specifies a package to implement
      the semantics -- Marpa will look up the names of the Perl closures in that
      package.
      The
      <tt>default_action</tt>
      named argument specified the action name for RHS's
      which do not explicitly specify one with an
      <tt>action</tt>
      adverb.
    </p>
    <h3>Running a parse</h3>
    <p>
      The next closure shows how to use the grammar to parse a string:
    </p><pre>
<!--
        html_fmt: An missing end tag was added to close the preceding <pre> element
      --><blockquote>
      sub calculate {
      my ($p_string) = @_;
      my $recce = Marpa::R2::Scanless::R-&gt;new( { grammar =&gt; $grammar } );
      my $self = bless { grammar =&gt; $grammar }, 'My_Actions';
      $self-&gt;{recce} = $recce;
      $self-&gt;{symbol_table} = {};
      local $My_Actions::SELF = $self;
      if ( not defined eval { $recce-&gt;read($p_string); 1 } ) {
      # Add last expression found, and rethrow
      my $eval_error = $EVAL_ERROR;
      chomp $eval_error;
      die $self-&gt;show_last_expression(), "\n", $eval_error, "\n";
      } ## end if ( not defined eval { $recce-&gt;read($p_string); 1 })
      my $value_ref = $recce-&gt;value();
      if ( not defined $value_ref ) {
      die $self-&gt;show_last_expression(), "\n",
      "No parse was found, after reading the entire input\n";
      }
      return ${$value_ref}, $self-&gt;{symbol_table};
      } ## end sub calculate
    </blockquote><!--
        html_fmt: Next end tag is cruft
      --></pre><!--
        html_fmt: Next end tag is cruft
      --></blockquote>
    <p>First we create a recognizer (aka a "recce") from our grammar.
      Next we defined a parse object named "<tt>$self</tt>".
      (Object enthusiasts will, I hope, forgive a certain awkwardness at this stage.)
    </p><p>We call the
      <tt>read()</tt>
      method on the recognizer with our string as
      its argument, check for errors,
      and then return the result.
      The calculator allows variables, whose values it keeps in a symbol table.
      These can be important side effect, so the symbol table is also returned
      by
      <tt>calculate()</tt>.
    </p>
    <h3>Dealing with errors</h3>
    <p>This calculator has error reporting that compares favorably with
      production languages.
      (Unfortunately, they often do not set the bar very high.)
      The Scanless interface, in its diagnostics will pinpoint where things
      went wrong from the technical point of view,
      and what it saw as the problem.
      This is often adequate as a diagnostic, but not always --
      the parsing may have ceased to reflect the programmer's intent before
      there was an actual parse error.
    </p><p>To help the programmer sync his intent with what Marpa saw,
      this calculator also prints the last
      <tt>expression</tt>
      successfully
      recognized.
      Here's the code that finds it:
    </p><blockquote>
      <pre>
sub show_last_expression {
    my ($self) = @_;
    my $recce = $self-&gt;{recce};
    my ( $start, $end ) = $recce-&gt;last_completed_range('expression');
    return 'No expression was successfully parsed' if not defined $start;
    my $last_expression = $recce-&gt;range_to_string( $start, $end );
    return "Last expression successfully parsed was: $last_expression";
} ## end sub show_last_expression
</pre></blockquote>
    <h3>The semantics</h3>
    <p>Here are a few of the simpler semantic closures:
    </p><blockquote>
      <pre>
sub do_set_var {
    my ( $self, $var, undef, $value ) = @_;
    return $self-&gt;{symbol_table}-&gt;{$var} = $value;
}

sub do_negate {
    return -$_[2];
}

sub do_arg0 { return $_[1]; }
sub do_arg1 { return $_[2]; }
sub do_arg2 { return $_[3]; }
</pre></blockquote>
    <p>I have found modern programmers
      are usually very comfortable with procedural coding.
      (As an aside, this accounts for the popularity of recursive descent
      and left parsing in general -- it makes parsing look procedural.)
      Things get more complicated than examples above,
      but the full code can be found in the gist.
    </p>
    <h3>Comments</h3>
    <p>
      Comments on this post
      can be sent to the Marpa Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 19:04 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2013/01/dsl_simpler2.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
