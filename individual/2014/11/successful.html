<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Tue, 04 Nov 2014</h3>
<br />
<center><a name="successful"> <h2>What makes a parsing algorithm successful?</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>What makes a parsing algorithm successful?
      I believe that two factors,
      are crucial.
      First, does the algorithm parse a workably-defined language in linear time?
      Second, does it allow the application to intervene in the parse
      with custom code?
      Neither of these is typically the focus of attention when
      comparing parsing algorithms.
      But the successful algorithms do one or the other.
    </p>
    <h3>Does the algorithm parse a workably-defined set of grammars in linear time?</h3>
    <p>By "workably-defined" I do not just mean well-defined
      in the mathematical sense.
      I mean something that goes beyond that.
      For a set of grammars to be workably defined,
      the definition has to be somethign that a programmer and,
      with reasonable effort,
      use in practice.
      The most prominent examples of a workably defined algorithms
      are those in modern regular expression engines.
    </p><p>
      A regular expression, in the pure sense consists of a sequence of symbols,
      usually shown by concatenation:
    </p><blockquote><pre>a b c</pre></blockquote><p>
      or a choice among sequences, usually shown by a vertical bar:
    </p><blockquote><pre>a | b | c</pre></blockquote><p>
      or a repetition of any of the, typically shown with a star:
    </p><blockquote><pre>a*</pre></blockquote><p>
      or any recursive combination of these.
      If this definition is new to you, it can take time to get
      used to it.
      But vast numbers of working programming are very much "used to it",
      and can quickly tell whether something is a regular
      expression or not.
    </p><p>
      Parsers whose languages are
      <b>not</b>
      workably defined are those in the LALR family (yacc, bison, etc.).
      LALR is quite well-defined mathematically,
      but even experts in parsing theory are hard put to look at
      an arbitrary grammar and determine if it is LALR.
    </p><p>
      Other examples of parsers whose languages are not workably
      defined are those written using recursive descent.
      Recursive descent has, in theory, a mathematically well-defined
      basis in the LL languages,
      but in practice this is not relevant, for two reasons.
      First, most recursive descent implementations do not exploit
      LL fully by using LL tables.
      Second, most implemenations extend the LL model with ad hoc
      code, code which sometimes amount to
      switching to  other parsing strategies.
    </p>
    <h3>Does it allow the user to intervene in the parse?</h3>
    <p>It is not easy for users to intervene in the processing
      of a regular expression, though some implementations attempt to
      allow such efforts.
      LALR parsers are notoriously opaque.
      Those who maintain the Perl parser have tried
      to supplement its abilities with
      custom code, with results that will not encourage
      others making the same attempt.
    </p><p>Recursive descent, on the other hand, has no parse engine --
      it is 100% custom code.
      You don't get much friendlier than that.
    </p><h3>Conclusion</h3><p>
      Regular expressions are a success,
      and will remain so,
      because the set of grammars
      they handle is very workably-defined.
      You can, for example, have code that writes regular expressions, and
      be confident they will work as long as they are well-formed.
      And it is not at all hard to determine if the regular expression is well-formed.
      (Whether it actually does what you want is a separate issue.)
      <p>
      Recursive descent does not handle a clearly-defined set of grammars,
      and it also has to be hand-written.
      But it makes up for this by allowing the user to step into the parsing process
      anywhere, and "get his hands dirty".
      For this reason, recursive descent is currently the algorithm of choice
      for major parsing projects.
      <p>
      As I have
      <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html">chronicled
      elsewhere</a>,
      LALR once was seen as
      <b>the</b> solution to the parsing problem,
      for strong theoretical reasons.
      But LALR, while mathematically well-defined,
      did not parse a workably defined set of grammars and
      is very unfriendly to an application that tries to alter,
      or even examine, its workings.
      After decades of trying, at this point the profession
      has almost totally abandoned LALR.
    </p>
    <h3>What about Marpa?</h3>
    <p>I've written an Earley-based parser named Marpa,
      which has both properties:
      its language is workably-defined
      and, while syntax-driven like LALR and regular expressions,
      it also allows the user to stop the parse engine,
      communicate with it about the state of the parse,
      do its own parsing for a while,
      and restart the parse engine at any point it wants.
    </p><p>With the other parsers that have workably-defined
      languages, linearity was a given -- they either worked in linear time
      or (very often) could not handle the language.
      Marpa parses anything
      that can be written in BNF.
      BNF can describe exactly the context-free languages,
      is used to describe languages in standards,
      and is the "gold standard" for workably-defined.
      However, Marpa does
      <b>not</b>
      parse everything that can be written in BNF in linear time.
    </p>
    <p>Marpa linearly-parsed language, however, while smaller,
      is also workably-defined.
      Marpa will parse any unambiguous language in linear time,
      unless it contains unmarked middle recursions.
      An example of a "marked" middle recursion is the language described
      by
    </p><blockquote><pre>S ::= a S a | x</pre></blockquote><p>
      where the "<tt>x</tt>" marks the middle.
      An example of an "unmarked" middle recursion is the language described
      by
    </p><blockquote><pre>S ::= a S a | a</pre></blockquote><p>
      where nothing marks the middle and you don't know until the end where the
      middle of the recursion is.
      If a human can reliably find the middle by eyeball, the middle recursion is marked.
      If a human can't, then the middle recursion might be unmarked.
    </p>
    <p>Marpa also parses a large set of unambiguous grammars linearly,
      and these are also workably-defined.
      Marpa parses an ambiguous grammar in linear time if
    </p><ul>
      <li>As required for the unambiguous grammars, it has no unmarked middle
        recursions.
      </li>
      <li>Marpa's level of ambiguity at any location is bounded by a constant.
        There can be as many rules "in play" as you like, and that's OK,
        your grammar is still linear.
        The key question is at how many points,
        earlier in the parse, can these rules have begun?
        That is, can a rule currently in play
        have begun only at 20 previous locations,
        and could it have started at every location so far?
        If the answer is 20 or some other constant, the level of
        ambiguity is "bounded".
        If not, the level of ambiguity is unbounded.
      </li>
      <li>Finally, all right recursions must be unambiguous.
      </li>
      </ul>
    <p>For the unambigious case, Marpa's workable-defining is not more
      complex than that for regular expressions.
      For the ambiguous one, it's somewhat harder but still quite manageable,
      and in return you get the advantage of dealing with a much larger
      set of grammars.
    </p>
    <h3>More about Marpa</h3><p>
      To learn more about Marpa,
      there's
      <a href=http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p><h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
    </p>
  </body>
</html>
<br />
<p>posted at: 21:10 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2014/11/successful.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
