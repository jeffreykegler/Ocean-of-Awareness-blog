<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness   </title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
  
</div>
  <div id="menu" style="margin:0;padding:10px;width:150px;float:left;">
  <h2>Jeffrey Kegler's blog</h2>
  <p>About Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <h3>Resources</h3>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey Kegler's website</a></p>
  <p><a href="http://www.jeffreykegler.com/marpa">The Marpa website</a></p>
  </div>
  <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Wed, 22 Aug 2012</h3>
<br />
<center><a name="precedence-parsing-made-simpler"> <h2>Precedence parsing made simpler</h2> </a>
</center>
<p>This post describes a new approach to precedence parsing,
one that makes it simpler and
more flexible.
Many programmers find precedence
is an intuitive way to
look at problems.
The traditional rules of arithmetic
are a familiar example:
<tt><pre>
E ::= ( E )
E ::= n
E ::= E * E
E ::= E + E
</pre></tt>
<p>
Here, as in the rest of this post,
the rules are ranked from tightest ("highest") precedence
to loosest ("lowest").
The order in the above display indicates that multiplication
takes precedence over addition, and parentheses take precedence
over everything else.
<h2>The old way and the new way</h2>
<p>The traditional way to deal with precedence
centers on symbols.
The symbols are divided sharply in two:
those that define structure
and those that carry information.
The structural symbols (often called "operators")
are assigned associativities and precedence.
To help guide the parse,
symbols may be further classified as infix, prefix,
circumfix, etc.
<p>
Many rules, even those which intuitively seem part of
the precedence order,
do not fit into this symbol-oriented view of precedence.
Implied operators are ruled out,
as is any rule with two non-terminals in a row.
Rules with an arity of 3 or above, when not also impossible,
are a challenge.
<p>The approach of this post is 100% rule-based.
There is no attempt to identify operators or structural
symbols,
and no attempt to assign properties to them.
This rule-based approach allows
the convenient expression and
efficient implementation of
implied operators,
of rules of arity 3 or higher,
and of rules with any pattern of terminals or non-terminals.
<h2>Simpler</h2>
<p>
Before getting into new features,
it is probably best to show the new approach as applied
to a grammar that
can be parsed with the traditional methods.
My notation is mostly standard or transparent,
but here are details:
<tt><pre>
    ::=       separates the lhs of a rule from its rhs alternatives
    |         separates alteratives at the same precedence level
    ||        separates alteratives at different precedence levels
    :group    indicates 'grouping' associativity
    :left     indicates left associativity (the default)
    :right    indicates right associativity
</pre></tt>
<p>
Here is the grammar:
<tt><pre>
e ::=
     NUM
   | VAR
   | :group '(' e ')'
  || '-' e
  || :right e '^' e
  || e '*' e
   | e '/' e
  || e '+' e
   | e '-' e
  || VAR '=' e
</pre></tt>
<p>
The above fully states the
precedence and associativity for the grammar's rules.
(As a reminder, the precedence follows the order of the rules,
from tightest to loosest.)
This is significantly simpler than what is required
to set up a traditional precedence parser.
On the other hand,
intuitively, it looks like all the required
information is there.
And, in fact, this is the source from which
Marpa::Demo::OP1 creates the grammar for a calculator.
The code is
<a href="https://gist.github.com/3427294">
a Github gist</a>.
<p>In real life, users of a calculator grammar,
like the above,
will be interested
in a numeric result.
However, in this post we are not interested in double-checking
Perl's ability to do basic arithmetic,
so instead we capture
the syntactic structure that the calculator creates.
Here are sample outputs, with square brackets
added to show the parse.
<tt><pre>
Input: "4 * 3 + 42 / 1"
  Parse: [[4*3]+[42/1]]
Input: "4 * 3 / (a = b = 5) + 42 - 1"
  Parse: [[[[4*3]/[([a=[b=5]])]]+42]-1]
Input: "4 * 3 /  5 - - - 3 + 42 - 1"
  Parse: [[[[[4*3]/5]-[-[-3]]]+42]-1]
Input: "- a - b"
  Parse: [[-a]-b]
Input: "1 * 2 + 3 * 4 ^ 2 ^ 2 ^ 2 * 42 + 1"
  Parse: [[[1*2]+[[3*[4^[2^[2^2]]]]*42]]+1]
</pre></tt>
<h2>More flexible</h2>
<p>
In the next grammar, I'll introduce an implied operator.
An implied operator is prominent among the features
that traditional precedence parsers
simply could not handle.
In the grammar that follows,
a missing operator will indicate multiplication,
just as in algebra.
<p>
Traditional precedence parsers also
were stymied by
rules with an arity of 3 or more.
For Marpa::Demo::OP1, these are no problem at all.
I'll introduce two ternary operations,
and a quaternary operation.
(New in the notation below is the "<tt>=> xyz</tt>",
which specifies a non-default semantics,
in this case "<tt>xyz()</tt>".)
<p>
<tt><pre>
e ::=
     NUM
   | VAR
   | :group '(' e ')'
  || '-' e
  || :right e '^' e
  || e '*' e
   | e e                                          => implied_multiply
   | e '/' e
  || e '+' e
   | e '-' e
  || VAR '=' e
  || :right e '?' e ':' e                         => spaced
   | :right e '??' e ':' e ':' e                  => spaced
  || 'payment' 'on' e 'over' e 'years' 'at' e '%' => spaced
</pre></tt>
<p>The code for this second example is also
<a href="https://gist.github.com/3427312">
a Github gist</a>.
And here is the output.
(To make it easy to spot them,
implied multiplications are shown with an "<code class="prettyprint">x</code>"
instead of a "<code class="prettyprint">*</code>".)
<tt><pre>
Input: "4 3 42 + 1"
  Parse: [[[4 x 3] x 42]+1]
Input: "e = m c^2"
  Parse: [e=[m x [c^2]]]
Input: "4 * 3 5 (6 7) 8 9 10"
  Parse: [[[[[[4*3] x 5] x [([6 x 7])]] x 8] x 9] x 10]
Input: "1 ? 42 : 2 ?? 3 : 4 : 5 ? 6 : 7"
  Parse: [1 ? 42 : [2 ?? 3 : 4 : [5 ? 6 : 7]]]
Input: "payment on 1000 + 1000 over months/12 years at 5 + 1 %"
  Parse: [payment on [1000+1000] over [months/12] years at [5+1] %]
</pre></tt
<h2>How rule-based precedence works
<br />
<p>posted at: 09:58 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08">/individual/2012/08</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/precedence-parsing-made-simpler.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 12 Aug 2012</h3>
<br />
<center><a name="the-solved-problem-that-isnt-is"> <h2>The solved problem that isn't, is</h2> </a>
</center>
<p>In the title of
<a href="http://tratt.net/laurie/tech_articles/articles/parsing_the_solved_problem_that_isnt">
an excellent blog post</a>,
Laurence Tratt calls parsing,
"the solved problem that isn't".
I thought this
phrase captured the current situation
in parsing theory and practice very nicely.
In stating that parsing is not a solved problem,
Tratt realized he was taking on a consensus.
But the consensus is fading --
for example, neither side in the interchange
between
<a href="http://arxiv.org/abs/1010.5023">
Might/Darais</a>
and
<a href="http://research.swtch.com/yaccalive">
Russ Cox</a>
expresses complete
contentment with the state of the art.
<p>
What would be a real solution to the parsing problem?
I wish to suggest that
<a href="http://www.jeffreykegler.com/marpa">Marpa</a>
is that solution.
I say that based on a list of features.
Marpa is the first parser to have all of these features,
and I claim they are enough to justify the assertion
that, with Marpa,
parsing is no longer an unsolved problem.
Specifically,
<ol>
<li><p>Marpa parses everything you can write in BNF.
<li><p>Marpa parses in times considered theoretically optimal.
For unambiguous grammars, Marpa is never worse than O(n²).
For ambiguous grammars, Marpa is never worse than O(n³).
Marpa never goes exponential.
<li><p>
Marpa parses all
classes of grammar in practical use today in linear time, O(n).
Marpa is linear for all LR-regular grammars.
The LR-regular grammars include regular expressions,
LL(k) for all k,
and LR(k) for all k.
<li><p>A serious practical issue has been parse-time error detection.
Marpa breaks new ground here.
Marpa is fully aware, at every point in the parse, of
all the rules it is parsing,
how far into them it has proceeded,
and of what tokens it expects next.
This information is available
to the application
conveniently and efficiently.
<li><p>
Marpa parsers do not need to be handwritten.
Marpa is available as a open-source library.
It is written in C,
and the C library can be used
<a href="http://jeffreykegler.github.com/Marpa/libmarpa.html">
directly</a>
or via
<a href="https://metacpan.org/release/Marpa-R2">
a Perl interface</a>.
<li><p>
For general BNF parsing,
the user does not need to craft
a lookahead or backtracking strategy -- Marpa
does not use lookahead and never backtracks.
<li><p>
Marpa's complexity and correctness claims come
with the traditional theoretical apparatus of
proofs based on prior literature.
</ol>
<p>
In his post,
Tratt focuses his discontent on the problem of "language composition" -- the
problem of combining two grammars into one.
Tratt knew that an efficient and practical general BNF parser, like Marpa,
would make language composition easy.
But he was not aware that any such parser existed.
Language composition is a topic to which I hope to return.
<br />
<p>posted at: 20:07 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08">/individual/2012/08</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/the-solved-problem-that-isnt-is.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Tue, 07 Aug 2012</h3>
<br />
<center><a name="marpa-v-perl-regexes-a-rematch"> <h2>Marpa v. Perl regexes: a rematch</h2> </a>
</center>
<p>
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>,
the latest version of
<a href="http://www.jeffreykegler.com/marpa">
Marpa</a>,
has some significant speedups.
Enough so, that it seems appropriate to revisit an
old benchmark.
(For those new to this blog
<a href="http://www.jeffreykegler.com/marpa">
Marpa is a new parser with a decades-long heritage</a>.
Marpa parses anything you can write in BNF and,
if your grammar is in one of the classes currently in practical use,
parses  it in linear time.)
</p><p>
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/marpa-v-perl-regexes-some-numbers.html">
The benchmark I'll revisit</a>
compared Marpa to Perl regexes,
testing the speed with which each could find balanced sets
of parentheses in a string of parentheses,
on a first longest match basis.
It's an interesting test, because it has easy cases
and hard cases,
and because the dividing line between good applications
for Marpa and good applications for regexes is
somewhere between the two sets of cases.
</p><p>
In the "hard cases",
the matches come toward the end.
On these, Perl regexes go quadratic (O(n<sup>2</sup>)),
while Marpa stays linear.
When Perl regexes become unuseable depends on your hardware
and your patience, but there does come such a point.
</p><p>
In the "easy cases",
the matches come toward the start.
Here Perl regexes stay linear.
In my previous testing of easy cases,
Perl regexes beat Marpa
at a steady 40 to 1,
even on some very long and non-trivial strings.
So let's see what has changed ...
</p><h2>The hard cases</h2>
<p>
</p><center>
<table width="529" height="167">
<tbody><tr><th colspan="7">
Finding balanced parentheses: the hard cases<br />
Executions per second by parsing method and length of input<br />
(a higher number means a faster method)<meta http-equiv="content-type" content="text/html; charset=utf-8"></th></tr>

<tr><td>
</td><th align="center">3000
</th><th align="center">2000
</th><th align="center">1000
</th><th align="center">500
</th><th align="center">100
</th><th align="center">10
</th></tr>
<tr><td>Marpa::R2, "thin" interface&nbsp;&nbsp;
</td><td align="right">&nbsp;30.88&nbsp;&nbsp;
</td><td align="right">&nbsp;46.14&nbsp;&nbsp;
</td><td align="right">&nbsp;89.81&nbsp;&nbsp;
</td><td align="right">&nbsp;176.98&nbsp;&nbsp;
</td><td align="right">&nbsp;803.23&nbsp;&nbsp;
</td><td align="right">&nbsp;2665.79&nbsp;&nbsp;
</td></tr>
<tr><td>Marpa::R2, standar<meta http-equiv="content-type" content="text/html; charset=utf-8">d interface&nbsp;
</td><td align="right">&nbsp;7.79&nbsp;&nbsp;
</td><td align="right">&nbsp;11.69&nbsp;&nbsp;
</td><td align="right">&nbsp;22.47&nbsp;&nbsp;
</td><td align="right">&nbsp;41.03&nbsp;&nbsp;
</td><td align="right">&nbsp;140.00&nbsp;&nbsp;
</td><td align="right">&nbsp;305.61&nbsp;&nbsp;
</td></tr>
<tr><td>Marpa::XS&nbsp;
</td><td align="right">&nbsp;3.72&nbsp;&nbsp;
</td><td align="right">&nbsp;5.47&nbsp;&nbsp;
</td><td align="right">&nbsp;10.28&nbsp;&nbsp;
</td><td align="right">&nbsp;19.50&nbsp;&nbsp;
</td><td align="right">&nbsp;58.96&nbsp;&nbsp;
</td><td align="right">&nbsp;111.71&nbsp;&nbsp;
</td></tr>
<tr><td>Perl regex&nbsp;
</td><td align="right">&nbsp;0.13&nbsp;&nbsp;
</td><td align="right">&nbsp;0.34&nbsp;&nbsp;
</td><td align="right">&nbsp;1.84&nbsp;&nbsp;
</td><td align="right">&nbsp;7.58&nbsp;&nbsp;
</td><td align="right">&nbsp;197.25&nbsp;&nbsp;
</td><td align="right">&nbsp;33429.33&nbsp;&nbsp;
</td></tr>
<tr><td>Regexp::Common::Balanced&nbsp;
</td><td align="right">&nbsp;0.05&nbsp;&nbsp;
</td><td align="right">&nbsp;0.12&nbsp;&nbsp;
</td><td align="right">&nbsp;0.53&nbsp;&nbsp;
</td><td align="right">&nbsp;2.43&nbsp;&nbsp;
</td><td align="right">&nbsp;62.09&nbsp;&nbsp;
</td><td align="right">&nbsp;3173.30&nbsp;&nbsp;
</td></tr>
</tbody></table><br /></center>
<p>
<a href="https://metacpan.org/release/Marpa-R2">
Marpa::R2</a>
and
<a href="https://metacpan.org/module/Marpa::R2::Advanced::Thin">
Marpa::R2::Thin</a>
are the new version of Marpa,
respectively its user-friendly and its "no-frills close to the C language" interfaces.
<a href="https://metacpan.org/release/Marpa-XS">
Marpa::XS</a>
is an older version, now stable.
The strings consist of left parentheses, except for a target: "<code class="prettyprint">(()())</code>".
In the "hard cases", the target is near the end of the string.
Further details on the benchmarking methodology are given in
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/marpa-v-perl-regexes-some-numbers.html">
the previous post</a>
and the code for this benchmark is
<a href="https://gist.github.com/3271072">
a Github gist</a>.
</p><p>
For regexes
against which to benchmark,
I first went to Regexp::Common::Balanced on CPAN.
The Regexp::Common::Balanced solution was not all fast,
and went quadratic in the hard cases.
Tom Christiansen provided a better solution for Perl 5.10 and above:
</p><blockquote>
<code class="prettyprint">(\\((?:[^()]++|(?-1))*+\\))</code>
</blockquote>
Tom's regex also goes quadratic in the hard cases,
but it is roughly 3 times faster than the one in Regexp::Common::Balanced.
<p>
Marpa::XS
already had a big lead in the hard cases,
and Marpa::R2 and especially Marpa::R2::Thin
have widened it.
Marpa does extensive precomputation, so it loses for short strings,
as you can see in the "10" column.
But Marpa's precomputation pays off quickly.
At around 125 parentheses,
Marpa::R2 catches up.
Marpa::R2::Thin catches up even faster
-- at roughly 35 parentheses.
When strings reach 3000 characters in length,
Marpa::R2 is about 60 times faster,
and Marpa::R2::Thin is more than 230 times as fast.
</p><h2>The easy cases</h2>
<p>
</p><center><table>
<tbody><tr><th colspan="7">
Finding balanced parentheses: the easy cases<br />
Executions per second by parsing method and length of input<br />
(a higher number means a faster method)</th></tr>
<tr><td>
</td><th align="center">10000
</th><th align="center">3000
</th></tr>
<tr><td>Marpa::R2, "thin" interface&nbsp;
</td><td align="right">&nbsp;12.59&nbsp;
</td><td align="right">&nbsp;41.59&nbsp;
</td></tr>
<tr><td>Marpa::R2, standard interface&nbsp;
</td><td align="right">&nbsp;2.59&nbsp;
</td><td align="right">&nbsp;8.60&nbsp;
</td></tr>
<tr><td>Perl regex&nbsp;
</td><td align="right">&nbsp;20.43&nbsp;
</td><td align="right">&nbsp;78.33&nbsp;
</td></tr>
<tr><td>Regexp::Common::Balanced&nbsp;
</td><td align="right">9.55&nbsp;
</td><td align="right">33.10&nbsp;
</td></tr>
</tbody></table><br /></center>
<p>
The "easy cases" are easy,
relatively speaking,
but they are not trivial.
The string is the same as for the hard cases, except that
the target starts at character position 2, near the beginning.
This is not a trivial matching problem because,
until the very end of the string,
it cannot be known whether the match will start at character
position 0, 1 or 2.
(<a href="https://gist.github.com/3280533">This
code is also in a Github gist</a>.)
</p><p>
For easy cases, I look at the numbers for longer strings.
I've added a column
for strings of 10,000 parentheses.
(I had wanted to carry the "hard cases" test up to 10,000,
but regex performance had deteriorated so badly by 3,000
that getting numbers for 10,000 seemed pointless.)
At 3,000 and even 10,000, regexes are
usually better than Marpa::R2.
(Usually, but not always: for these long strings
Marpa::R2::Thin beats the solution from Regexp::Common::Balanced,
even on these "easy" cases.)
</p><p>
Let's focus on the real race -- the one with Tom's regex.
Tom's regex had beat Marpa::XS by 40 to 1 on this test.
And it still beats Marpa::R2 by almost 10 to 1.
But, for the easy cases,
its lead over Marpa::R2::Thin is now less than 2 to 1.
</p><p>
There will always be cases where regexes beat Marpa.
For this balanced parentheses benchmark,
Marpa's precomputations guarantee that short strings will be one
of those cases.
But much of regex's currently remaining advantage comes,
not from faster pattern recognition,
but from faster string handling.
Perl regexes do their string handling in C.
Marpa::R2 currently does its string handling in Perl,
something which could be changed.
Stay tuned.</p>
<br />
<p>posted at: 17:25 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08">/individual/2012/08</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/08/marpa-v-perl-regexes-a-rematch.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body>
</html>
