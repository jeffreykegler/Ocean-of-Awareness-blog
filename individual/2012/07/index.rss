<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Rudy Rucker and Kurt Goedel</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/07/31#rudy-rucker-and-kurt-gdel</link>
    <description>&lt;p&gt;My major interest is in parsing theory.
But,
according to Google Analytics,
most of my web hits are for a side interest.
A few years ago I discovered
the
&lt;a href=&quot;http://morgenstern.jeffreykegler.com/&quot;&gt;
Lost Morgenstern Document&lt;/a&gt;,
an account of 
Kurt G&amp;ouml;del's citizenship hearing which had
gone missing for so long there was doubt it had
ever existed.
Einstein was at the hearing and
Einstein's fame,
plus the fact it's a good yarn,
make the Lost Morgenstern Document
a matter of fairly wide interest.
&lt;p&gt;
This post is about another G&amp;ouml;del document
which recently surfaced.
This document does not make a good yarn.
In fact, in terms of reading difficulty,
it ranges from the moderately hard to the low-grade cryptographic.
But the
&lt;a href=&quot;http://www.rudyrucker.com/blog/2012/07/31/conversatons-with-kurt-godel/&quot;&gt;
Rucker Notes&lt;/a&gt;
are considerably more important
than the Lost Morgenstern Document.
&lt;p&gt;
Rudy Rucker (a well-known sci-fi writer who deserves
to be better known)
talked with G&amp;ouml;del
several times and took notes,
notes which he has just put online.
This is a significant event.
G&amp;ouml;del had unconventional views on a wide range
of topics.
G&amp;ouml;del avoided controversy,
in part out of common sense,
and in part because he suffered from paranoia.
So he avoided publishing unpopular views except
when he had watertight proofs.
But, when talking to Rucker,
G&amp;ouml;del speculated,
and even argued.

&lt;p&gt;
Rucker was almost,
but not quite unique.
Hao Wang talked with G&amp;ouml;del at much greater length,
and Wang's notes remain the best sources for 
the ideas that G&amp;ouml;del would not commit to writing.
But Wang's conversations were restricted by Wang's interests.
&lt;p&gt;
For example, G&amp;ouml;del
had thought a lot about the nature of time.
He'd published a paper on closed timelike curves,
what in a loose sense could be called time travel.
G&amp;ouml;del's result was pioneering.
When G&amp;ouml;del wrote,
professional physicists did not write about time travel.
G&amp;ouml;del made it possible for the topic,
even if it was still somewhat suspect,
to be taken seriously.
Wang, however, was not interested.
Whenever the physics
or philosophy of time
came up,
Wang changed the subject.
&lt;p&gt;
Based on the existence of closed timelike curves
as solutions to the mathematics of relativity,
is the possibility
of time travel to be taken seriously?
If so,
can you travel back and prevent yourself from being born?
Rucker's few pages
are, and will probably remain,
the most direct evidence we have of
G&amp;ouml;del thoughts on these and
a heterogeny of issues.</description>
  </item>
  <item>
    <title>Prefixing the Ruby Slippers, and the Bigfoot Maneuver</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/07/26#prefixing-the-ruby-slippers-and-the-bigfoot-maneuver</link>
    <description>&lt;a title=&quot;By Frank L Baum (Library of Congress[1]) [Public domain], via Wikimedia Commons&quot; href=&quot;http://commons.wikimedia.org/wiki/File%3AGlinda_cover.jpg&quot;&gt;&lt;img style=&quot;float:left; padding:20px; border-color:White&quot; width=&quot;256&quot; alt=&quot;Glinda cover&quot; src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Glinda_cover.jpg/256px-Glinda_cover.jpg&quot;/&gt;&lt;/a&gt;
&lt;p&gt;In
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2012/07/partial-parsing-and-error-reporting.html&quot;&gt;
my last post&lt;/a&gt;
I talked about partial parsing of Perl
using my new parsing algorithm,
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;
Marpa&lt;/a&gt;.
This post explains how I do it.
For those interested,
the code for the example in my last post can be found in
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;t/curly2.t&lt;/span&gt;
in
&lt;a href=&quot;https://metacpan.org/release/JKEGL/Marpa-R2-2.015_001/&quot;&gt;
Marpa::R2 2.015_001&lt;/a&gt;
(a developer's version).
For convenience, I've also pulled
&lt;a href=&quot;https://gist.github.com/3177276&quot;&gt;

&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;t/curly2.t&lt;/span&gt;
out as a Github gist&lt;/a&gt;.
&lt;/p&gt;
&lt;h2&gt;Introducing the problem&lt;/h2&gt;
&lt;p&gt;
This technique will work for
languages other than Perl.
In fact, this technique could be used to look for several different
target languages
at once,
for example, when searching a database
of emails that might include code segments
in Perl, HTML, C, etc.
&lt;p&gt;
For clarity, I will often refer to the
Perl and C programs
being sought as targets
in text as &quot;code segments&quot;.
In the context of this blog post,
a string is only considered to be a valid
&quot;code segment&quot; if it is also a valid
and complete program.
&lt;/p&gt;
&lt;p&gt;
Perl all by itself presents just about every parsing difficulty there is,
and it will work fine for this discussion.
We will search for the &quot;longest first match&quot;, which is harder
than most alternatives,
but which is also what applications usually want.
For example,
take the following:
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
abcdef ++$a; ++$b; ghijkl
&lt;/div&gt;

&lt;p&gt;
Here the null string is the first valid Perl code segment,
and to be pedantic about it,
it is the longest first match.
But zero length Perl code segments are
not of interest to most applications,
so we'll ignore them from here on out.
Ignoring zero-length Perl code segments,
the string &quot;&lt;code class=&quot;prettyprint&quot;&gt;++$a&lt;/code&gt;&quot; is a first match,
but is still not the longest first match.
&quot;&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt; ++$a; ++$b; &lt;/span&gt;&quot;
is valid Perl code,
and that is the longest first match.
&lt;/p&gt;
&lt;p&gt;
The search can get considerably more complicated.
Consider this code:
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
abcdef sub f { ++$a; ++$b; } ghijkl
&lt;/div&gt;
&lt;p&gt;
Here
&quot;&lt;span style =&quot;white-space:nowrap; font-family:monospace&quot;&gt; sub f { ++$a; ++$b; } &lt;/span&gt;&quot;
is the longest first match, but until the closing curly brace is seen it is not
clear where the longest first match will start, much less end.

&lt;/p&gt;
&lt;h2&gt;The Basic Idea&lt;/h2&gt;
&lt;p&gt;
We note that no longest first match can start after some other match ends.
That means there are two phases in the search -- one where we should allow
targets to start, and one where we should not.
&lt;p&gt;
Let's assume that,
whenever two different code segments share some of the input tokens,
one contains the other -- that is, if strings
&lt;span style=&quot;font-family:monospace&quot;&gt;AB&lt;/span&gt;
and
&lt;span style=&quot;font-family:monospace&quot;&gt;BC&lt;/span&gt;
are valid code segments, then
&lt;span style=&quot;font-family:monospace&quot;&gt;ABC&lt;/span&gt;
is valid code.
(We'll call this the Overlap Closure Property.)
Our strategy will be to parse in two &quot;modes&quot;.
In prefix mode, we track all possible Perl code segments.
Prefix mode ends when the first non-zero length Perl code segment ends.
At that point we know that one of the current candidates must
be the longest first match.
&lt;p&gt;

After prefix mode,
we continue to read tokens,
building all our candidate code segments,
and keeping track of where the most recent one ended.
We do this until either parsing cannot continue,
or we have run out of tokens.
As we'll show more carefully below,
once we can no longer continue parsing,
the Perl code segment that ended most recently will be
the longest first match.
If several end at the same location,
the longest of them will be the longest first match.
&lt;p&gt;
To actually implement this idea,
I'll need to use a series of tricks:
Prefixing, the Ruby Slippers
and the Bigfoot Maneuver.
I'll describe these next,
then I'll put them together as an algorithm.
&lt;p&gt;
The technique I outline in this post
has the advantage that it does not require
rewriting the rules
and symbols of the original, non-partial-parsing, grammar.
New rules and symbols are added &quot;on top of&quot; the original
grammar.
&lt;h2&gt;Prefixing&lt;/h2&gt;
&lt;p&gt;
Prefixing is the simplest of the tricks.
As long as it is possible for a longest first match to start,
my Marpa-based Perl parser is in &quot;prefix mode&quot;.
Once the end of a non-trivial Perl code segment is seen,
&quot;prefix mode&quot; is turned off.
&lt;p&gt;
Here are rules to define the prefix
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
&amp;lt;embedded_perl&amp;gt; ::= &amp;lt;target&amp;gt;&lt;br&gt;

&amp;lt;embedded_perl&amp;gt; ::= &amp;lt;non_perl_prefix&amp;gt; &amp;lt;target&amp;gt;&lt;br&gt;
&amp;lt;non_perl_prefix&amp;gt; ::= &amp;lt;non_perl_token&amp;gt;+
&lt;/div&gt;
&lt;p&gt;
The
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target&amp;gt;&lt;/span&gt;

symbol represents the longest first match --
the &quot;target&quot; that we are looking for.
The plus sign after
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;
indicates that
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_prefix&amp;gt;&lt;/span&gt;
is a non-zero length sequence of
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;
symbols.
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;'s
are just &quot;aliases&quot;
for the application's normal tokens.
Marpa allows tokens to be ambiguous in this way.
&lt;p&gt;
While prefixing is turned on, every token is read as
both its normal self within the original grammar,
and as a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;.
Initially, prefixing is turned on.
It will be turned off as described later.
&lt;h2&gt;The Ruby Slippers&lt;/h2&gt;

The Ruby Slippers technique, as many of my readers will recall,
is wishful thinking, brought to life and made effective within the world
of parsing.
So, let's ask ourselves, what could we wish for that would make finding
the longest first match easy?
&lt;p&gt;
We close our eyes, click our sanguine heels and wish
that the longest first match had markers in the input,
one at its beginning, and one at its end.
As Glinda gently urges us on,
we add that to our grammar:
&lt;p&gt;
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
&amp;lt;target&amp;gt; ::= &amp;lt;target_start_marker&amp;gt; &amp;lt;prog&amp;gt; &amp;lt;target_end_marker&amp;gt;
&lt;/div&gt;
&lt;p&gt;
Here &lt;code class=&quot;prettyprint&quot;&gt;prog&lt;/code&gt; is the top level symbol of the Perl grammar --
the original grammar's &quot;start&quot; symbol.

&lt;p&gt;
Recall that in the Ruby Slippers technique, the grammar assumes that the
world is unrealistically easy, orderly, etc.
And the lexer makes the parser's wishes come true.
For the partial Perl parser,
we write the lexer so that, as long as prefixing is on,
whenever the parser wants a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_start_marker&amp;gt;&lt;/span&gt;,
it gives it one.
&lt;h2&gt;The Bigfoot Maneuver&lt;/h2&gt;
&lt;p&gt;
In parsing, the Bigfoot maneuver uses &quot;bigfoot&quot; tokens.
We call them &quot;bigfoot&quot; tokens because,
while we say they're out there,
we never actually encounter one,
and in fact are fortunate not to do so.
&lt;p&gt;
Marpa, at every point, knows which tokens it is expecting.
We can use this feature, along with &quot;bigfoot&quot; tokens, to signal events to the
lexer.
When we want the parser to signal some event to the lexer, we arrange for it
to expect a &quot;bigfoot&quot; token.
Let's look again at this rule:
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
&amp;lt;target&amp;gt; ::= &amp;lt;target_start_marker&amp;gt; &amp;lt;prog&amp;gt; &amp;lt;target_end_marker&amp;gt;

&lt;/div&gt;
&lt;p&gt;
Here
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_end_marker&amp;gt;&lt;/span&gt;
is a &quot;bigfoot&quot; token.
We won't ever see one, but the fact that the parser is looking
for one will tell us that we have found a Perl
&lt;span style=&quot;font-family:monospace&quot;&gt;prog&lt;/span&gt;.
&lt;p&gt;
We'll use another bigfoot token to deal with
zero-length Perl code segments.
A null string is a legal Perl code segment, but we don't want to count
zero-length code segments as longest first matches.
We could deal with this
by rewriting the Perl grammar slightly,
in order to exclude zero length Perl code segments.
But it is desirable to leave Perl's rules and symbols untouched.
So instead, we introduce another pair of rules
&lt;div style=&quot;text-align:center; font-family:monospace&quot;&gt;
&amp;lt;target&amp;gt; ::= &amp;lt;target_start_marker&amp;gt; &amp;lt;line&amp;gt; &amp;lt;non_trivial_target_end&amp;gt;&lt;br&gt;

&amp;lt;target&amp;gt; ::= &amp;lt;target_start_marker&amp;gt; &amp;lt;decl&amp;gt; &amp;lt;non_trivial_target_end&amp;gt;&lt;br&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;line&amp;gt;&lt;/span&gt;
and
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;decl&amp;gt;&lt;/span&gt;
are two of the original Perl grammar's symbols.

&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;line&amp;gt;&lt;/span&gt;
and
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;decl&amp;gt;&lt;/span&gt;
are never zero length.
Every Perl
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;prog&lt;/span&gt;
is a sequence of zero or more
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;line&amp;gt;&lt;/span&gt;'s
and
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;decl&amp;gt;&lt;/span&gt;'s.
&lt;p&gt;
We define a &quot;non-trivial&quot; Perl code segment as one that contains a
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;line&amp;gt;&lt;/span&gt;

or a
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;decl&amp;gt;&lt;/span&gt;.
To signal the lexer that we have found a non-trivial Perl code segment, we use
&lt;span style=&quot;white-space:nowrap; font-family:monospace&quot;&gt;&amp;lt;non_trivial_target_end&amp;gt;&lt;/span&gt;
as a bigfoot token.
&lt;h2&gt;The Strategy&lt;/h2&gt;
We can now describe the algorithm.
The program to find all the Perl in an arbitrary text is a loop,
which walks through the input finding one longest first match at a time.
Each search for a longest first match is implemented as a separate parse.
When a longest first match is found, a new search begins at the next token
after the match.
&lt;p&gt;
To find a longest first match,
we start out in prefix mode.
In prefix mode,
every Perl token is read in two ways.
First, it is read
the same way
that it was read in the original Perl grammar.
Second, it is read
as a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;.
&lt;p&gt;
In addition, as long as we are in prefix mode,
whenever the parser demands a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_start_marker&amp;gt;&lt;/span&gt;,
we provide it.
This means that while in prefix mode,
we are tracking all possible Perl code segments,
as well as extending the string of

&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_perl_token&amp;gt;&lt;/span&gt;'s to
act as the prefix to any new target candidate that we encounter.
Note that the last prefix token -- the one that we read just before we turn prefix mode off --
will be in all of our target candidates.
This is important because it guarantees that they will all overlap.
&lt;p&gt;
When we see that a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;non_trivial_target_end&amp;gt;&lt;/span&gt;
bigfoot token is expected,
we turn prefix mode off.
We now have at least one candidate for a target and,
since we are not extending the prefix, we will start no new
target candidates.
For the rest of this parse,
we will only lengthen the already started Perl code segments.
&lt;p&gt;
Whether in prefix mode or not,
every time the parser requests a 
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_end_marker&amp;gt;&lt;/span&gt;
bigfoot token,
we record our location.
We never actually provide a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_end_marker&amp;gt;&lt;/span&gt;
as input.
Bigfoot tokens are not Ruby Slippers tokens.
This means that rules that have bigfoot tokens are
&quot;virtual&quot; rules in the sense that they will never actually
be completed.
&lt;p&gt;
Parsing ends when it is &quot;exhausted&quot;
or when we run out of tokens.
An &quot;exhausted&quot; parse is one which cannot continue successfully,
although it may have already succeeded.
(In fact, since the partial parser extends the prefix forever
unless a match is found,
in our case an &quot;exhausted&quot; parse MUST be a successful parse.)

&lt;p&gt;
Once parsing ends,
we call the recognizer's
&lt;span style=&quot;font-family:monospace&quot;&gt;progress()&lt;/span&gt;
method to get a list of all the 
&lt;span style=&quot;font-family:monospace&quot;&gt;prog&lt;/span&gt;'s ending
at the last location where we expected a
&lt;span style=&quot;font-family:monospace&quot;&gt;&amp;lt;target_end_marker&amp;gt;&lt;/span&gt;
bigfoot.
The longest of the completed
&lt;span style=&quot;font-family:monospace&quot;&gt;prog&lt;/span&gt; rules
found in our
&lt;span style=&quot;font-family:monospace&quot;&gt;progress()&lt;/span&gt;
report for that last location is our longest first match.
If there is no last location,
we will also have run out of tokens,
and we are done processing the input.
&lt;h2&gt;Other approaches&lt;/h2&gt;

&lt;p&gt;
The above approach is not the only way to do partial parsing in Marpa.
In fact, you can do it much more simply using only the Prefixing technique,
along with a similar &quot;Postfixing&quot; technique.
The problem is that this method easily goes cubic (O(n&lt;sup&gt;3&lt;/sup&gt;)),
and the worst case
(the one where most or all of the input text is a single Perl code segment)
is also one of practical interest.
The approach outlined above will be linear (O(n)) for all cases of practical interest.
I qualify my assertion by saying &quot;cases of practical interest&quot;
because in fact Perl parsing is, in the general case, undecidable.
&lt;p&gt;
The method outlined in this post could be extended
to deal with languages that do not have
the Overlap Closure Property.
In fact,
it is not completely clear that Perl,
in general,
has the Overlap Closure Property.
The C language does not in general have the Overlap Closure Property,
at least not if the preprocessor is taken into account.
Using the C preprocessor, it would be easy
to construct strings 
&lt;span style=&quot;font-family:monospace&quot;&gt;X&lt;/span&gt;,
&lt;span style=&quot;font-family:monospace&quot;&gt;Y&lt;/span&gt;,
&lt;span style=&quot;font-family:monospace&quot;&gt;Z&lt;/span&gt;
where 
&lt;span style=&quot;font-family:monospace&quot;&gt;X&lt;/span&gt;,
&lt;span style=&quot;font-family:monospace&quot;&gt;Y&lt;/span&gt;,

&lt;span style=&quot;font-family:monospace&quot;&gt;Z&lt;/span&gt;,
&lt;span style=&quot;font-family:monospace&quot;&gt;XY&lt;/span&gt;
and
&lt;span style=&quot;font-family:monospace&quot;&gt;YZ&lt;/span&gt;
are all completely valid C,
but 
&lt;span style=&quot;font-family:monospace&quot;&gt;XYZ&lt;/span&gt;
has a syntax error.
But, for Perl and C code of practical interest,
it is not unreasonable to expect the Overlap Closure Property will hold.</description>
  </item>
  <item>
    <title>Partial parsing and error reporting</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/07/22#partial-parsing-and-error-reporting</link>
    <description>&lt;blockquote&gt;
&quot;One of the secrets to mathematical problem solving is that one needs to place a high value on partial progress,
as being a crucial stepping stone to fully solving the problem.&quot;
-- &lt;a href=&quot;https://plus.google.com/u/0/114134834346472219368/posts/Xdm8eiPLWZp&quot;&gt;
Terence Tao&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;Once an error is found,
a traditional parser is
pretty much lost.
This is true for even
state of the art compilers and interpreters.
One small typo results
in many screens of useless
diagnostics.
If you're an old hand,
you scroll back over these,
knowing that, for the better quality compilers,
the first few lines often have something to
do with the real problem.
With Marpa, we can do better than this.
&lt;/p&gt;
&lt;p&gt;
Robust error reporting
is equivalent to the problem of finding code interspersed
among arbitary text.
For example,
consider this mixture of text and Perl fragments.
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
Note: line:column figures include preceding whitepace
The next line is a perl fragment
{42;{1,2,3;4}}
Code block from 3:5 to 3:13
Code block from 2:33 to 3:14
The next line is a perl fragment
{42;{1,2,3,4}}
Hash from 7:5 to 7:13
Code block from 7:5 to 7:13
Code block from 6:33 to 7:14
The next line is a perl fragment
{42;{;1,2,3;4}}
Code block from 12:5 to 12:14
Code block from 11:33 to 12:15
The next line is a perl fragment
{42;+{1,2,3,4}}
Hash from 16:6 to 16:14
Code block from 15:33 to 16:15
&lt;/pre&gt;&lt;/code&gt;
I have written the prototype of a utility
(&lt;code class=&quot;prettyprint&quot;&gt;ucurly.pl&lt;/code&gt;)
that finds Perl fragments
scattered among other material,
and parses them.
To test the accuracy of the parse,
I have it look for one of Perl's parsing ambiguities ---
anonymous hash constructors that could also be code blocks.
For the example above,
&lt;code class=&quot;prettyprint&quot;&gt;ucurly.pl&lt;/code&gt; finds what there is to be found:

&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
Perl fragment: {42;{1,2,3;4}}
Code block at 3:5 3:13 {1,2,3;4}
Code block at 2:33 3:14 {42;{1,2,3;4}}
Perl fragment: {42;{1,2,3,4}}
Ambiguous Hash at 7:5 7:13 {1,2,3,4}
Ambiguous Code block at 7:5 7:13 {1,2,3,4}
Code block at 6:33 7:14 {42;{1,2,3,4}}
Perl fragment: {42;{;1,2,3;4}}
Code block at 12:5 12:14 {;1,2,3;4}
Code block at 11:33 12:15 {42;{;1,2,3;4}}
Perl fragment: {42;+{1,2,3,4}}
Hash at 16:6 16:14 {1,2,3,4}
Code block at 15:33 16:15 {42;+{1,2,3,4}}
perl tokens = 62; all tokens=267; 23.22%
&lt;/pre&gt;&lt;/code&gt;
&lt;p&gt;
My Marpa-based Perl parser,
as it currently stands,
is a partial Perl parser.
On select problems, it is 100%.
For example,
it understands all of the output from Data::Dumper.
And it scored perfectly in the example in this blog post.
It will parse perhaps 90% of a typical, complex Perl program.
&lt;/p&gt;
&lt;p&gt;
At this point in the Marpa-based Perl parser's evolution,
rather than add Perl syntax,
I decided to use it to investigate partial parsing.
Some readers will have observed that &quot;90% coverage&quot;
is a synonym with &quot;useless&quot; in current parsing practice.
That's because traditional parsing algorithms are close to binary.
Traditional parsers only understand input if it is correct or nearly so.
&lt;/p&gt;
&lt;p&gt;
When partial parsing is possible,
things are more interesting.
For example, I turned
&lt;code class=&quot;prettyprint&quot;&gt;ucurly.pl&lt;/code&gt;,
my ambiguity-finding utility,
loose on
&lt;a href=&quot;http://api.metacpan.org/source/MARKSTOS/CGI.pm-3.59/lib/CGI.pm&quot;&gt;
CGI.pm&lt;/a&gt;,
a complex bit of Perl code by anyone's standard.
My utility failed to parse a lot of correct Perl code
in CGI.pm,
producing a lot of false negatives.
But this did not prevent it from singling out
line 461:
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;

      @result = map {ref $_ ? $_ : $self-&gt;_decode_utf8($_) } @result;
&lt;/pre&gt;&lt;/code&gt;
This line is ambiguous -- the first argument to map
could be either an anonymous hash constructor,
or a code block.
My guess, and I believe, the Perl's parser's guess,
is that it's a code block.
But it'd be nice to have a utility that spots these,
so that all doubt can be removed:
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
      @result = map { ; ref $_ ? $_ : $self-&gt;_decode_utf8($_) } @result;
&lt;/pre&gt;&lt;/code&gt;</description>
  </item>
  <item>
    <title>Two new interfaces to Marpa</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/07/08#two-new-interfaces-to-marpa</link>
    <description>&lt;blockquote&gt;
&quot;You get to create your own world,
and the only thing that limits what you can do
are the capabilities of the machine --
and, more and more often they days,
your own abiliites&quot;
&lt;cite&gt;Linus Torvalds, &lt;i&gt;Just For Fun&lt;/i&gt;, p. 74&lt;/cite&gt;
&lt;/blockquote&gt;
&lt;p&gt;As of
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
Marpa::R2 2.010000&lt;/a&gt;,
Marpa has two new, documented, interfaces.
(For those new to this blog,
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;
Marpa is something new in parsing&lt;/a&gt; --
it parses anything you can write in BNF and,
if your grammar is in one of the classes currently in practical use,
parses  it in linear time.
Marpa's parse engine is written in optimized C,
so that Marpa's speed is competitive with parsers of far less power.
Marpa's stable version is
&lt;a href=&quot;https://metacpan.org/module/Marpa::XS&quot;&gt;
Marpa::XS&lt;/a&gt;.)


&lt;h2&gt;Announcing Marpa's C library: Libmarpa&lt;/h2&gt;
The first new interface is Libmarpa, a C language library.
Previously, Marpa's only documented interfaces required the
programmer to use it
through Perl.  Using Marpa through Perl had major advantages --
it gave the programmer convenient access not just to Perl's capabiliites,
but to all of CPAN as well.

&lt;p&gt;But there were downsides.
&lt;ul&gt;
&lt;li&gt;
There are other languages besides Perl,
and these have their own advantages
and their own fans.
&lt;li&gt;There was a real cost in efficiency.
Perhaps 90% of the time in the typical Marpa application
was spent running Perl, as opposed to 10% in Marpa's C code.
&lt;li&gt;Finally, making the user interface convenient also meant making choices
for the user.
Not all of the capabilities of
Marpa were available through Marpa::XS and Marpa::R2.
&lt;/ul&gt;

With Libmarpa, the programmer has access to the full speed
and flexibility of Marpa's optimized C code.

&lt;h2&gt;Announcing Marpa's &quot;thin&quot; interface: Marpa::R2::Thin&lt;/h2&gt;
&lt;p&gt;Together with Libmarpa, I am announcing a &quot;thin&quot; Perl interface to it.
The &quot;thin&quot; interface is a raw interface to Libmarpa.
It's a compromise between the &quot;thick&quot; Marpa::R2 and Marpa::XS
interfaces,
and having to program in C.
The thin interface will be of interest to
&lt;ul&gt;
&lt;li&gt;Programmers creating interfaces to Marpa.  They no longer
have to layer their code on top of Marpa::XS and Marpa::R2.
All interfaces are now equal.

&lt;li&gt;Perl programmers who want direct access to all of
Libmarpa's capabilities.
&lt;li&gt;Programmers in a situation which where lower overhead
justifies extra effort.
&lt;/ul&gt;

&lt;h2&gt;The documentation&lt;/h2&gt;
If you are new to Marpa, you
do NOT want to head straight to the Libmarpa
and Marpa::R2::Thin documentation.
Instead, I suggest that you look at
&lt;a href=&quot;https://metacpan.org/release/Marpa-R2&quot;&gt;
the Marpa::R2 documentation&lt;/a&gt;,
or
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;
the Marpa web page&lt;/a&gt;.
The
&lt;a href=&quot;https://github.com/downloads/jeffreykegler/Marpa--R2/api-v2.10.0.pdf&quot;&gt;
Libmarpa API document&lt;/a&gt;
is a reference manual,
which assumes that the user is already familiar with Marpa,
either through Marpa::R2, Marpa::XS or

&lt;a href=&quot;https://github.com/downloads/jeffreykegler/Marpa-theory/recce.pdf&quot;&gt;Marpa's
theory paper&lt;/a&gt;.
Reading
&lt;a href=&quot;https://metacpan.org/module/Marpa::R2::Advanced::Thin&quot;&gt;
the Marpa::R2::Thin document&lt;/a&gt;,
in its turn, requires continual reference back
to the Libmarpa API document.</description>
  </item>
  </channel>
</rss>
