<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>The syntax of English is undecidable</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/03/29#the-syntax-of-english-is-undecidable</link>
    <description>&lt;p&gt;
The question of parsing 
English and other natural languages
has come up
in the course of my work on
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;
the Marpa parser&lt;/a&gt;.
&lt;a href=&quot;http://www.jeffreykegler.com/#TOC-Perl-Parsing-is-Undecidable&quot;&gt;
As in the case of Perl&lt;/a&gt;,
I first posed the question of whether any
algorithm running on a Turing machine can parse
the target language.
This post contains
what I hope the reader will find to be
a rigorous demonstration
that the syntax of the English language is undecidable.
&lt;p&gt;
When I say &amp;ldquo;undecidable&amp;rdquo;,
I mean that term in the strict sense.
Undecidability is not vagueness or
uncertainty -- undecidability is the certainty
that a &amp;ldquo;decision&amp;rdquo; of the matter
is not possible.
I will give a specific example of
an English-language sentence which is unsyntactic if and
only if it is syntactic.
&lt;h2&gt;The Demonstration&lt;/h2&gt;

&lt;p&gt;
The sentence hinges on the distinction between sentences
in the passive voice,
and sentences which contain a copular verb
(in this case, &amp;ldquo;to be&amp;rdquo;)
and an adjectival complement.
For example,
&lt;blockquote&gt;(A) &amp;ldquo;The door was opened&amp;rdquo;&lt;/blockquote&gt;
is a passive voice sentence.
In the sentence
&lt;blockquote&gt;(B) &amp;ldquo;The door was open&amp;rdquo;,&lt;/blockquote&gt;
on the other hand, &amp;ldquo;open&amp;rdquo;
is an adjectival complement,
and &amp;ldquo;was&amp;rdquo; is a copular verb.
(While the passive voice of English
is the subject of considerable discussion,
the terminology and analysis
of this post
follows Quirk et al.,

&lt;cite&gt;A comprehensive grammar of the English language&lt;/cite&gt;,
pp. 159-171.
and
&lt;a href=&quot;http://languagelog.ldc.upenn.edu/nll/?cat=54&quot;&gt;Language
Log&lt;/a&gt;, and sticks to terrain which should not
be controversial, even for non-specialists.)
&lt;p&gt;Now consider the following sentence.
&lt;blockquote&gt;(C) &amp;ldquo;The window was closed.&amp;rdquo;&lt;/blockquote&gt;
Is this a sentence with a predicate in the
passive voice,
or is &amp;ldquo;was&amp;rdquo; a copular verb
with an adjectival complement?
In standard dictionaries, you will find 
&amp;ldquo;closed&amp;rdquo; is listed both
as an adjective and as the past participle
of the verb
&amp;ldquo;close&amp;rdquo;, so that either could be
the case.
Further information would be needed to decide the syntax of (C).

&lt;p&gt;
Next I make two observations.
The first observation is that a sentence can be syntactically
correct, but not meaningful.
The traditional example is
&lt;blockquote&gt;(G) &amp;ldquo;Green dreams sleep furiously&amp;rdquo;.&lt;/blockquote&gt;
Another example is
&lt;blockquote&gt;(H) &amp;ldquo;The first even prime greater than two crossed the
street symmetrically&amp;rdquo;.&lt;/blockquote&gt;
Both these sentences allow easy syntactic analysis: each has a subject,
and a predicate.
Nouns, adjectives, adverbs and verbs can be readily
identified and given fixed locations in a formal syntactic structure.
But neither sentence has any meaning, except in a poetic or highly
figurative sense.
&lt;p&gt;
The second observation is that, while we can have correct syntax
without a semantics,
we cannot have meaning without syntax.
That is, sentences like
&lt;blockquote&gt;(I) &amp;ldquo;Airplane from to the and for of or pilot up&amp;rdquo;,&lt;/blockquote&gt;

while they might contain words which could be selected
and rearranged to be meaningful,
do not mean anything.
&lt;p&gt;
We now return to the passive-versus-adjective decision,
where we observed that
&lt;blockquote&gt;(P) &amp;ldquo;The window was closed&amp;rdquo;&lt;/blockquote&gt;
could be an example of either a verb in the passive voice
or of a copular verb with an adjectival complement.
In the sentence
&lt;blockquote&gt;(Q) &amp;ldquo;The window was closed, but the door was open&amp;rdquo;,&lt;/blockquote&gt;
the question is resolved by coordination.
Since in (Q) &amp;ldquo;open&amp;rdquo; can only be an adjectival complement,
the expectation is that &amp;ldquo;closed&amp;rdquo; will also be.
Similarly, in the sentence

&lt;blockquote&gt;(R) &amp;ldquo;The window was closed, but the door was opened&amp;rdquo;,&lt;/blockquote&gt;
coordination with 
&amp;ldquo;opened&amp;rdquo; decides the matter in favor of the passive
voice.
In a sentence where the coordination is closer,
and includes a by-phrase to show agency for both verbs,
&lt;blockquote&gt;(S) &amp;ldquo;The window was closed and the door opened by the same person&amp;rdquo;,&lt;/blockquote&gt;
the presumption that both verbs are in the passive voice becomes
a certainty.
&lt;p&gt;
We are now in a position to consider our undecidable sentence,
&lt;blockquote&gt;(U) &amp;ldquo;The window was closed and the door opened by the burglar after
he discovered that the window was in fact
a beautifully executed trompe d'oeil mural.&amp;rdquo;&lt;/blockquote&gt;

The window is fake.
It therefore could not have been
closed by the burglar, which makes its syntax wrong.
The verb &amp;ldquo;was closed&amp;rdquo;, before semantic feedback
is taken in account, clearly is in the passive voice.
After the semantic feedback to the syntax is considered, however, it is clear
that 
&amp;ldquo;was closed&amp;rdquo; cannot be in the passive voice,
and that therefore (U) is unsyntactic.
&lt;p&gt;But if a sentence does not have correct syntax,
it cannot have a semantics.
Since the only problem with the syntax of (U) was a result
of the semantic feedback, if semantics is not considered (U)
has correct syntax.
So (U) is incorrect syntactically if and only if it has
correct syntax.
&lt;p&gt;
We cannot decide (U) to have incorrect syntax, because in that
case it becomes meaningless and the syntax becomes unobjectionable.
But neither can we decide (U) to have correct syntax,
because that makes (U) meaningful.
When (U) is meaningful,
it has incorrect syntax,
because the passive voice cannot be correct
given the meaning.
&lt;p&gt;Our only choice is to say that the correctness of
the syntax of (U) cannot be decided.
It is not true
that (U) has correct syntax,
but neither is it true
that (U) has incorrect syntax.
This concludes the demonstration.
&lt;h2&gt;A Thought Problem&lt;/h2&gt;
&lt;p&gt;
To a reader unconvinced
by the preceding demonstration,
I would urge that,
as a thought problem,
she consider
a computer program attempting to
parse English.
Such a program would have to know
at least some semantics, and
would have to feed this knowledge back
to the parsing process.
But the preceding demonstration shows that
such a feedback loop, if completely effective,
will encounter sentences like (U),
where it cannot decide whether the syntax of 
the sentence is correct or incorrect.
I believe that,
by reflecting on this thought problem,
the candid reader will be able to convince herself
that a human being
parsing English sentences
like (U)
will have the same problems,
and for similar reasons.
&lt;h2&gt;About Syntax and Semantics&lt;/h2&gt;
&lt;p&gt;

It needs to be emphasized that the diagonalization
in this post's demonstration
is not about semantic truth and has nothing to do
with semantic paradox.
This post is
about the feedback from semantics into syntax,
and the relationship between them.
By way of contrast,
consider these sentences:
&lt;blockquote&gt;
(X) &amp;ldquo;Two plus two is five.&amp;rdquo;&lt;br&gt;
(Y) &amp;ldquo;This sentence has incorrect syntax.&amp;rdquo;&lt;br&gt;
(Z) &amp;ldquo;This sentence is false.&amp;rdquo;
&lt;/blockquote&gt;
(X) is false; (Y) attempts a contradiction but fails;
and (Z) achieves a semantic contradiction.
But in none of them is the semantics an issue for the
syntax,
and all three are correct syntactically.
In each case,
even when there are semantic issues,
the feedback that the semantics provide the
syntax is unproblematic.</description>
  </item>
  <item>
    <title>A Marpa mailing list</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/03/12#a-marpa-mailing-list</link>
    <description>&lt;p&gt;Ruslan Zakirov has started &lt;a href=&quot;https://groups.google.com/forum/?hl=en&amp;fromgroups#%21forum/marpa-parser&quot;&gt;a Google mailing list&lt;/a&gt; for discussions about Marpa: marpa-parser@googlegroups.com -- I am grateful to Ruslan for doing this and plan to follow the mailing list.

&lt;p&gt;On another topic, I will be removing the &quot;bare name&quot; version of Marpa from CPAN shortly.  The &quot;bare name&quot; Marpa is a legacy, deprecated version and is simply causing too much confusion, with search engines and elsewhere.  The official, stable version of Marpa remains &lt;a href=&quot;https://metacpan.org/module/Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;.</description>
  </item>
  <item>
    <title>Making the parsing game safe</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/03/10#making-the-parsing-game-safe</link>
    <description>&lt;p&gt;
In previous posts,
I've talked about
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;Marpa&lt;/a&gt;
as an alternative to other parsers.
In this one,
I want to talk
about Marpa as an alternative
for problems where
&lt;a href=&quot;#RE&quot;&gt;parsing has been avoided&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Because parsing HAS been avoided in the past.
And for good reason.
If you were drawn by the allure of domain-specific languages,
or yielded to the siren call of language-oriented programming,
you plunged headlong toward two pitfalls:
&lt;ul&gt;
&lt;li&gt;Your parser might not parse your grammar.
Which you might discover at any point in incremental development.
Or when a vital maintenance change came along.
&lt;/li&gt;
&lt;li&gt;
Your input might not parse,
and your parse engine might leave you
with no easy way to find out
what the problem is.
Maybe your input was wrong,
maybe your grammar was wrong,
or maybe you've simply
hit the limits of that parse engine.
When it came to debugging, taking a language-based
approach was a bit like deciding to write your problem up in
&lt;a href=&quot;http://en.wikipedia.org/wiki/P%E2%80%B2%E2%80%B2&quot;&gt;P''&lt;/a&gt;.

&lt;/li&gt;
&lt;/ul&gt;</description>
  </item>
  <item>
    <title>User experiences with Marpa: some observations</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/03/01#user-experiences-with-marpa-some-observations</link>
    <description>&lt;p&gt;
When it comes to
user experiences with Marpa,
I confess to being a highly biased source.
I hope the following observations
will be useful nonetheless.
(Marpa, for those new to this blog,
is a new, powerful and fast parser and parsing algorithm.
To learn more,
check out &lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;its web page&lt;/a&gt;.)
&lt;/p&gt;
&lt;h2&gt;Marpa does the job&lt;/h2&gt;
&lt;p&gt;
If you've read user's accounts of work with BNF grammars over
the years
(I have studied many),
you know they follow a familiar pattern.
The user has some BNF.
He then tries tool X (for X substitute
yacc, bison, PEG, recursive descent, etc.)
and finds that it almost works.
Almost, but not quite.
The rest of the account describes the user
beating up his grammar in an effort to make
it fit the tool.
Perhaps 50% of the time, he reports that his effort
was wasted.
&lt;/p&gt;
&lt;p&gt;
The accounts from Marpa users are different,
because the problem the users of other tools spend
most of their time describing,
and spent most of their time solving,
does not exist with Marpa.
Once they have their grammar worked out,
Marpa parses it.
As a practical
matter, this difference is a big deal.
A methodology that, half the time,
takes you to a dead end,
is one that practitioners will avoid.
&lt;/p&gt;
&lt;p&gt;
The reason that regular expressions became so dominant,
I am convinced,
is that they did the job.
If you can write your problem as a regular expression
(here I speak of regular expressions, not regexes)
you are guaranteed two things.
First that your regular expression engine *WILL* handle it.
Second, that it will do so in acceptable time.
Regular expressions did the job.
With Marpa, BNF does the job.
&lt;/p&gt;
&lt;h2&gt;BNF as a lost art&lt;/h2&gt;

&lt;p&gt;
An obstacle to learning Marpa seems to be
that writing BNF is something of a lost art.
BNF is not difficult.
By my accounting,
BNF is actually simpler than regular expressions.
BNF involves one idea: concatenation.
Regular expressions involve all of concatenation,
sequence and alternation.
Even if you don't agree with my way of calculating
difficulty,
I think you'll agree that
BNF is vastly simpler than Perl regexes.
&lt;p&gt;
&lt;/p&gt;
When I learned programming (around 1970),
BNF was much better known than regular expressions.
BNF had been established for years
as the way of specifying languages.
Regular expressions,
on the other hand,
did not come in prominence
before Thompson's
&lt;a href=&quot;http://en.wikipedia.org/wiki/Ed_%28text_editor%29&quot;&gt;ed editor&lt;/a&gt;.
The first PDP11 assembler version of that came out in 1971,
the year I was taking the introduction to Computer Science
with Alan Perlis.
Prof. Perlis
spent a lot of time on BNF
and
&lt;a href=&quot;http://en.wikipedia.org/wiki/Markov_algorithm&quot;&gt;
Markov machines&lt;/a&gt;.
I cannot recall that he mentioned regular expressions.
Since then, at least
in the US, BNF and Markov machines seem to have been consigned to
nearly the same degree of oblivion.</description>
  </item>
  </channel>
</rss>
