<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Making the parsing game safe</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/03/10#making-the-parsing-game-safe</link>
    <description>&lt;p&gt;
In previous posts,
I've talked about
&lt;a href=&quot;http://www.jeffreykegler.com/marpa&quot;&gt;Marpa&lt;/a&gt;
as an alternative to other parsers.
In this one,
I want to talk
about Marpa as an alternative
for problems where
&lt;a href=&quot;#RE&quot;&gt;parsing has been avoided&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Because parsing HAS been avoided in the past.
And for good reason.
If you were drawn by the allure of domain-specific languages,
or yielded to the siren call of language-oriented programming,
you plunged headlong toward two pitfalls:
&lt;ul&gt;
&lt;li&gt;Your parser might not parse your grammar.
Which you might discover at any point in incremental development.
Or when a vital maintenance change came along.
&lt;/li&gt;
&lt;li&gt;
Your input might not parse,
and your parse engine might leave you
with no easy way to find out
what the problem is.
Maybe your input was wrong,
maybe your grammar was wrong,
or maybe you've simply
hit the limits of that parse engine.
When it came to debugging, taking a language-based
approach was a bit like deciding to write your problem up in
&lt;a href=&quot;http://en.wikipedia.org/wiki/P%E2%80%B2%E2%80%B2&quot;&gt;P''&lt;/a&gt;.

&lt;/li&gt;
&lt;/ul&gt;</description>
  </item>
  </channel>
</rss>
