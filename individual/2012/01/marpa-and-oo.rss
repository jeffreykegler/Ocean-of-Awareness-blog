<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Marpa and OO</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2012/01/21#marpa-and-oo</link>
    <description>&lt;p&gt;
Both
&lt;a href=&quot;http://www.perlmonks.org/?node_id=900763&quot;&gt;publicly&lt;/a&gt;
and privately I hear from folks who
tell me that
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&quot;&gt;Marpa&lt;/a&gt;
is an OO
superclass waiting to happen.
I can see their point.
If there ever was a case for code reuse,
the Marpa algorithm is one.
On the other hand,
any non-trivial use of
Marpa requires additional semantics,
so that the Marpa classes
walk, swim and quack
very much like abstract type classes.
&lt;/p&gt;
&lt;p&gt;
Furthermore, the additional semantics
that Marpa needs comes in pieces -- semantic actions.
And even though these pieces
often share little code
with each other,
they interact heavily
as part of a specific
structure.
This means that their semantics are tightly coupled,
both to each other and to Marpa.
In short, Marpa's semantic actions look a lot
like the methods of a subclass.
&lt;/p&gt;
&lt;p&gt;
Not that there aren't issues.
In particular,
if Marpa were a superclass,
its subclasses wouldn't know which methods they
needed to implement
until after the grammar was fully specified --
in other words until deep into runtime.
But if you're into OO, there are no problems,
just interesting challenges.
&lt;/p&gt;
&lt;p&gt;
A top priority with me is to empower those
who have ideas for alternative Marpa interfaces,
whether object-oriented or not.
Currently,

&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;
is divided into two layers.
The core algorithm is in a C library (libmarpa).
The interface code is the upper layer.
Written in Perl,
this upper layer calls libmarpa.
But in
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;,
libmarpa's interface was not documented,
and frankly the
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;
version of libmarpa was
so hackish that it needed to
be rewritten
before it could be effectively
and clearly documented.
In the development version of Marpa,
&lt;a href=&quot;http://search.cpan.org/dist/Marpa-R2/&quot;&gt;Marpa::R2&lt;/a&gt;,
this rewrite
has been completed,
and the libmarpa documentation is now underway.
&lt;/p&gt;
&lt;p&gt;
With a documented libmarpa interface,
authors of new Marpa interfaces can totally bypass
the current
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;
interface.
And in terms of speed, they'll start the race
with an advantage --
&lt;a href=&quot;http://search.cpan.org/dist/Marpa-R2/&quot;&gt;Marpa::R2&lt;/a&gt;

is 20% faster
than
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
But why wait for
&lt;a href=&quot;http://search.cpan.org/dist/Marpa-R2/&quot;&gt;Marpa::R2&lt;/a&gt;
to try out your ideas?
At the cost of a modest overhead,
a new OO interface can be layered on top of
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;.
The new interface can simply define a default action
to
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;,
one that implements
your wrapper's semantics.
Supplying an OO context to Marpa's semantic actions
is easy.
All
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;'s
actions receive as their first
argument a &quot;per-parse variable&quot;.
The per-parse variable can be initialized
to anything the upper layer wants.
A wrapper object could pass itself to Marpa's
semantic actions as their per-parse variable.
&lt;a href=&quot;https://metacpan.org/release/Marpa-XS&gt;Marpa::XS&quot;&gt;Marpa::XS&lt;/a&gt;'s
semantic actions can then easily use
the wrapper object to call one of the wrapper's
methods,
passing it the semantic action's other arguments.

&lt;/p&gt;</description>
  </item>
  </channel>
</rss>
