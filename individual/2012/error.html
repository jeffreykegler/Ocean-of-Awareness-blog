<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 29 Oct 2012</h3>
<br />
<center><a name="error"> <h2>A Marpa DSL tutorial: Error reporting made easy</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      Using
      Marpa's facilities for error reporting,
      a quickly written domain-specific language can,
      as of its first draft,
      have error reporting whose helpfulness and precision exceeds
      that of carefully hand-crafted production compilers.
      This post will give an example.
      Two techniques will be used.
    </p><p>
      First and most basic,
      in the technical sense, Marpa's knowledge of when the parse
      can no longer proceed is 100% accurate and immediate.
      This is not the case with yacc-derived parsers,
      and is not the case with most recursive descent parsers.
    </p><p>
      The second technique involves giving an exact account of what
      Marpa believes it has seen so far.
      The Marpa parser can report the answer to questions like
    </p><blockquote><p>
        "What was the last statement you successfully parsed?"
      </p><p>
        "What was the last expression you successfully parsed?"
      </p><p>
        "Where did the last successfully parsed block end?"
      </p>
    </blockquote>
    <p>
      Imagine that your C compiler or 4GL interpreter reported this
      information every time you made an error.
      Your work would be a lot faster.
      For users of your next DSL, you don't have to imagine -- this
      kind of error-reporting will be a standard feature
      from its earliest versions.
    </p><h3>The language</h3>
    <p>
      To focus on the logic of the error reporting,
      I picked a language that was error-prone,
      but otherwise as simple as possible.
      For this purpose,
      prefix arithmetic is like a gift from the dakinis.
      Simple in concept,
      it is almost impossible to get right when it is more than a few
      characters long,
      and confusing to read.
      <q>say + 1 2</q>
      and
      <q>+++ 1 2 3 + + 1 2 4</q>
      are two correct strings in this
      language.
      Their results are, in order, 3 and 13.
    </p><p>
      I restricted the calculator to addition, because even with one
      operator, prefix notation is confusing enough to serve our purposes.
      I have included an optional
      <tt>say</tt>
      keyword, in order
      to illustrate rejection of a token by type.
      In pure prefix arithmetic, either all tokens are valid or none are.
      The
      <tt>say</tt>
      keyword is only valid as the first token.
    </p><h3>The grammar</h3><p>
      The full code for this post is in
      <a href="https://gist.github.com/3974816">
        a Github gist</a>.
      It was run using
      <a href="https://metacpan.org/release/JKEGL/Marpa-R2-2.023_007">
        a release candidate for the full release of Marpa::R2</a>
      Here is the grammar.
    </p><blockquote><pre><tt>
my $prefix_grammar = Marpa::R2::Grammar-&gt;new(
    {   start          =&gt; 'Script',
        actions        =&gt; 'My_Actions',
        default_action =&gt; 'do_arg0',
        rules          =&gt; [ &lt;&lt;'END_OF_RULES' ]
Script ::=
     Expression
   | kw_say Expression action =&gt; do_arg1
Expression ::=
     Number
   | op_add Expression Expression action =&gt; do_add
END_OF_RULES
    }
);
</tt></pre></blockquote>
    <p>The rules are specified in another DSL,
      of the kind I've used
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">
        in previous posts</a>.
      This one is incorporated in Marpa::R2 itself,
      and is
      <a href="https://metacpan.org/module/JKEGL/Marpa-R2-2.023_007/pod/BNF.pod">
        documented here</a>.
      Here are its features relevant to this example:
    </p><dl>
      <dt><strong><tt>::=</tt></strong></dt>
      <dd>A BNF rule in LHS
        <tt>::=</tt>
        RHS form</dd>
      <dt><strong><tt>|</tt></strong></dt>
      <dd>Separates alternative RHS's at the
        <strong>same</strong>
        precedence level</dd>
      <dt><strong><tt>=&gt;</tt></strong></dt>
      <dd><tt>keyword =&gt; value</tt>, where
        <tt>keyword</tt>
        the name of an adverb.</dd>
    </dl>
    <p>The
      <tt>action =&gt; do_add</tt>
      adverb indicates that the semantics for the alternative
      are in the Perl closure named
      <tt>do_add</tt>.
    </p><p>The rest of the grammar's definition will be familiar to Marpa users.
      <tt>Script</tt>
      is the start symbol,
      the Perl closures implementing semantics are to be found in the
      <tt>My_Actions</tt>
      package,
      and where no semantics are explicitly specified,
      the Perl closure
      <tt>do_arg0</tt>
      is the default.
    </p><h3>The semantics</h3>
    <p>The semantics for this example are easy.
    </p><blockquote><pre><tt>
sub My_Actions::do_add  { shift; return $_[1] + $_[2] }
sub My_Actions::do_arg0 { shift; return shift; }
sub My_Actions::do_arg1 { shift; return $_[1]; }
</tt></pre></blockquote>
    <p>
      The first argument to a Marpa semantic closure is a "per-parse variable",
      which is not used in this application.
      The others are the values of the child nodes,
      as determined recursively and in lexical order.
    </p><h3>The lexer's table</h3>
    <p>
      In this post,
      I am skipping around in the code --
      <a href="https://gist.github.com/3974816">
        the full code is in the gist</a>.
      But lexical analysis is of particular interest to new
      Marpa users.
      The lexer I use for this example is overkill --
      table-driven and using Perl's progressive matching
      capabilities, it is capable of serving a much more
      complex language.
      (I talked about lexing more
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">
        in a previous example</a>.)
      Here is the lexer's table:
    </p>
<blockquote> <pre>
my @terminals = (
    [ Number =&gt; qr/\d+/xms,   'Number' ],
    [ op_add =&gt; qr/[+]/xms,   'Addition operator' ],
    [ kw_say =&gt; qr/say\b/xms, qq{"say" keyword} ],
);
/pre> </blockquote>
    <h3>Types of parsing error</h3>
    <p>Before plunging in the code that captures parsing and issues,
    it may be best to describe the forms they take,
    and show the messages that the code that follows will produce.
    <h4>No valid token</h4>
    <p>The lexer may reach a point in the input
    where it does not find one of the allowed tokens.
    An example in this language would be an input with an
        an exclamation point.
	Errors of this kind have always been easy to diagnose,
	pinpoint and, usually, to fix.
<h4>The parser rejects a token</h4>
	In some cases the lexer finds a token,
	but it is not one the parser will accept at that point,
	so the parser rejects the token.
	An example with this language would be the input
	"<tt>+ 1 say 2</tt>", which causes the following diagnostic:
<blockquote><pre>
Last expression successfully parsed was:  1
A problem occurred here:  say 2
Parser rejected token ""say" keyword"
</pre></blockquote>
<p>In this situation spotting the bad keyword should be all
the information the user needs, but
note that Marpa did successfully determine that
"<tt>1</tt>" is a valid expression of the language, but
"<tt>+ 1</tt>" is not.
<h4>The parser becomes exhausted</h4>
<p>
In other cases, the parser may "dead end" -- reach a point
where no more input can be accepted.
One example is with the input
"<tt>+ 1 2 3 + + 1 2 4</tt>".
This causes the following diagnostic:
<blockquote><pre>
Last expression successfully parsed was: + 1 2
The parse became exhausted here: " 3 + + 1 2 4"
</pre></blockquote>
<p>The parser has completed a prefix expression,
and unlike infix and postfix expressions, once they have
been allowed to end
there is no way to add "new stuff" at the end.
The parse is "exhausted".
<p>A second example of an exhausted parse
occurs with the the input
"<tt>1 + 2 +3  4 + 5 + 6 + 7</tt>".
Here is the diagnostic:
<blockquote><pre>
Last expression successfully parsed was: 1
The parse became exhausted here: " + 2 +3  4 + 5 + 6 + 7"
</pre></blockquote>
<h4>The input is fully read, but there is no parse</h4>
Finally, it may happen that lexer and parser read and accept
the entire input, but do not find a valid parse in it.
For example, if the input is 
"<tt>+++</tt>", the diagnostic will be:
<blockquote><pre>
No expression was successfully parsed
No parse was found, after reading the entire input
</pre></blockquote>
<p>The input was a good start for a prefix expression,
but no numbers were ever found,
and our DSL reports that it never recognized any
prefix expressions.
<p>A more complicated case is this input:
"<tt>++1 2++</tt>".
Here is what our DSL tells us:
<blockquote><pre>
Last expression successfully parsed was: +1 2
No parse was found, after reading the entire input
</pre></blockquote>
<p>
Our DSL did find a good expression, and tells us where it was.
If there is more than one good expression, our DSL tells us
the most recent.
With input "<tt>++1 2++3 4++</tt>",
the diagnostic becomes
<blockquote><pre>
Last expression successfully parsed was: +3 4
No parse was found, after reading the entire input
</pre></blockquote>
<p>In fact, if we thought it would be helpful
our DSL could show all the expressions found,
or the last <i>N</i> expressions for some
<i>N</i>.
This is a simple language with nothing but expressions
involving a single operator.
More interesting languages will have statements and blocks,
and layers of subexpressions.
The logic below can be easily modified to show us
as much about these as we think will be helpful.
    <h3>Parsing the DSL</h3>
    <blockquote><pre>
sub my_parser {
    my ( $grammar, $string ) = @_;
    my @positions = (0);
    my $recce = Marpa::R2::Recognizer-&gt;new( { grammar =&gt; $grammar } );

    my $self = bless {
        grammar   =&gt; $grammar,
        input     =&gt; \$string,
        recce     =&gt; $recce,
        positions =&gt; \@positions
        },
        'My_Error';

    my $length = length $string;
    pos $string = $positions[-1];

    <big><b>... "Reading the tokens" goes here ...</b></big>

    my $value_ref = $recce-&gt;value;
    if ( not defined $value_ref ) {
        die $self-&gt;show_last_expression(), "\n",
            "No parse was found, after reading the entire input\n";
    }
    return ${$value_ref};
} ## end sub my_parser
</pre></blockquote>
    <h3>Reading the tokens</h3>
    <blockquote><pre>
TOKEN: while ( pos $string &lt; $length ) {
    next TOKEN if $string =~ m/\G\s+/gcxms;    # skip whitespace
    if ( $recce-&gt;exhausted() ) {
	die $self-&gt;show_last_expression(), "\n",
	    q{The parse became exhausted here: "},
	    $self-&gt;show_position( $positions[-1] ), qq{"\n},
	    ;
    } ## end if ( $recce-&gt;exhausted() )

    <big><b>...  "Looping through the lexing table" goes here ...</b></big>

    die 'A problem occurred here: ',
	$self-&gt;show_position( $positions[-1] ), "\n",
	q{No valid token was found};
} ## end TOKEN: while ( pos $string &lt; $length )
<!--
          html_fmt: An missing end tag was added to close the preceding <pre> element
        --><pre><!--
          html_fmt: An missing end tag was added to close the preceding <pre> element
        --></blockquote>
    <h3>Looping through the lexing table</h3>
    <blockquote><pre>
TOKEN_TYPE: for my $t (@terminals) {
    my ( $token_name, $regex, $long_name ) = @{$t};
    next TOKEN_TYPE if not $string =~ m/\G($regex)/gcxms;
    if ( defined $recce-&gt;read( $token_name, $1 ) ) {
	my $latest_earley_set_ID = $recce-&gt;latest_earley_set();
	$positions[$latest_earley_set_ID] = pos $string;
	next TOKEN;
    }
    die $self-&gt;show_last_expression(), "\n",
	'A problem occurred here: ',
	$self-&gt;show_position( $positions[-1] ), "\n",
	qq{Parser rejected token "$long_name"\n};
} ## end TOKEN_TYPE: for my $t (@terminals)
</pre></blockquote>
    <h3>Showing the last expression</h3>
    <blockquote><pre><tt>
sub My_Error::show_last_expression {
    my ($self) = @_;
    my $last_expression =
        $self-&gt;input_slice( $self-&gt;last_completed_range('Expression') );
    return
        defined $last_expression
        ? "Last expression successfully parsed was: $last_expression"
        : 'No expression was successfully parsed';
} ## end sub My_Error::show_last_expression
</tt></pre></blockquote>
    <h3>Slicing the input</h3>
    <blockquote><pre><tt>
sub My_Error::input_slice {
    my ( $self, $start, $end ) = @_;
    my $positions = $self-&gt;{positions};
    return if not defined $start;
    my $start_position = $positions-&gt;[$start];
    my $length         = $positions-&gt;[$end] - $start_position;
    return substr ${ $self-&gt;{input} }, $start_position, $length;
} ## end sub My_Error::input_slice
</tt></pre></blockquote>
    <h3>Finding the last successful parse of a symbol</h3>
    <blockquote><pre>
sub My_Error::last_completed_range {
    my ( $self, $symbol_name ) = @_;
    my $grammar      = $self-&gt;{grammar};
    my $recce        = $self-&gt;{recce};
    my @sought_rules = ();
    for my $rule_id ( $grammar-&gt;rule_ids() ) {
        my ($lhs) = $grammar-&gt;bnf_rule($rule_id);
        push @sought_rules, $rule_id if $lhs eq $symbol_name;
    }
    die "Looking for completion of non-existent rule lhs: $symbol_name"
        if not scalar @sought_rules;
    my $latest_earley_set = $recce-&gt;latest_earley_set();
    my $earley_set        = $latest_earley_set;

    <big><b>... "Traversing the Earley sets" goes here ...</b></big>

    return if $earley_set &lt; 0;
    return ( $first_origin, $earley_set );
} ## end sub My_Error::last_completed_range
</pre></blockquote>
    <h3>Traversing the Earley sets</h3>
    <blockquote><pre>
my $first_origin = $latest_earley_set + 1;
EARLEY_SET: while ( $earley_set &gt;= 0 ) {
    my $report_items = $recce-&gt;progress($earley_set);
    ITEM: for my $report_item ( @{$report_items} ) {
	my ( $rule_id, $dot_position, $origin ) = @{$report_item};
	next ITEM if $dot_position != -1;
	next ITEM if not scalar grep { $_ == $rule_id } @sought_rules;
	next ITEM if $origin &gt;= $first_origin;
	$first_origin = $origin;
    } ## end ITEM: for my $report_item ( @{$report_items} )
    last EARLEY_SET if $first_origin &lt;= $latest_earley_set;
    $earley_set--;
} ## end EARLEY_SET: while ( $earley_set &gt;= 0 )
</pre></blockquote>
    <h3>Comments
    </h3>
<br />
<p>posted at: 09:46 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/error.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
