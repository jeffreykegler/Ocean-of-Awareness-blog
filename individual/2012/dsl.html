<html>
<head>
<link rel="alternate" type="type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness   </title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
  
</div>
  <div id="menu" style="margin:0;padding:2em;width:150px;float:left;">
  <h2>Jeffrey Kegler's blog</h2>
  <p>About Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <h3>Resources</h3>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey Kegler's website</p>
  <p><a href="http://www.jeffreykegler.com/marpa">The Marpa website</p>
  </div>
  <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:10px;">
<h3>Sun, 26 Aug 2012</h3>
<br />
<center><a name="dsl"> <h2>Domain-Specific Languages made simple</h2> </a>
</center>
<h2>Writing your own language</h2>
<p>Creating your own languages has been A Big Deal (tm).
What if you could create a simple language in hours or minutes?
There's been a serious obstacle to this up to now.
No practical parser "just parsed" BNF.
With Marpa, that restriction is lifted.
<p>
In this post, I will describe
a small, sample Marpa domain-specific language (DSL).
In designing it I am inspired by
<a href="http://blog.plover.com/oops/blosxom-sux.html">
Mark Dominus's description</a>
of the
<a href="http://en.wikipedia.org/wiki/Worse_is_better">
"Worse is Better" philosophy</a>,
and it implementation in the form of
<a href="http://en.wikipedia.org/wiki/Blosxom">
Blosxom</a>.
This DSL is feature-poor,
but short, simple and extensible.
<h2>A calculator</h2>
<p>
This DSL is a calculator.
Calculators are a familiar example.
And, after all, whatever tool you build this
DSL into, it will probably be useful
to have a calculator as part of it.
What follows contains only the parts of the code
relevant to the discussion,
not necessarily in lexical order.
If you find the following interesting,
you'll almost certainly want the full code,
which is available as
a Github gist.
<p>
<h2>The grammar</h2>
<p>Marpa allows you to build your DSL in as a clean, sensible
structure,
with a separate grammar, tokenize and semantics.
If you're used to doing parsing with regexes or recursive descent,
you expect to see things mixed together,
and much as you might like modularity in other contexts,
this cleaner approach may make you uneasy.
And not without reason, since in the past the tools that used
it were painful to use and,
for cleanly written practical grammars,
often rewarded the programmer's efforts by failing to deliver.
<p>Here's the grammar for our calculator.
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my $rules = Marpa::Demo::OP2::parse_rules(
    <<'END_OF_GRAMMAR'
reduce_op ::= '+' | '-' | '/' | '*'
script ::= e
script ::= script ';' e => do_arg2
e ::=
     NUM
   | VAR => do_is_var
   | :group '(' e ')' => do_arg1
  || '-' e => do_negate
  || :right e '^' e => do_binop
  || e '*' e => do_binop
   | e '/' e => do_binop
  || e '+' e => do_binop
   | e '-' e => do_binop
  || e ',' e => do_array
  || reduce_op 'reduce' e => do_reduce
  || VAR '=' e => do_set_var
END_OF_GRAMMAR
);

</div>
<p>The grammar is written in another DSL, <tt>Marpa::Demo::OP2</tt>,
which is bundled into the same file.
Together, the two quite useable DSL's require 600 lines,
self-testing included.
The calculator grammar is written in OP2,
and OP2's grammar is defined directly in Marpa::R2.
<p>
I'm using OP2 in this post, as it presents the <strong>idea</strong>
of a grammar more clearly.
Marpa::R2's lower level syntax, while more dependable, flexible and efficient,
is more cluttered.
OP2 itself is interesting as an extension and generalization of
precedence parsing,
as I described in
a previous post.
Here's its syntax:
<center>
<table width=80%>
<tr><td><tt>::=</tt><td>A BNF rule in LHS <tt>::=</tt> RHS form</tr>
<tr><td><tt>|</tt><td>Separates alternative RHS's at the <strong>same</strong> precedence level</tr>
<tr><td><tt>||</tt><td>Separates alternative RHS's at the <strong>different</strong> precedence levels.
  The tighter ("higher") precedence alternative is first, the
  tighter ("lower") precedence alternative is second.
  </tr>
<tr><td><tt>=&gt;</tt><td><tt><tt>rule =&gt; semantics</tt>, where <tt>semantics</tt>
is a Perl closure.
</tr>
<tr><td><tt>:left</tt><td>The alternative is left-associative (the default)</tr>
<tr><td><tt>:right</tt><td>The alternative is right-associative</tr>
<tr><td><tt>:group</tt>&nbsp;&nbsp<td>The alternative is grouping-associative -- that is, its
operator(s), regardless of their own precedence,
group expressions of the loosest precedence</tr>
</table>
</center>
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my $grammar = Marpa::R2::Grammar->new(
    {   start          => 'script',
        actions        => __PACKAGE__,
        default_action => 'add_brackets',
        rules          => $rules,
    }
);
$grammar->precompute;
</div>

<h2>The Semantics</h2>
<p>The semantics for this calculator are somewhat interesting,
but this post is about how to get <strong>your</strong> interesting
semantics out easily and quickly in the of form a powerful
language specifically designed for it.
This interested in the semantics of my little caculator
can look at
the Github git.
</p>
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
</div>

<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
    my $rec = Marpa::R2::Recognizer->new( { grammar => $grammar } );
</div>

<h2>The lexer</h2>
<p>So far I have not created a lexer to go with Marpa,
for several reasons.
One of the most important is that it would not add
value -- Perl regex engine is a fine lexer,
and one that is easy to customize.
This second show a way of doing lexing with the
Perl regex engine.
<p>The calculator's is table-driven.
The table is quite simple -- it's an array of 
of two element arrays.
In the inner arrays, the first element is the same name,
as specified in the grammar,
and the second is a regex which matches it.
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">
my @terminals = (
    [ q{'reduce'}, qr/reduce\b/xms ],
    [ 'NUM',  qr/\d+/xms ],
    [ 'VAR',  qr/\w+/xms ],
    [ q{'='}, qr/[=]/xms ],
    [ q{';'}, qr/[;]/xms ],
    [ q{'*'}, qr/[*]/xms ],
    [ q{'/'}, qr/[\/]/xms ],
    [ q{'+'}, qr/[+]/xms ],
    [ q{'-'}, qr/[-]/xms ],
    [ q{'^'}, qr/[\^]/xms ],
    [ q{'('}, qr/[(]/xms ],
    [ q{')'}, qr/[)]/xms ],
    [ q{','}, qr/[,]/xms ],
);
</div>
<p>
The reader will note that I am one of those who specify <tt>xms</tt> for every
regex.
It is not important in this application, but order matters if you have
terminals where one can be the prefix of another, for example,
<tt>==</tt> and <tt>=</tt>.
Note that the symbol names preserve the surrounding single quotes.
This is convenient for processing, bu it also makes diagnostic message involving
those symbols more comprehensible.
Finally, note that the <tt>reduce</tt> operator is required to end on a word boundary.
<p>
The next code fragment is the tokenizing engine.
This looks daunting until you see that 12 lines of the intermost loop are
code for a very specific and comprehensive error message.
One of Marpa's greatest improvements over previous
parsers is that, when a parse fails,
Marpa can tell why in considerable detail.
It makes sense to take advantage of that ability.
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">

    my $length = length $string;
    pos $string = 0;
    TOKEN: while ( pos $string < $length ) {

        # skip whitespace
        next TOKEN if $string =~ m/\G\s+/gcxms;

        # read other tokens
        TOKEN_TYPE: for my $t (@terminals) {
            next TOKEN_TYPE if not $string =~ m/\G($t->[1])/gcxms;
            if ( not defined $rec->read( $t->[0], $1 ) ) {
                say $rec->show_progress() or die "say failed: $ERRNO";
                my $problem_position = ( pos $string ) - length $1;
                my $before_start     = $problem_position - 40;
                $before_start = 0 if $before_start < 0;
                my $before_length = $problem_position - $before_start;
                die "Problem near position $problem_position\n",
                    q{Problem is here: "},
                    ( substr $string, $before_start, $before_length + 40 ),
                    qq{"\n},
                    ( q{ } x ( $before_length + 18 ) ), qq{^\n},
                    q{Token rejected, "}, $t->[0], qq{", "$1"},
                    ;
            } ## end if ( not defined $rec->read( $t->[0], $1 ) )
            next TOKEN;
        } ## end TOKEN_TYPE: for my $t (@terminals)

        die q{No token at "}, ( substr $string, pos $string, 40 ),
            q{", position }, pos $string;
    } ## end TOKEN: while ( pos $string < $length )

</div>

<h2>Evaluating the parse</h2>
<p>
<div style="white-space:pre;overflow:auto;font-family:monospace;margin:0;padding:1em 0 1em 2.8em;">

    $rec->end_input;

    my $value_ref = $rec->value;

    if ( !defined $value_ref ) {
        say $rec->show_progress() or die "say failed: $ERRNO";
        die 'Parse failed';
    }
    return ${$value_ref};

</div>

<h2>Alernatives</h2>
<p>This calculator uses
Marpa::R2.
Marpa::R2 is beta,
while Marpa::XS is in a stable, bug-fix only release.
On the other hand Marpa::R2 is somewhat faster here,
and its reporting of parse-time problems is cleaner.
<br />
<p>posted at: 09:20 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012">/individual/2012</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/dsl.html">direct link to this entry</a>
</p>
<div style="margin:0;height:20px;font-size:xx-large;color:#38B0C0;padding:1px;text-align:center;">
&bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&bull;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="blogs.perl.org">blogs.perl.org</a>.
</div>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body>
</html>
