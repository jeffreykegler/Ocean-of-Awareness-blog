<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Sat, 29 Dec 2012</h3>
<br />
<center><a name="self_lex"> <h2>A self-parsing and self-lexing grammar</h2> </a>
</center>
  <p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
      <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/self_parse.html">In
      a previous post</a>, I showed a self-parsing grammar,
      written in Marpa's new BNF interface.
      That grammar was in a tradition going back to the 70's and,
      following the tradition, I cheated a bit.
      The grammar required,
      but did not include, a lexer to make a prepass over
      its input.
      <p>
      This post contains a self-parsing
      and self-lexing grammar,
      the one for Marpa's forthcoming Scanless interface.
      This grammar is about as self-contained as a grammar can get,
      short of being encoded into a
      <a href="http://en.wikipedia.org/wiki/Universal_Turing_machine">Universal
      Turing machine</a>.
    </p>
    <p>
      Many readers will
      prefer to be introduced to the Scanless interface
      via a simpler example,
      but based on the response to the previous past I know
      there are others who share my fascination with
      self-description and self-exemplification.
      And there is something to be said for reading an example
      that is a final authority on itself.
    </p>
    <p>
      As far as being a practical example,
      this one is certainly as practical as they come.
      This grammar that follows is the one actually used,
      not only to parse itself and all other grammars written for the
      Marpa's Scanless interface,
      but also to parse the strings written
      for Marpa's BNF interface,
      the Scanless interface's predecessor.
    </p>
    <p>
      The grammar in this blog post is abridged a bit,
      and rearranged for ease of explanation.
      The original is
      <a href="https://metacpan.org/source/JKEGL/Marpa-R2-2.035_003/lib/Marpa/R2/meta/metag.bnf">
      here</a>.
    </p><blockquote>
      <pre>
# Copyright 2012 Jeffrey Kegler
</pre></blockquote>
    <p>The file starts with legalese, which I've cut.
    (It is under GNU's LGPL 3.0.)
      Note the hash comment -- since this is a self-describing self-lexer,
      the grammar will eventually tell us how it deals with hash comments.
    </p>
    <blockquote>
      <pre>
:start ::= rules
rules ::= rule+
rule ::= &lt;start rule&gt;
  | &lt;empty rule&gt;
  | &lt;priority rule&gt;
  | &lt;quantified rule&gt;
  | &lt;discard rule&gt;
</pre></blockquote>
    <p>Next it tells us that the
      <tt>rules</tt>
      symbol is the start symbol,
      that our grammar consists of a series of one or more rules,
      and that these rules fall into one of five types.
      A few of the rules is our self-describing grammar are
      themselves self-describing.
      The last rule above is one of them: 
      it is a <tt>&lt;priority rule&gt;</tt>,
      one of the 5 types it allows.
      The previous two lines exemplify two of the other possibilities:
      the first is a <tt>&lt;start rule&gt;</tt>
      and the second is a <tt>&lt;quantified rule&gt;</tt>.
    </p><blockquote>
      <pre>
&lt;start rule&gt; ::= (':start' &lt;op declare bnf&gt;) symbol
&lt;op declare bnf&gt; ~ '::='
</pre></blockquote>
<p>
      The parentheses can be ignored -- they surround symbols
      that are hidden from the semantics.
      (This allows a simpler semantics.)
      Here we see the description of a start rule:
      the
      <tt>:start</tt>
      pseudo-symbol,
      and an
      <tt>::=</tt>
      operator,
      followed by a
      <tt>symbol</tt>.
    </p>
    <p>Above we saw an example of a quantified rule: "<tt>rules ::= rule+</tt>".
    Here is the definition:
    </p>
    <blockquote>
      <pre>
&lt;quantified rule&gt;
  ::= lhs &lt;op declare&gt;
    &lt;single symbol&gt; quantifier &lt;adverb list&gt;
lhs ::= &lt;symbol name&gt;
&lt;op declare&gt;
  ::= &lt;op declare bnf&gt; | &lt;op declare match&gt;
&lt;op declare match&gt; ~ '~'
quantifier ::= '*' | '+'
</pre></blockquote>
    <p>
      A quantified rule contains a left hand side (LHS) symbol name,
      one of the two declaration operators,
      a
      <tt>single symbol</tt>,
      a plus or minus "quantifier",
      and an adverb list.
      The adverb list can be empty, as it was in our example,
      and in fact has been in every rule so far.
    </p>
    <p>The two rule declaration operators
    ("<tt>::=</tt>" and "<tt>~</tt>")
    are for two different kinds of rule.
    The BNF operator ("<tt>::=</tt>") is for rules at the higher level -- "structural rules".
    The match operator ("<tt>~</tt>") is lower-level rules == "lexical rules".
    </p>
    <p>
    There are two easy quidelines as to which rule to use.
    If you want the RHS exactly as you've stated it, character-for-character,
    it is a lexical rules and you should use the match operator: "<tt>~</tt>".
    If you want Marpa to "do what you mean" about whitespace and comments when it comes
    to interpreting the RHS, it is a strutural rule,
    and you should use the BNF operator "<tt>::=</tt>".
    </p>
    <p>
    This structural/lexical division corresponds very closely to Perl 6's
    distinction between the "rule" and "token".
    It also corresponds closely to the lexer/parser division of labor,
    as used in compilers.
    </p>
    <p>
      Next come the two rules we've yet to see:
    </p>
    <blockquote>
      <pre>
&lt;discard rule&gt;
  ::= (':discard' &lt;op declare match&gt;) &lt;single symbol&gt;
&lt;empty rule&gt; ::= lhs &lt;op declare&gt; &lt;adverb list&gt;
</pre></blockquote>
    <p>
      We'll explain what a "discard rule" is when we encounter one.
      We won't encounter an empty rule in this grammar.
      An empty rule indicates that its LHS symbol is nullable.
      Note that an empty rule can have an adverb list.
    </p>
    <blockquote>
      <pre>
&lt;priority rule&gt; ::= lhs &lt;op declare&gt; priorities
priorities ::= alternatives+
    separator =&gt; &lt;op loosen&gt; proper =&gt; 1
&lt;op loosen&gt; ~ '||'
alternatives ::= alternative+
    separator =&gt; &lt;op equal priority&gt; proper =&gt; 1
alternative ::= rhs &lt;adverb list&gt;
&lt;op equal priority&gt; ~ '|'
</pre></blockquote>
    <p>
      Most rules, including most of the rules we've already seen,
      are priority rules,
      so-called because in their most complicated form they can express
      a precedence scheme.
      The typical rule in a grammar is a priority rule with only
      one priority -- we've yet to see anything else.
      Within priorities, there can be alternatives,
      and we have seen example of this.
      When
      <tt>rule</tt>
      was defined as being one of a set of possible
      rule types, priority rule being among those types,
      the different types of rule were alternatives within a single
      priority.
    </p>
    <p>We've used
      <tt>symbol</tt>,
      <tt>&lt;symbol name&gt;</tt>,
      and
      <tt>&lt;single symbol&gt;</tt>
      a few times.
      It's time to see how they are defined:
    </p>
    <blockquote>
      <pre>
&lt;single symbol&gt; ::=
    symbol
  | &lt;character class&gt;
symbol ::= &lt;symbol name&gt;
&lt;symbol name&gt; ::= &lt;bare name&gt;
&lt;symbol name&gt; ::= &lt;bracketed name&gt;
&lt;bare name&gt; ~ [\w]+
&lt;bracketed name&gt; ~ '&lt;' &lt;bracketed name string&gt; '&gt;'
&lt;bracketed name string&gt; ~ [\s\w]+
</pre></blockquote>
    <p>At this point,
      <tt>symbol</tt>
      and
      <tt>&lt;symbol name&gt;</tt>
      are
      essentially the same thing:
      someday there may be another way to specify symbols
      except by name.
      <tt>&lt;single symbol&gt;</tt>
      means any expression guaranteed
      to produce a single symbol.
      <tt>symbol</tt>
      is obviously one;
      a character class is the other.
    </p><p>Now that we know what a symbol can be,
      let's look at how right hand sides are built up:
    </p>
    <blockquote>
      <pre>
rhs ::= &lt;rhs primary&gt;+
&lt;rhs primary&gt; ::= &lt;single symbol&gt;
&lt;rhs primary&gt; ::= &lt;single quoted string&gt;
&lt;rhs primary&gt; ::= &lt;parenthesized rhs primary list&gt;
&lt;parenthesized rhs primary list&gt;
  ::= ('(') &lt;rhs primary list&gt; (')')
&lt;rhs primary list&gt; ::= &lt;rhs primary&gt;+
</pre></blockquote>
<p>A right hand side (RHS) is a sequence of one or more RHS "primaryies".
These can be single symbols, strings in single quotes,
or a sublist of RHS primaries in parentheses.
<p>And here is the syntax for adverb lists:
    <blockquote>
      <pre>
&lt;adverb list&gt; ::= &lt;adverb item&gt;*
&lt;adverb item&gt; ::=
      action
    | &lt;left association&gt;
    | &lt;right association&gt;
    | &lt;group association&gt;
    | &lt;separator specification&gt;
    | &lt;proper specification&gt;
</pre></blockquote>
<p>Adverb lists are lists of zero or more adverbs, which can be of one of five kinds.
Some of the adverbs have to do with the associativity (right/left/group)
of priorities.
Since all our "prioritized" rules are trivial (have only one priority),
this grammar does not include any of the following:
    <blockquote>
      <pre>
&lt;left association&gt; ::= ('assoc' '=&gt;' 'left')
&lt;right association&gt; ::= ('assoc' '=&gt;' 'right')
&lt;group association&gt; ::= ('assoc' '=&gt;' 'group')
action ::= ('action' '=&gt;') &lt;action name&gt;
&lt;action name&gt; ::= &lt;bare name&gt;
</pre></blockquote>
<p>We also will not see <tt>action</tt> adverbs in this grammar,
for reasons explained below.
Here are two adverbs the we do see:
    <blockquote>
      <pre>
&lt;separator specification&gt;
  ::= ('separator' '=&gt;') &lt;single symbol&gt;
&lt;proper specification&gt; ::= ('proper' '=&gt;') boolean
boolean ~ [01]
</pre></blockquote>
<p>Next, the rules that deal with whitespace.
    <blockquote>
      <pre>
:discard ~ whitespace
whitespace ~ [\s]+
</pre></blockquote>
<p>The two rules say that sequences of whitespace are recognized
as tokens, then discarded.
It is as simple as that.
Perl-style comments are handled in the same way:
    <blockquote>
      <pre>
# allow comments
:discard ~ &lt;hash comment&gt;
&lt;hash comment&gt; ~ &lt;terminated hash comment&gt;
  | &lt;unterminated final hash comment&gt;
&lt;terminated hash comment&gt;
  ~ '#' &lt;hash comment body&gt; &lt;vertical space char&gt;
&lt;unterminated final hash comment&gt;
  ~ '#' &lt;hash comment body&gt;
&lt;hash comment body&gt; ~ &lt;hash comment char&gt;*
&lt;vertical space char&gt; ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
&lt;hash comment char&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
</pre></blockquote>
<p>"Unterminated final hash comments" deal with the special
case of hash comments at the end of a file that is not properly
terminated with a newline.
The <tt>&lt;unterminated final hash comment&gt;</tt> symbol is an example of how
long angle bracketed symbol name can make things clearer.
Without the long name, it might not be evident what that rule and symbol
were trying to accomplish.
Comments, of course, can accomplish the same thing, but the long names can
be cleaner.
Their special advantage (and, in some contexts, disadvantage)
is that their fuller description
is propagated to wherever that symbol is used.
<p>In the next snippet, defining single-quoted strings,
the description is clearly too long for the symbol name,
so much of does go into a comment.
    <blockquote>
      <pre>
# In single quotes strings and character classes
# no escaping or internal newlines, and disallow empty string
&lt;single quoted string&gt;
  ~ ['] &lt;string without single quote or vertical space&gt; [']
&lt;string without single quote or vertical space&gt;
  ~ [^'\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]+
</pre></blockquote>
<p>Note the two Unicode vertical whitespace codepoints
U+2028 and U+2029 are included.
For the moment, the implementation only supports 7-bit ASCII,
so these are superfluous.
But when Unicode support is added, the grammar won't need to be changed.
<p>Finally, there are character classes:
    <blockquote>
      <pre>
&lt;character class&gt; ~ '[' &lt;cc string&gt; ']'
&lt;cc string&gt; ~ &lt;cc character&gt;+
&lt;cc character&gt; ~ &lt;escaped cc character&gt;
  | &lt;safe cc character&gt;
&lt;escaped cc character&gt; ~ '\' &lt;horizontal character&gt;

# hex 5d is right square bracket
&lt;safe cc character&gt;
  ~ [^\x{5d}\x{0A}\x{0B}\x{0C}\x{0D}\x{0085}\x{2028}\x{2029}]

# a horizontal character is any character that is not vertical space
&lt;horizontal character&gt; ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
</pre></blockquote>
<p>These are Perl character classes,
to be passed straight to Perl for intrepretation.
The grammar need only recognize strings enclosed by square brackets.
But it must deal with escaped square brackets,
and this is enough to make character
classes the most
complicated lexeme of the grammar.
    </p>
    <h3>Semantics</h3>
    <p>The Scanless interface's meta-grammar, is unusual in its semantics
      because it serves a dual purpose -- it is also the grammar for Marpa's
      BNF interface, which has a different semantics.
      In practice, a grammar is usually tied tightly to one semantics,
      but this is an exception.
    </p><p>
      For most grammars in either the Marpa's BNF or Scanless interface,
      the semantics would be specified using
      <tt>action</tt>
      adverbs.
      For this grammar, there are no
      <tt>action</tt>
      adverbs -- internally,
      Marpa waits until it knows which interface the grammar will be used for,
      then uses the symbol names to determine the actions on a "just in time"
      basis.
    </p><p>
      Standard applications will
      labeling rules and alternatives with
      <tt>action</tt>
      adverbs.
      Example of this are in the documentation for the BNF
      and Scanless interfaces.
    </p><h3>Comments</h3>
    <p>
      Comments on this post can be sent to the Marpa Google Group:
      <code>marpa-parser@googlegroups.com</code>
    </p>
<br />
<p>posted at: 19:03 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/12/self_lex.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
