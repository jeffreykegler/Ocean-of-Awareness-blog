<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>How to parse HTML, part 2</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/12/07#how-to-parse-html-part-2</link>
    <description>&lt;p&gt;
This is the second of a series of posts that details
a Marpa-based, &quot;Ruby Slippers&quot;
approach to parsing liberal
and defective HTML.
This post assumes you have 
read
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/11/how-to-parse-html.html&quot;&gt;
the first post&lt;/a&gt;.
&lt;/p&gt;
&lt;h2&gt;First, reduce the HTML to a token stream&lt;/h2&gt;
&lt;p&gt;
Most computer languages can be viewed
as a token stream.
HTML is not an exception.
HTML tokens can be blocks of text;
comments and various other SGML entities;
HTML element start tags;
and HTML element end tags.
The HTML token stream is unusual in that
some of its tokens can
be quite complex internally.
&lt;/p&gt;
In parsing computer languages,
it is a frequent practice to divide the
work between a tokenizer (&quot;lexer&quot;)
and a &lt;a href=&quot;#HIGH-LEVEL&quot;&gt;high-level parser&lt;/a&gt;.
The lexer takes the raw input
and turns it into a token stream.
Tokenizing HTML is a difficult job,
and one for which there is an excellent CPAN module:
&lt;a href=&quot;https://metacpan.org/module/HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt;.
&lt;a href=&quot;https://metacpan.org/module/Marpa::HTML&quot;&gt;Marpa::HTML&lt;/a&gt;

relies on
&lt;a href=&quot;https://metacpan.org/module/HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt;
to do its tokenization.
&lt;p&gt;
&lt;/p&gt;
&lt;a href=&quot;https://metacpan.org/module/Marpa::HTML&quot;&gt;Marpa::HTML&lt;/a&gt;
determines the large scale structure of the HTML document --
what I will call in this post, &quot;high-level&quot; parsing.
The result of high-level parsing can be
seen as a hierarchical structure.
The goal of high-level parsing is
to build a hierarchy which reflects
the structure of the document.
Conventionally, this hierarchy is visualized
as an upside-down tree,
one where the &quot;leaves&quot; are the tokens,
and where the &quot;root&quot; node represents the
document as a whole.</description>
  </item>
  </channel>
</rss>
