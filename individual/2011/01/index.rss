<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Why I Stuck With Perl</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/01/22#why-i-stuck-with-perl</link>
    <description>&lt;p&gt;I've just read
&lt;a href=&quot;http://everythingsysadmin.com/2011/01/python-is-better-than-perl6.html&quot;&gt;
a very thoughtful
description&lt;/a&gt;
of why one Perl
programmer switched to Python.
In this blog post, I'll explain why I did not.

&lt;p&gt;When I started on the
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;
project, Perl was
not an automatic choice.
In fact it looked like it might
be the wrong one.
There was as much buzz for Python then
as now.
Maybe more.
I'd had my own
experience with Python,
and it was excellent.
I'd used Python to create a threaded mail client for
testing purposes.
I found Python to be easy to learn, fun to use,
and an effective way to accomplish my task.

&lt;p&gt;Perl had another problem.
An important audience for
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;,
&lt;a href=&quot;#NOTE1&quot;&gt;my new parser&lt;/a&gt;, 
is academia.
Academics certainly use Perl.
My experience is that they even respect it in a certain sense.
But Perl does not fit neatly into the minimalist
paradigms which still rule academia.
If you speak Perl to academics, you are not talking
their language.
That means you run a great
risk that nobody will listen.

&lt;p&gt;I read and studied a lot about the relative merits
and demerits
of various scripting languages.
Others have covered, and continue to cover, that ground
very well.
Let me go straight to explaining why I stuck.
Perl has CPAN.  And CPAN ...  well, let me tell you a story.

&lt;h1&gt;An Incident on CPAN&lt;/h1&gt;
&lt;p&gt;Recently, my development version of Marpa::XS showed a lot of failures
from the cpantesters.
This happened immediately after a mild brag in this blog,
about my impressive success rate in writing portable C code.
It was like one of those Greek myths,
where one of the Gods in Olympus decides a big-talking mortal needs to be taken down a peg.


&lt;p&gt;I did not receive any lightning bolts, but I sure got a variety of test
failures.
With considerable effort,
I was able to eliminate
all but one of these on my own.
The remaining failure happened only on the tests run by Andreas Koenig.
Not that I expected Andreas's setup was at fault --
it was more likely that all the other setups were being liberal where
Andreas was being strict.
Which is what turned out to be the case.

&lt;p&gt;So I emailed Andreas.
Frankly, I did not have high expectations.
Andreas is doing a lot of important things.
My guess was that
discovering why new C code on the unstable development version
of a new module does not execute in his test setup
might take quite a while to percolate to the top of his &quot;to do&quot; list.

&lt;p&gt;I was therefore very surprised when the answer rocketed back.
My development version of Marpa::XS failed only with the development
versions of Module::Build later than a certain version number.
Andreas, it turns out,
is set up to do regression analysis, and the regression analysis
pointed straight to the combination.

&lt;p&gt;For those of you who don't know, regression analysis essentially sets up
an equation combining various factors (in this case, module versions, Perl versions,
hardware, OS, etc.) with an outcome (in this case, success or failure).
It can be used to see which factors correlate with which outcomes --
in this case, which combinations of modules, hardware, etc. are correlated
with failures.

&lt;p&gt;It's a very cool technique.
(I tried to get my clients to use it in my consulting practice,
but there was just too much pushback on the math.)
Andreas's regression tools pointed straight to the problem.
It began to happen when Module::Build switched to non-lazy
loading of dynamic code.

&lt;p&gt;Here's what my bug was.  I had declared a C function, call it
&lt;var&gt;xyz()&lt;/var&gt;.
But I had never defined &lt;var&gt;xyz()&lt;/var&gt; -- there was no code for it.
But I also never called
&lt;var&gt;xyz()&lt;/var&gt; anywhere.
With lazy dynamic loading, that meant no attempt to load
&lt;var&gt;xyz()&lt;/var&gt; was ever made.
So with lazy loading, my bug was harmless.


&lt;p&gt;In the name of thorough testing, Module::Build was switching to
non-lazy loading.  This meant that, call or no call, my executable
looked for
&lt;var&gt;xyz()&lt;/var&gt; and, when it did not find it, abended.

&lt;p&gt;In his email to me,
David Golden left it an open question whether testing with
lazy or non-lazy loading is best.
I'll leave the final resolution of that to his capable judgement.
For Marpa, I think Module::Build's new behavior is the best,
and I've changed my test setup to always be non-lazy.
In the future, any never-called never-defined function like
&lt;var&gt;xyz()&lt;/var&gt; will abend in my test setup.

&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;My quest is to make Marpa's C-enabled version
widely portable.
To this end, CPAN not only offers
me free widespread testing, but even fast, polite, high-quality help with
debugging.
Would I get that if I were programming in a language other than Perl?
&lt;p&gt;&lt;a name=&quot;NOTE1&quot;&gt;&lt;b&gt;Note 1:&lt;/b&gt;&lt;/a&gt;
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;  parses any grammar that you can write in BNF,
and parses all grammars parseable by yacc or recursive descent in linear time.</description>
  </item>
  <item>
    <title>Perl and Parsing 6: Error Handling </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/01/09#perl-and-parsing-6-error-handling</link>
    <description>&lt;h2&gt;Is the Perl interpreter psychic?&lt;/h2&gt;
&lt;p&gt;An important consequence of the choice of parsing algorithm
is the
&lt;a href=&quot;#NOTE1&quot;&gt;handling of parse-time errors&lt;/a&gt;.
It's often overlooked.
Perl's use of LALR based parsing puts severe limits on its
ability to locate errors,
limits which the Perl interpreter is sometimes able to overcome.
Consider the following erroneous piece of code.
&lt;pre&gt;
&lt;code class=&quot;prettyprint&quot;&gt;
my $lyric =
'Sloopy wears a red dress, yeah
As old as the hills
but when sloopy wears that red dress, yeah
you know it gives me the chills
Sloopy when I see you walking, 
walking down the street
I say don't worry sloopy, girl
You belong to me';
print &quot;$lyric\n&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Some of you may have spotted this as the lost third verse of the
October 1965 US #1 hit, &quot;Hang on Sloopy&quot;.
Others may notice that the single quote in &quot;don't&quot;
is going to make things come out pear-shaped.
On this latter point,
the Perl interpreter's performance is uncanny, if a bit noisy:
&lt;p&gt;&lt;pre&gt;
&lt;code class=&quot;prettyprint&quot;&gt;
Bareword found where operator expected at bomb.pl line 8, near &quot;I say don't&quot;
  (Might be a runaway multi-line '' string starting on line 2)
        (Do you need to predeclare I?)
syntax error at bomb.pl line 8, near &quot;I say don't worry &quot;
Bad name after me' at bomb.pl line 9.
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;I just said that Perl's LALR-based parsing made error detection difficult.
So how do I explain the above, where the error detection is not merely good,
it almost seems psychic?
&lt;h2&gt;Behind the Smoke and Mirrors&lt;/h2&gt;
&lt;p&gt;A closer look will show how Perl pulls off this bit of apparent
mind-reading.
If you look at &lt;var&gt;toke.c&lt;/var&gt;, you'll see the trick.
Globals in the tokenizer track the beginning and ending of the 
most recent multi-line object.
Anytime a multi-line object ends just before an error,
the Perl interpreter fingers it.
It's a bit like police lieutenant Arthur Tragg in the old Perry Mason
series, who on discovering a murder victim, always arrested the next
person he saw -- usually Mason's client.
It's a good guess and,
unlike the indefatigable Arthur Tragg,
who persisted despite turning out to be wrong week after week,
it works for the Perl interpreter most of the time.
&lt;p&gt;But not always.
Let's rearrange this example, so that the string is OK,
and we're depending on the LALR parser to locate an error.
&lt;p&gt;&lt;pre&gt;
&lt;code class=&quot;prettyprint&quot;&gt;
my $lyric =
'Sloopy wears a red dress, yeah
As old as the hills
but when sloopy wears that red dress, yeah
you know it gives me the chills
Sloopy when I see you walking, 
walking down the street
I say don\'t worry sloopy, girl
You belong to me'~!@$%^&amp;*()_+;
print &quot;$lyric\n&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;pre&gt;
&lt;code class=&quot;prettyprint&quot;&gt;
Bareword found where operator expected at bomb2.pl line 9, near &quot;)_&quot;
        (Missing operator before _?)
syntax error at bomb2.pl line 9, near &quot;You belong to me'~&quot;
  (Might be a runaway multi-line '' string starting on line 2)
Execution of bomb2.pl aborted due to compilation errors.

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This example clearly illustrates the limits of LALR parsing.
A multi-line string just
ended, and the tokenizer duly drops the dime,
but there's no way to make the charge stick.
The multi-line string is fine,
and the problem is somewhere in the special characters after it.

&lt;p&gt;
But where?
Now that we are no longer dazzled by the psychic abilities of the tokenizer,
let's carefully define what we mean by the actual error location.
The error location is the first character which makes a valid parse impossible.
Put another way, if a parser reads a character, and that character renders
it impossible that any subsequent reading of characters
will produce a valid parse, then the location
of that character is the error location.

&lt;p&gt;Where is the error location in this example?
I think it may be at the '%' sign,
but I frankly don't know.
More to the point, neither does the Perl interpreter,
though it throws out guesses all over the map.

&lt;h2&gt;The Immediate Error Detection Property&lt;/h2&gt;
&lt;p&gt;The error-locating ability of parsing algorithms divides them into
two types.
&quot;Immediate error detection&quot; is what you'd like to see in a parser --
the moment the parser encounters a character which makes a valid parse
impossible, it knows it.
Other parsers, and LALR is prominent among them, need to grind on,
reading more characters.
Only later do they realize something has gone wrong.

&lt;p&gt;When recursive descent is full LL(1) it has the immediate error detection
property.
(In simplified terms, recursive descent is full LL(1) when it is
smart about lookahead for
empty rules.)
Recursive descent implementations which are not full LL(1) do not
have the immediate error detection property.
This is the case with most actual implementations of
recursive descent.
On the other hand,
recursive descent's major attraction is that it is hack-friendly,
so that a recursive descent implementation which is less than full LL(1)
in theory might well
do immediate error detection when it counts.

&lt;p&gt;Earley's algorithm has the immediate error detection property.
My implementation of it in
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;
has the
immediate error detection property and then some.
When it is about to read a token,
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;
knows, and can inform the lexer,
exactly which input symbols
will result in a viable parse.
This allows &lt;a
href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html&quot;&gt;

some very nice tricks&lt;/a&gt;.
&lt;p&gt;&lt;a name=&quot;#NOTE1&quot;&gt;&lt;b&gt;Note 1&lt;/b&gt;&lt;/a&gt;:
For the readers of my last post on &lt;var&gt;yacc&lt;/var&gt;,
the discussion of error reporting here changes the subject:
That post dealt with the reporting of errors by a parser generator while the parser is
being generated: generation-time error reporting.
This post changes the topic to the reporting of errors in its input by a parser:
parse-time error reporting.
My next post in the
&lt;var&gt;yacc&lt;/var&gt;
series will discuss
&lt;var&gt;yacc&lt;/var&gt;'s
parse-time error reporting.
&lt;p&gt;For a hand-written parser, of course, there is no such thing as generation-time,
and therefore generation-time error reporting is a non-issue.
Parse-time error reporting is an issue for all parsers,
whether generated or hand-written.</description>
  </item>
  </channel>
</rss>
