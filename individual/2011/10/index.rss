<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Perl and Parsing 12: Beating up on the &quot;use&quot; statement</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/10/30#perl-and-parsing-12-beating-up-on-the-use-statement</link>
    <description>&lt;p&gt;
If you have been following the Perl blogosphere recently,
you may have noticed that it has been a bad few weeks
for Perl's &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement.
I have been
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/10/perl-and-parsing-10-use-the-easier-way.html&quot;&gt;
picking it apart&lt;/a&gt;
in this series,
and chromatic, on his blog,
&lt;a href=&quot;http://www.modernperlbooks.com/mt/2011/10/what-perl-5s-use-really-does.html&quot;&gt;
recently pointed out a documentation issue&lt;/a&gt;.
Unlike chromatic, who focuses on user concerns,
I use Perl as a way to implement and to illustrate parsing.
Though, to be sure,
one of the points I try to make
is that the choice of parsing strategy
is ultimately very much a user concern.
&lt;/p&gt;
&lt;p&gt;
I find
Perl's &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement
especially interesting because it is a good example of
a natural syntax that you would like to be easy to parse,
but which proves problematic with current parsing technology.
With a general BNF parser, like Marpa, 
Perl's &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement is easy to parse.
But the &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement strains
Perl's parser LALR parse engine to the limits.
Indeed, as I will show next, even a bit beyond.

&lt;/p&gt;
&lt;h2&gt;Reversed use statements&lt;/h2&gt;
&lt;p&gt;
Consider this statement
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;use 2 Fatal;&lt;/code&gt;
&lt;/pre&gt;
Perl accepts this without error or warning, and interprets it as
a request of at least version 2 of the &lt;code class=&quot;prettyprint&quot;&gt;Fatal&lt;/code&gt;
module.
But there's a problem.
If you missed it,
look carefully -- module name and version are reversed
from the documented order.
As documented, the statement should be
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;use Fatal 2;&lt;/code&gt;
&lt;/pre&gt;</description>
  </item>
  <item>
    <title>Marpa::XS is now beta</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/10/23#marpaxs-is-now-beta</link>
    <description>&lt;p&gt;
I am very happy to announce that
&lt;a href=&quot;http://search.cpan.org/~jkegl/Marpa-XS-0.018000/&quot;&gt;
Marpa::XS is now beta&lt;/a&gt;.
Marpa::XS will kept stable.
Changes to its interface will be especially avoided.
&lt;/p&gt;
&lt;h1&gt;What is Marpa?&lt;/h1&gt;
&lt;p&gt;Marpa is an advance over recursive descent
and yacc.
I hope the Marpa algorithm
will become the standard parser for
problems too
big for regular expressions.
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Marpa parses,
&lt;a href=&quot;#LINEAR&quot;&gt;
in linear time&lt;/a&gt;,
those
classes of grammar that are currently in practical use.
&lt;/li&gt;
&lt;li&gt;The importance of parse-time debugging is often underestimated.
Marpa's parse-time error detection breaks new ground -- Marpa is
fully aware of exactly where in the parse it is at all times,
and of exactly what input it expects and why.
This means parse-time error detection, once a desperate last
resort, now can be used as
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html&quot;&gt;

a parsing technique in itself&lt;/a&gt;.

&lt;/li&gt;
&lt;li&gt;Marpa is a general BNF parser -- that means if you feed it anything
written in BNF, it &quot;just parses&quot; it.
This includes grammars which are left-recursive, right-recursive and
ambiguous -- even infinitely ambiguous.
&lt;/li&gt;
&lt;li&gt;Marpa never goes exponential -- worst case, even for highly ambiguous
grammars, is O(n**3), which is
&lt;a href=&quot;#OPTIMAL&quot;&gt;considered optimal&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;New with this release&lt;/h1&gt;
&lt;p&gt;
Marpa::XS 0.018000 contains two new
ranking methods.
These ranking methods allow applications to control
the order of parse trees within
an ambiguous parse.
The two new ranking methods are the &lt;code class=&quot;prettyprint&quot;&gt;rule&lt;/code&gt;
ranking method and
the &lt;code class=&quot;prettyprint&quot;&gt;high_rule_only&lt;/code&gt; ranking method.
In both methods, integer ranks are assigned to rules,
and alternative parsings are ordered on a top-down, left-to-right basis.
When it comes to comparing choices by rule rank, ties are allowed --
in fact, they are common.
By default, all the alternatives at every choice point
tie with each other.
When they are tied in rank,
the order of choices is arbitrary.

&lt;/p&gt;
In the &lt;code class=&quot;prettyprint&quot;&gt;rule&lt;/code&gt; ranking method, all the parse trees are
kept, and visited in order.
In the &lt;code class=&quot;prettyprint&quot;&gt;high_rule_only&lt;/code&gt; ranking method,
only the highest ranked alternatives are kept,
and they are visited in arbitrary order.
Because of ties, more than one of the alternatives at a choice point
can be &quot;highest&quot;.
A full description of the new ranking methods
is &lt;a href=&quot;http://search.cpan.org/perldoc?Marpa::XS::Semantics::Order&quot;&gt;
in Marpa::XS's documentation&lt;/a&gt;.</description>
  </item>
  <item>
    <title>Announcing Marpa::XS 0.016000</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/10/14#announcing-marpaxs-0016000</link>
    <description>&lt;p&gt;
I released
&lt;a href=&quot;http://search.cpan.org/~jkegl/Marpa-XS-0.016000/&quot;&gt;
Marpa::XS 0.016000&lt;/a&gt;
a week ago and the
cpantesters results look excellent.
With this release, my conversion of Marpa from Perl to C
is finished.
A lot of Perl code remains, to be sure,
but all of it is code that
arguably belongs in some kind of
&lt;a href=&quot;#HLL&quot;&gt;higher-level language&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
This release was checked 
for leaks and other memory issues.
The couple of issues that turned up were fixed.
&lt;/p&gt;
&lt;h1&gt;What is Marpa?&lt;/h1&gt;
&lt;p&gt;Marpa is an advance over recursive descent
and yacc.
I hope the Marpa algorithm
will become the standard parser for
problems too
big for regular expressions.
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Marpa parses

&lt;a href=&quot;#LINEAR&quot;&gt;
in linear time&lt;/a&gt;,
all
classes of grammar that are currently in practical use.
&lt;/li&gt;
&lt;li&gt;The importance of parse-time debugging is often underestimated.
Marpa's parse-time error detection breaks new ground -- Marpa is
fully aware of exactly where in the parse it is at all times,
and of exactly what input it expects and why.
This means parse-time error detection, once a desperate last
resort, now can be used as
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html&quot;&gt;
a parsing technique in itself&lt;/a&gt;.

&lt;/li&gt;
&lt;li&gt;Marpa is a general BNF parser -- that means if you feed it anything
written in BNF, it &quot;just parses&quot; it.
This includes grammars which are left-recursive, right-recursive and
ambiguous -- even infinitely ambiguous.
&lt;/li&gt;
&lt;li&gt;Marpa never goes exponential -- worst case, even for highly ambiguous
grammars, is O(n**3), which is
&lt;a href=&quot;#OPTIMAL&quot;&gt;considered optimal&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What is next with Marpa?&lt;/h1&gt;

&lt;p&gt;
At this point,
little remains to be done before a
a 1.000000 beta release of Marpa::XS.
Once Marpa::XS does go beta, I expect to be able to keep
its interface stable.
&lt;/p&gt;
&lt;p&gt;
Inside Marpa::XS,
the portions converted to C amount to
a complete, if low-level, parsing library.
The &lt;kbd&gt;libmarpa&lt;/kbd&gt; library
does not, however, have the documentation that you'd expect in
a library being released on its own.
&lt;/p&gt;
&lt;p&gt;
Also, frankly, before writing the documentation,
I need to redo the interface to &lt;kbd&gt;libmarpa&lt;/kbd&gt;.
As long as the interface to libmarpa was a strictly internal affair,
I didn't worry about it much --
I made the first cut at a design, and got it working.
I then looked at the result.
If the design was so awful that
it got in the way of features or was an efficiency issue,
I fixed it.
If ugliness or awkwardness was its main issue, I moved on.
With the first pass and a few trial applications behind me,
I now
know how the &lt;kbd&gt;libmarpa&lt;/kbd&gt; interface should look.
&lt;/p&gt;

&lt;p&gt;
Once I have &lt;kbd&gt;libmarpa&lt;/kbd&gt; finished and documented,
the next step will be Marpa::Thin.
These days a lot of people like to hack interfaces.
The Marpa project is about the parse engine -- when it
comes to interfaces, I want to put everyone else on a level
playing field with me, if not get out of the game altogether.
Marpa::Thin will be a &quot;thin&quot; Perl interface to &lt;kbd&gt;libmarpa&lt;/kbd&gt;.
&lt;/p&gt;
&lt;p&gt;
Currently, I plan to create a SWIG interface to &lt;kbd&gt;libmarpa&lt;/kbd&gt;,
which means that any environment that SWIG supports
(and there are a lot of them)
will have access to the low-level Perl library.
I have mixed feelings about Marpa leaving its Perl home,
but I think most Perlers share my belief --
we contribute to the Perl community,
not because it is a goal in itself,
but because it is the best way to
contribute to a larger community.
&lt;/p&gt;
&lt;h1&gt;Limitations and Comparisons&lt;/h1&gt;
&lt;p&gt;
Currently, the major limitation of Marpa::XS is
that it is alpha.
Development is well advanced, but the interface remains
subject to change.
For a comparison of Marpa to other parsers,
one which is careful to point out situations
where older parsing algorithms may still be superior,
see the
&quot;Limitations and Comparisons&quot; section

&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/08/announcing-marpaxs-080.html&quot;&gt;
in my announcement of Marpa::XS 0.008000&lt;/a&gt;.
&lt;/p&gt;&lt;h2&gt;Notes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a name=&quot;HLL&quot;&gt;&quot;higher-level language&quot;: &lt;/a&gt;
Of course, depending on the application, the ideal &quot;high-level language&quot;
may be C.
But I feel no real need to convert the code for the user interfaces
to C,
and the scripts for building and testing really should be in a
highly portable high-level language.
&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;LINEAR&quot;&gt;&quot;in linear time&quot;: &lt;/a&gt;
To be specific, Marpa parses any LR-regular grammar in linear time -- O(n).
LR-regular is a vast class of grammars that includes LALR,
LR(k) for all k,
and LL(k) for all k.
This means that Marpa parses,
in linear time,
every grammar parsed by yacc,
recursive descent and regular expressions.
&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;OPTIMAL&quot;&gt;&quot;considered optimal&quot;: &lt;/a&gt;
The phrase &quot;considered optimal&quot; elides some
irrelevant bits of theory.
It would be a bit of a
surprise if it is possible to
do general BNF parsing
in O(n), but nobody has proved that it can't be done.
The Valiant algorithm parses general BNF
and is O(n**2.376...) or better.
But Valiant's algorithm is only faster for huge problems,
and for those it
needs a machine with many terabytes of main memory
to deliver on its speed claims.
So it won't be competing with Marpa any time soon.

&lt;/p&gt;</description>
  </item>
  <item>
    <title>Perl and Parsing 11: Are all Perl programs parseable?</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/10/07#perl-and-parsing-11-are-all-perl-programs-parseable</link>
    <description>&lt;p&gt;
Before going further in &lt;a href=&quot;#SERIES&quot;&gt;this series&lt;/a&gt;,
I want to touch on a question I have so far
avoided:
Are all Perl programs parseable?
&lt;/p&gt;
&lt;p&gt;
Most languages do not pose this question.
It was Adam Kennedy, in creating PPI, who
first ran up
against it.
Adam conjectured that in fact
Perl parsing may be undecidable.
While in the planning stages for Marpa,
I found Adam's conjecture
and
&lt;a href=&quot;http://www.jeffreykegler.com/Home/perl-and-undecidability&quot;&gt;
turned it into a formal proof&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Being the first to formalize this result, I took the
initial heat over it, and now I get the credit.
The dust has pretty much settled,
and to my mild surprise, the result has proved of
interest to the academic community.
The initial revulsion at the idea of undecidable
parsing has subsided,
even to the extent that others now want to get into
the act.
&lt;a href=&quot;http://en.wikipedia.org/wiki/Programming_language#Syntax&quot;&gt;
I read on Wikipedia that LISP parsing is also undecidable&lt;/a&gt;.
So all the cool kids seem to be doing it.
&lt;/p&gt;

&lt;p&gt;
Undecidability is actually something we are quite comfortable
with -- all the general-purpose CPU chips we use have this
property,
and we put up with it as the price for their power.
In the case of general-purpose CPU chips,
the downside is real and occasionally serious.
Some of the things our computers cannot do are reasonable
things for us to want them to do.
As one example,
infinite loop detection can never be 100% accurate.
As another, very serious issue,
no program will ever be able to determine
with 100% accuracy whether an arbitrary program 
is or is not a virus.
Virus detection must always involve a degree of guesswork.
&lt;p&gt;
The undecidability of
Perl parsing differs from the usual situation in one major
respect:
In return for the additional power of Perl's parser,
we seem to be giving up absolutely nothing.
Nobody has ever been able to show a practical downside.
&lt;/p&gt;
&lt;p&gt;
True, as I have proved, there are Perl programs
that no parser,
including the perl interpreter itself,
can parse.
But all the examples that anyone,
including me, has been able
to come up are contrived cases.
None of them are Perl programs that
someone might care about as a practical matter.
&lt;/p&gt;
&lt;p&gt;
In future posts, I plan to discuss various strategies
for parsing Perl.
I will not mention the
undecidability issue again,
unless it has some relevance in context --
something that will seldom happen.
&lt;/p&gt;
&lt;h2&gt;Notes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&quot;SERIES&quot;&gt;&quot;this series&quot;&lt;/a&gt;:
Previous posts in this series have been

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html&quot;&gt;
Parsing with Ruby Slippers&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-perl-2-down-the-garden-path.html&quot;&gt;
Parsing Perl 2: Down the Garden Path&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/07/parsing-perl-3-perl-and-minimalism.html&quot;&gt;
Parsing Perl 3: Perl and Minimalism&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/08/perl-and-parsing-4-the-golden-age-of-right-parsing.html&quot;&gt;
Perl and Parsing 4: The Golden Age of Right Parsing&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/09/perl-and-parsing-6-rewind.html&quot;&gt;
Perl and Parsing 5: Rewind&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/01/perl-and-parsing-6-error-handling.html&quot;&gt;

Perl and Parsing 6: Error Handling&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/02/perl-and-parsing-7-do-list-operators-have-leftright-precedence.html&quot;&gt;
Perl and Parsing 7: Do List Operators have Left/Right Precedence?&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/03/perl-and-parsing-8-the-where-and-why-of-rejection.html&quot;&gt;
Perl and Parsing 8: The Where and Why of Rejection&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html&quot;&gt;
Perl and Parsing 9: &quot;Use&quot; and the Ruby Slippers&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/10/perl-and-parsing-10-use-the-easier-way.html&quot;&gt;
Perl and Parsing 10: &quot;Use&quot; the Easier Way&lt;/a&gt;
&lt;/ul&gt;
&lt;/ol&gt;</description>
  </item>
  <item>
    <title>Perl and Parsing 10: &quot;Use&quot; the Easier Way</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/10/06#perl-and-parsing-10-use-the-easier-way</link>
    <description>&lt;p&gt;
In
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html&quot;&gt;
the previous post in this series&lt;/a&gt;,
I described the way
the &lt;a href=&quot;#TPP&quot;&gt;Traditional Perl Parser&lt;/a&gt; (TPP) parses Perl's
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement.
This post will describe an IMHO attractive alternative approach,
using my own &lt;a href=&quot;http://search.cpan.org/dist/Marpa-XS/&quot;&gt;
Marpa::XS&lt;/a&gt;.
Marpa::XS has a prototype Perl parser as part of its test suite.
&lt;/p&gt;
&lt;h2&gt;The TPP Way&lt;/h2&gt;

&lt;p&gt;
If
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html&quot;&gt;
that previous post&lt;/a&gt;
is not fresh in your mind, it may be useful
at this point to look back at it.
Summarizing, the TPP uses
&lt;a href=&quot;http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html&quot;&gt;
the &quot;Ruby Slippers&quot; method&lt;/a&gt;:
It first simplifies the grammar so that, while convenient for the
parser, the grammar falls short of describing the actual language.
The lexer then fakes the input to the parser
so that the parser's &quot;wishful thinking&quot; comes true.
&lt;/p&gt;
&lt;p&gt;
In the TPP, the parser requires all
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statements
take this form:
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use_statement ::= USE WORD WORD LIST

&lt;/pre&gt;&lt;/code&gt;
Here the &lt;code class=&quot;prettyprint&quot;&gt;WORD&lt;/code&gt;'s may be either versions or
&lt;a href=&quot;#PRAGMA&quot;&gt;names of modules&lt;/a&gt; -- the semantics
looks at the internal representations to sort this out once
the parsing is finished.
&lt;/p&gt;
&lt;h2&gt;The Marpa::Perl Way&lt;/h2&gt;
&lt;p&gt;Marpa is a lot better than
TPP's LALR parse engine at the Ruby Slippers thing.
Marpa will tell its lexers exactly what it wants at every point, whereas
the TPP's lexer can expect no help from the LALR parse engine
and is forced to do its own parsing of
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement.
But in Marpa::Perl, I decided NOT to use the Ruby Slippers
to parse Perl's &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement.
Marpa is good at the Ruby Slippers, but it also allows even better and easier
ways to tackle this problem.

&lt;/p&gt;
&lt;p&gt;
Marpa can parse far more grammars than the TPP's parse engine.
Marpa can even parse ambigious grammars.
The &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement
comes in three forms, and it is easy to create a rule for
each one.
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use_statement ::= USE NAME VERSION LIST
use_statement ::= USE VERSION
use_statement ::= USE NAME LIST
&lt;/pre&gt;&lt;/code&gt;
&lt;/p&gt;
This is a very natural way to describe 
the &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement --
so natural that in fact, it's almost exactly
the way the Perl documentation
DOES describe it.
The one difference is that
the Perl documentation lists separate forms for
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statements
with and
without &lt;code class=&quot;prettyprint&quot;&gt;LIST&lt;/code&gt;'s of arguments.
This is useful for clarity, but

&lt;code class=&quot;prettyprint&quot;&gt;LIST&lt;/code&gt;'s can be empty.
Separate rules in the parser's BNF
dedicated to module requests
without the &lt;code class=&quot;prettyprint&quot;&gt;LIST&lt;/code&gt;'s would create
a useless and inefficient ambiguity.
&lt;p&gt;
The three rules above demonstrate ambiguity of a helpful kind.
Consider
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use Fatal 5;
&lt;/pre&gt;&lt;/code&gt;
The TPP parses this as a request to use
the (so far non-existent) version 5 or higher of the
&lt;code class=&quot;prettyprint&quot;&gt;Fatal&lt;/code&gt;.
According to both TPP's and Marpa::Perl's BNF,
however, it could also be parsed as a request to
Fatal to wrap a Perl subroutine named &lt;code class=&quot;prettyprint&quot;&gt;5&lt;/code&gt;.
In fact, that's exactly how the TPP will interpret
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use Fatal +5;
&lt;/pre&gt;&lt;/code&gt;

&lt;/p&gt;
Marpa::Perl solves the ambiquity by using Marpa's new
ranking method, which allows every rule to have an
integer rank.
Marpa::Perl ranks the rules in the order I listed them
above,
from highest to lowest.
The long form (both name and version)
of the module request ranks highest, meaning that Marpa::Perl
parses
a &lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement that way
whenever possible.
When a 
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement cannot
possibly be the long form of a module request,
Marpa::Perl tries to parse it as a perl version request.
&lt;a href=&quot;#LAST_RESORT&quot;&gt;As a last resort&lt;/a&gt;,
Marpa::Perl interprets a
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement
as the short form (name only)
of a module request.
&lt;p&gt;
By using this rule ranking,
Marpa::Perl's lexer can avoid the issue of determining what is a
version number and what is a name.
Marpa allows tokens to be
ambiguous.
Marpa::Perl's lexer can tell the parser that
&lt;code class=&quot;prettyprint&quot;&gt;v5.0&lt;/code&gt; is BOTH a name and a version,
and let the parser sort things out.
LALR is, to say the least,
not tolerant of
ambiguities, so
the TPP's lexer must tackle the issue
of identifying versions head-on.

&lt;/p&gt;
&lt;h2&gt;Summarizing ...&lt;/h2&gt;
&lt;p&gt;
When it comes to parsing Perl's
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement,
I believe I have shown that Marpa can do it more easily.
Parsing the
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement
in Marpa required the three BNF rules shown,
plus arranging to have the lexer recognize that numbers
and v-strings can be either a version or a name,
which is done with
&lt;a href=&quot;#MARPA_CODE&quot;&gt;
a simple loop over a fixed list&lt;/a&gt;.
Look at
the corresponding code in
&lt;a href=&quot;https://metacpan.org/source/FLORA/perl-5.14.2/toke.c&quot;&gt;toke.c's tokenize_use()
&lt;/a&gt; and

&lt;a href=&quot;https://metacpan.org/source/FLORA/perl-5.14.2/op.c&quot;&gt;op.c's
Perl_utilize()&lt;/a&gt;,
and you'll see some of the most difficult logic
that you're likely to find anywhere.
&lt;/p&gt;
&lt;p&gt;
Perhaps more significant is what Marpa::Perl could do that the TPP
does not and could not do.
Imagine, for example, that you've written a module to make available
the regular expression logic as implemented in the classic
&lt;a href=&quot;http://en.wikipedia.org/wiki/Version_8_Unix&quot;&gt;
AT&amp;T UNIX version 8&lt;/a&gt;,
affectionately remembered as v8 UNIX.
Imagine further that you decide, unhappily, to name this module,
&lt;kbd&gt;v8.pm&lt;/kbd&gt;.
In that case you can simply forget about loading it with TPP's
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement,
which will insist that &lt;code class=&quot;prettyprint&quot;&gt;v8&lt;/code&gt; is a version number,
even in a case like this:

&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use v8 0 qw(re);
&lt;/pre&gt;&lt;/code&gt;
The 
&lt;code class=&quot;prettyprint&quot;&gt;use&lt;/code&gt; statement
just shown can only have one parse.
A human being can quickly determine what that one parse must be.
Why have we come to believe this is too much
to expect of our parsing algorithms?
&lt;/p&gt;

&lt;h2&gt;Notes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&quot;TPP&quot;&gt;&quot;Traditional Perl Parser&quot;: &lt;/a&gt;
In this series, I call the Perl interpreter's parser,
the one whose implementation centers on the files
&lt;kbd&gt;toke.c&lt;/kbd&gt; and &lt;kbd&gt;perly.y&lt;/kbd&gt;,
the Traditional Perl Parser, or TPP.
Most others just call it the Perl parser, but in this
series I discuss its alternatives (&lt;kbd&gt;Marpa::Perl&lt;/kbd&gt;

and &lt;kbd&gt;PPI&lt;/kbd&gt;) a lot.
This little bit of special terminology
saves confusion.
&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&quot;PRAGMA&quot;&gt;&quot;names of modules&quot;: &lt;/a&gt;
Actually, these can also be pragma names, a fact that,
for brevity's sake,
I will not mention again.
&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&quot;LAST_RESORT&quot;&gt;&quot;last resort&quot;: &lt;/a&gt;
Actually, the TPP accepts some undocumented syntaxes.
This gets into strange territory.
The TPP parses
&lt;code class=&quot;prettyprint&quot;&gt;&lt;pre&gt;
use v2 Fatal;
&lt;/pre&gt;&lt;/code&gt;
as a request to use version 2.0 or higher
of the &lt;code class=&quot;prettyprint&quot;&gt;Fatal&lt;/code&gt; module.
You could take the point of view that the TPP should reject statements
like this
as syntax errors,
in which case TPP's behavior is a bug.
For the purposes of this blog post, I ignore this issue.

&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&quot;MARPA_CODE&quot;&gt;&quot;a simple loop over a fixed list&quot;: &lt;/a&gt;
For the code see
&lt;a href=&quot;https://metacpan.org/source/JKEGL/Marpa-XS-0.013_004/pperl/Marpa/Perl.pm&quot;&gt;
pperl/Marpa/Perl.pm
in the latest developer's version of Marpa::XS
&lt;/a&gt;.
The code discussed begins at line 1200.
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
  </item>
  </channel>
</rss>
