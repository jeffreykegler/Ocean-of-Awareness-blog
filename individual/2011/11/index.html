<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div id="menu" style="margin:0;padding:10px;width:150px;float:left;">
  <h2>Jeffrey Kegler's blog</h2>
  <p>About Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <h3>Resources</h3>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey Kegler's website</a></p>
  <p><a href="http://www.jeffreykegler.com/marpa">The Marpa website</a></p>
  <p>Ocean of Awareness blog <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>
  and <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>
  </p>
  </div>
  <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Wed, 30 Nov 2011</h3>
<br />
<center><a name="how-to-parse-html"> <h2>How to Parse HTML</h2> </a>
</center>
<p>
This is the first of a series of posts that will detail
a Marpa-based "Ruby Slippers"
approach to parsing liberal
and defective HTML.
As an example, let's look at a
few lines
taken more or less at random
from the middle
of the <a href="http://www.perl.org/">perl.org
landing page</a>.
That page is exactly 400 lines long.
Here is line 200 and some lines
lines to either side of it.
<pre>
<code class="prettyprint">
&lt;/td&gt;
&lt;td&gt;
&lt;div class="module"&gt;
&lt;a href="http://www.perlfoundation.org/"&gt;
&lt;img alt=""
    src="http://mc-cdn.pimg.net/images/icons/onion.vee5cb98.png"
    width="45" height="45" /&gt;
&lt;/a&gt;

&lt;h4&gt;
&lt;a href="http://www.perlfoundation.org/"&gt;The Perl Foundation&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;
The Perl Foundation is dedicated to the advancement
of the Perl programming language through open discussion,
collaboration, design, and code.
</code>
</pre>
<p>
For readability, I've rearranged
the whitespace, but otherwise the above is untouched.
My more-or-less-random extract is part of a table, and captures the
end tag of one cell and the beginning of another.
</p>
<p>

<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
has no trouble fixing this up,
but neither does the
rendering engine
in Firefox.
If you cut and paste the above display into a file,
and look at it in your favorite web browser,
the result will probably be quite reasonable.
So why am I saying
that Marpa-based
HTML parsing is a step forward?
</p>
<h2>What's the Big Deal?</h2>
<p>
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
as it sits is a flexible and useable tool,
but what makes it different is best appreciated if you think in
terms of
writing, maintaining or
<a href="#FORKING">forking Marpa::HTML</a>.
The rendering engine in your favorite browser
is a monolith of mission-specific code,
and in most cases maintaining it is
the job of a team.
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
was written in a couple
of geek-weeks.
It is reasonable to expect that even
if a change amounted nearly to
a total rewrite,
it could done in
a similar amount of time.
</p>
<p>

Why is
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
that much easier to code?
Well, admittedly,
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
does not do rendering, which
makes life easier.
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
just parses
HTML, without trying to figure out how to arrange it
on a display.
</p>
<p>
More to our purpose,
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
divides
HTML parsing into two layers:
an HTML specific layer;
and
<a href="https://metacpan.org/module/Marpa::XS">

a general parsing layer</a>.
Most of the complexity goes into the general parsing
layer, which is in carefully optimized C,
and which contains no HTML-specific code.
The HTML-specific layer is
small and coded in Perl.
<p>
When I started writing 
Marpa::HTML,
<a href="https://metacpan.org/module/Marpa::XS">
my general parsing layer was already written,
tested and ready to go</a>.
I only
needed to write an HTML-specific layer.
Marpa::HTML was my first serious exercise of
the Ruby Slippers,
and my surprise at how easy it was
to use inspired the name.
</p>
<p>
The advantages to breaking up
an HTML parser
into an HTML-specific layer
and a parse engine
can be compared to the advantages that were accrued
by breaking up the original monolithic
web browsers into a user interface and a rendering engine.
The interface of
modern browsers can be changed
without hacking the rendering engine.
The Marpa-powered approach to parsing
HTML allows the programmer to completely change
his approach to HTML without
touching the parse engine.
</p>
As you read this series of posts,
I hope the following will be food for the imagination:
<ul>
<li>
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
could be the basis
of a utility.
Two I have already written are

<a href="https://metacpan.org/module/html_fmt">html_fmt</a>
and
<a href="https://metacpan.org/module/html_score">html_score</a>.
<li>A Marpa-powered tool
could take a customized approach to dealing with defects in HTML.
<li>A Marpa-powered tool
could take a configurable approach to dealing with defects in HTML.
<li>A Marpa-powered tool could provide an XS-powered engine to speed up HTML::Tree.
<li>A Marpa-powered tool could understand embedded content,
such as
the HTML-within-HTML used in the displays
in this blog post.
<li>
A Marpa-powered tool could imitate your favorite renderer.
<li>
A Marpa-powered tool could configurably imitate the properties
of many renderers.
<li>
A Marpa-powered tool could prototype the HTML renderer
of your dreams.
<li>
With its HTML-specific layer
recoded in C,
a fork could be the easier-to-maintain
HTML renderer of your dreams.

</ul>
<h2>The Example</h2>
<p>
I will finish this post, by taking a first look at
what
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
does.
For that,
it is convenient to use
<a href="https://metacpan.org/module/html_fmt">html_fmt</a>,
my Marpa-powered HTML "pretty-printer".
<a href="https://metacpan.org/module/html_fmt">html_fmt</a>
takes any file fed to it,
interprets it as HTML,
and prints a "prettified" version to the standard output.
It's a good tool for studying HTML interpretation.
Here is what it did with our example:
</p>
<pre>
<code class="prettyprint">
&lt;!-- Following start tag is replacement for a missing one --&gt;

&lt;html&gt;
  &lt;!-- Following start tag is replacement for a missing one --&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;!-- Preceding end tag is replacement for a missing one --&gt;
  &lt;!-- Following start tag is replacement for a missing one --&gt;

  &lt;body&gt;
    &lt;!-- Following start tag is replacement for a missing one --&gt;
    &lt;table&gt;
      &lt;!-- Following start tag is replacement for a missing one --&gt;
      &lt;tbody&gt;
        &lt;!-- Following start tag is replacement for a missing one --&gt;

        &lt;tr&gt;
          &lt;!-- Next line is cruft --&gt;
          &lt;/td&gt;
          &lt;td&gt;
            &lt;div class="module"&gt;
              &lt;a href="http://www.perlfoundation.org/"&gt;

                &lt;img alt=""
    src="http://mc-cdn.pimg.net/images/icons/onion.vee5cb98.png"
    width="45" height="45" /&gt;
              &lt;/a&gt;
              &lt;h4&gt;
                &lt;a href="http://www.perlfoundation.org/"&gt;
                  The Perl Foundation
                &lt;/a&gt;
              &lt;/h4&gt;

              &lt;p&gt;
                The Perl Foundation is dedicated to the advancement
                of the Perl programming language through open discussion,
                collaboration, design, and code.
              &lt;/p&gt;
              &lt;!-- Preceding end tag is replacement for a missing one --&gt;
            &lt;/div&gt;
            &lt;!-- Preceding end tag is replacement for a missing one --&gt;
          &lt;/td&gt;

          &lt;!-- Preceding end tag is replacement for a missing one --&gt;
        &lt;/tr&gt;
        &lt;!-- Preceding end tag is replacement for a missing one --&gt;
      &lt;/tbody&gt;
      &lt;!-- Preceding end tag is replacement for a missing one --&gt;
    &lt;/table&gt;

    &lt;!-- Preceding end tag is replacement for a missing one --&gt;
  &lt;/body&gt;
  &lt;!-- Preceding end tag is replacement for a missing one --&gt;
&lt;/html&gt;
&lt;!-- Preceding end tag is replacement for a missing one --&gt;
</code>
</pre>
<p>
Whenever

<a href="https://metacpan.org/module/html_fmt">html_fmt</a>
adds a tag or spots a spurious tag ("cruft") it adds a
comment to that effect.
As you can see from the above,
<a href="https://metacpan.org/module/html_fmt">html_fmt</a>
sees that the extract is a
table fragment and builds a table around it.
An interesting exercise is to take both the example
and the 
<a href="https://metacpan.org/module/html_fmt">html_fmt</a>
output and look at them in your favorite browser,
comparing
<a href="https://metacpan.org/module/html_fmt">html_fmt</a>'s
reconstruction from the HTML fragment with your browser's.
</p>
<p>
In posts to come,
I'll go into detail about the Ruby Slippers,
Marpa-powered,
approach to HTML parsing.
</p>
<h2>Notes</h2>

<ol>
<li><p><a name="FORKING">"forking"</a>:
To be sure,
I consider
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
a fine tool,
and use it often in my own work.
And it is possible that I will enhance
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>.
But a parser like
<a href="https://metacpan.org/module/Marpa::XS">Marpa</a>
is a tool.
Inventing a new hammer does not
evince
a desire to single-handedly build
every house in the world.
</li>
</ol>
<br />
<p>posted at: 09:12 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11">/individual/2011/11</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/how-to-parse-html.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 27 Nov 2011</h3>
<br />
<center><a name="marpa-and-the-ruby-slippers"> <h2>Marpa and the Ruby Slippers</h2> </a>
</center>
<p>In
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/what-is-the-marpa-algorithm.html">a previous post</a>,
I listed the four ideas
that are essential to
<a href="https://metacpan.org/release/Marpa-XS">Marpa</a>.
This post delves into
one of them: Ruby Slippers parsing.
In Ruby Slippers parsing, the parser imagines
("wishes")
that the language it is parsing
is easier
to parse than it actually is.
The part of the application that handles input
(the "lexer")
manipulates the input
to make the parser's
"wishes" come true.
</p>
<p>
As an example,
take liberal HTML.
"Liberal HTML" is HTML as it is found "in the wild",
with missing and spurious tags.
I've written a
<a href="https://metacpan.org/module/Marpa::HTML">Marpa-powered liberal HTML parser</a>
which uses the Ruby Slippers as its primary
technique.
The grammar behind
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
assumes a fantasy world,
one where no element ever occurs out of place,
and where all HTML elements have both start and end tags.
</p>
<p>

With Marpa as the parse engine, it is easy for
the lexer to make wishes come
true.
All the lexer needs to do is wait until the parser is not happy
with the input.
When the parser sees the actual input as a problem,
the lexer asks the parser what it would like to see instead.
Marpa always knows exactly what it is looking for,
so that it is no problem for the lexer
to invent an input that makes the parser happy.
</p>
<h2>The Obstacles</h2>
<p>
This technique sounds a bit magical, which
is why I named it "the Ruby Slippers".
But the idea is simple enough,
and the need for it great enough,
that it has occurred to others over the
now 50 year history of parsing techniques.
In fact,
the
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/09/perl-and-parsing-9-use-and-the-ruby-slippers.html">
Perl lexer invents input</a>
to simplify the Perl language into something
that its LALR-based parse engine can handle.
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/what-is-the-marpa-algorithm.html#comments">Commenters on a previous post</a>
have mentioned other instances.
I suspect
that instances
where the Ruby Slippers were used
can be found going back to the 60's.
</p>
<p>
But previous use of the Ruby Slippers was difficult,
and had to be rudimentary and infrequent.
The parsers in standard use did not provide
enough feedback.
Recursive descent takes a worm's eye point of view of the
parse -- it knows only where it is trying to burrow at that
particular time.
</p>

<p>
When it came to feedback,
LALR-based parsers were particularly bad --
they were based on
a very abstract state machine.
The Perl lexer,
for its use of the Ruby Slippers,
didn't even try looking at the LALR state --
instead the Perl lexer
duplicated the LALR parser's work
for the section of the parse that was of interest.
If the Perl lexer tried to make frequent use of the Ruby Slippers
it would raise a question:
Why bother with the LALR parser at all?
</p>
<h2>The Solution</h2>
<p>
To really empower the Ruby Slippers, a parser needs to 
do two things.
First, the parser must know what it wants.
Second, the parser must know this in time to help guide the input.
</p>
<p>
Earley's algorithm met the first requirement from the beginning.
Earley's algorithm works by creating "Earley sets".
The original Earley sets were lists of rule applications,
one list for every token in the input.
A rule application was in the Earley set if and only if it
was a real
<a href="#POSSIBILITY">possibility</a>.
</p>
<p>
The second requirement was not met in the original Earley's
algorithm.
For the second requirement to be met,
all work on an Earley set at a parse position
must be finished before
the tokens that start at that position
are read.
Pre-Marpa, Earley parse engines
intermixed work on a location's Earley set,
with reading the input for that location.
That meant that the information to guide Ruby Slippers parsing
did not
became available until just AFTER it was needed.
</p>
<p>

In creating Marpa,
I needed
to combine other researcher's improvements to Earley's into a single
algorithm.
Merging their parse engines into a new one
forced me to write my own, new, parse engine.
In the course of this,
I saw that Earley's Algorithm could be rearranged
so that,
at every location in the parse,
each list of possible rule applications was finished before
the input
starting at that location was read.
<p>
</p>
To make this happen,
Marpa divides the single loop of previous Earley parse engines
into two loops,
and reverses their order.
In other words,
Marpa's parse engine turns the original Earley parse engine 
inside-out and upside-down.
The result is provably equivalent to the original,
and just as fast.
<br />
<p>posted at: 15:48 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11">/individual/2011/11</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 21 Nov 2011</h3>
<br />
<center><a name="which-marpa-distribution-to-use"> <h2>Which Marpa distribution to use?</h2> </a>
</center>
<p>
Which distribution of Marpa should you use?
<a href="https://metacpan.org/release/Marpa-XS">Marpa::XS</a>
or
<a href="https://metacpan.org/release/Marpa-PP">Marpa::PP</a>
or the "bare name" Marpa?
Use
<a href="https://metacpan.org/release/Marpa-XS">Marpa::XS</a>
if you can,
<a href="https://metacpan.org/release/Marpa-PP">Marpa::PP</a>
otherwise.
The "bare name" Marpa is a legacy distribution,
and should be avoided by new users
and in new implementations.
<h2>Marpa::XS</h2>
<a href="https://metacpan.org/release/Marpa-XS">Marpa::XS</a>

incorporates all of my C language speedups.
As well as the fastest of the Marpa distributions,
it is also the only one in beta --
in particular, I will be at pains to keep the interface stable.
<a href="https://metacpan.org/release/Marpa-XS">Marpa::XS</a>
is best both for the casually curious,
and for those intending to use
the Marpa algorithm in their applications.
Note that since
<a href="https://metacpan.org/release/Marpa-XS">Marpa::XS</a>
remains beta, caution is still advised.
<br />
<p>posted at: 20:52 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11">/individual/2011/11</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/which-marpa-distribution-to-use.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Fri, 18 Nov 2011</h3>
<br />
<center><a name="what-is-the-marpa-algorithm"> <h2>What is the Marpa algorithm?</h2> </a>
</center>
<p>
I have referred to
"the Marpa algorithm"
many times.
What is that?
The
<a href="https://metacpan.org/release/Marpa-XS">implementation</a>
involves many details,
but the Marpa algorithm itself is basically four ideas.
Of these only the most recent is mine.
The other three come
from papers
spanning over 40 years.
</p>
<h2>Idea 1: Parse by determining which rules can be applied where</h2>
<p>
The first idea is to track the progress of the a parse by determining,
for each token, which rules can be applied and where.
Sounds pretty obvious.
Not-so-obvious is how
to do this efficiently.
</p>
<p>
In fact,
most parsing these days uses
some sort of shortcut.
Regexes and LALR (yacc, etc.) require the grammar to take a restricted form,
so that they can convert the rules into a state machine.
Recursive descent, rather than list the possibilities, dives into
them one by one.
It, too, only works well with grammars of a certain kind.
</p>
<p>
<a href="EARLEY1970">In 1970</a>,
Jay Earley described an parsing algorithm that
went from left to right,
and worked by determining which rules applied where.
Earley's was reasonably fast,
but the severe limits of 1970's hardware pushed less powerful
parsing algorithms to the forefront,
where they remain.
Jay Earley soon left the computer field to become a
psychotherapist.
His ideas remain the basis of much of general BNF parsing.
Marpa is an Earley's parser.

</p>
<h2>Idea 2: Right-recursion is left-recursion in the mirror</h2>
<p>
Earley's original algorithm could handle anything you could write
in BNF: ambiguous, infinitely ambiguous, left-recursive, right-recursive, you name it.
And Earley's was very good at left-recursion -- blazingly fast.
With right-recursion, however, Earley's original algorithm went quadratic.
For many applications, quadratic time is unacceptable.
</p>
<p>
Right-recursion is just left-recursion seen backwards.
<a href="LEO1991">In 1991</a>,
Joop Leo figured out how
to take efficient advantage of this.
Leo modified Earley's to identify potential right-recursions
and parse them "in the mirror", as if they were left-recursions.
</p>
<p>
With this improvement, Earley's algorithm was now linear for
the LR-regular grammars, a vast class which includes every other
class of grammar in practical use, then and now.
Startlingly, 
Leo's result went 20 years with few implementations.
Marpa is its first implementation in a general-purpose utility.
</p>
<h2>Idea 3: Don't dance around the issue of nullables</h2>
<p>

A pesky problem with Earley's algorithm remained: nullable symbols.
A symbol
is a nullable symbol
if it represents something that might be omitted,
Examples are the three <kbd>expression</kbd>'s
in C language <code class="prettyprint">for</code> statements:
any or all of these may be omitted.
To be considered practical,
a parsing algorithm must work well with grammars
that contain nullables.
</p>
<p>
Earley's original 1970 algorithm actually had a bug in its handling
of nullables.
There was an easy fix, but it made the algorithm slower.
Since efficiency was already seen as the reason to prefer other
parsers, this was a big deal.
</p>
<p>
<a href="AH2002">In 2002</a>,
Aycock & Horspool stopped the dancing around the nullable issue.
They rewrote Earley's parse engine, targeting nullables.
The result was an improvement in other respects.
Marpa's parse engine is not that of Aycock & Horspool.
But Marpa's strategy for handling nullables comes directly from their work.
And the design of Marpa's parse engine is heavily influenced by
that described in Aycock & Horspool 2002.
</p>

<h2>Idea 4: Use the Ruby Slippers</h2>
<p>
For Marpa to get the benefits of both Leo and Aycock&Horspool,
I needed to combine their
quite different
parse engines.
In the process, I realized that behind Earley's original algorithm
lay a promise,
never-fulfilled.
If your parser knows which rules are applicable where,
then it should, in principle,
allow you to use this information
to guide the parsing process.
</p>
<p>
What was needed was a parse engine which was careful to do
all the other processing BEFORE
it looked at the input.
The Marpa parse engine does this ---
at each parse location, examining the input
is the last thing Marpa does.
By examining the input last,
Marpa makes the information
from the other processing available for determining
what that input should be.
</p>
<p>
To see how this can be useful,
take the example of liberal HTML ---
HTML in which tags might be missing.
With Marpa,
it is possible to parse liberal HTML with an unrealistically simple
grammar.
An HTML parser can use
a reference grammar which assumes that start and end tags are always
present, even when not required by the standard.
When the input does not conform to this grammar's unrealistic
expectations,
and it very often will not,
the application can ask the parser what it DOES expect
according to that grammar.
If it's a missing end tag, the application can invent it and
pass it on to the parser.
The parse then continues, quite happily.
</p>
<p>
I call this technique, where the grammar demands
a perfect world and the application changes the input
to match the grammar's expectations,
Ruby Slippers parsing.
I've
<a href="https://metacpan.org/release/Marpa-HTML">implemented an HTML parser</a>
which uses the Ruby Slippers.
I use

<a href="https://metacpan.org/release/Marpa-HTML">
Marpa::HTML</a>
myself a good deal.
It is fast and flexible and IMHO the best way to parse liberal HTML.
</p>
<h2>Summary</h2>
Four ideas are essential to the
<a href="https://metacpan.org/release/Marpa-XS">Marpa</a>
algorithm:
<ul>
<li>Marpa is an Earley's parser,
in that it works by creating lists of possibilities at each token.
<li>Marpa handles right-recursion using Joop Leo's method.
This makes it O(n) for every class of grammar in practical use today.
<li>Marpa handles nullables using the ideas of Aycock&Horspool 2002.
As a side effect, this
opens the way to further improvements in the Earley parse engine.

<li>The Marpa algorithm allows the application to be fully aware,
at all times,
of what is going on in the parse.
Obviously, this benefits error-handling.
More importantly,
it opens the road to powerful new parsing strategies.
</ul>
<h2>Notes</h2>
<ol>
<li><a name="EARLEY1970">"Earley 1970": </a>
Earley, Jay,
"An efficient context-free parsing algorithm",
Communications of the Association for Computing Machinery, 13:2:94-102, 1970.
</li>
<li><a name="LEO1991">"Leo 1991": </a>
Leo, Joop M.I.M.,
"A General Context-Free Parsing Algorithm Running in Linear Time on Every LR(k) Grammar Without Using Lookahead",
Theoretical Computer Science, Vol. 82, No. 1, 1991, pp 165-176.
</li>
<li><a name="AH2002">"Aycock&Horspool 2002": </a>

Aycock, John and
Horspool, R. Nigel,
"Practical Earley Parsing",
The Computer Journal, Vol. 45, No. 6, 2002, pp. 620-630.
<a href="http://www.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf">
Available online</a>.
</li>
</ol>
<br />
<p>posted at: 18:09 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11">/individual/2011/11</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/what-is-the-marpa-algorithm.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Mon, 07 Nov 2011</h3>
<br />
<center><a name="marpa-v-perl-regexes-some-numbers"> <h2>Marpa v. Perl regexes: some numbers</h2> </a>
</center>
<p>
In this post, I pit Marpa against the Perl regex engine.
The example I will use is unanchored searching for balanced parentheses.
I have claimed that many problems now tackled with regexes are better
solved with a more powerful parser, like Marpa.
I believe the numbers in this post back up that claim.
</p>
<p>
To be very clear,
I am NOT claiming that Marpa should or can replace
regexes in general.
For each character,
all an <a href="#RE">RE</a>
(regular expression) engine needs to do
is to compute a transition from
one "state" to another state based on that character --
essentially a simple lookup.
It's the sort of thing a modern C compiler should optimize
into a series of machine instructions that
you can count
on the fingers of one hand.
</p>
Marpa is much more powerful than an regular expression engine,
and to deliver this power
Marpa makes a list of all the possibilities
for each
<a href="#TOKEN">token</a>.
Tricks are used to compress these per-token lists,
and Marpa's code to process them is heavily
optimized.
But even so,
Marpa's processing requires more than a handful of
machine instructions.
<br />
<p>posted at: 17:21 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11">/individual/2011/11</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/marpa-v-perl-regexes-some-numbers.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body>
</html>
