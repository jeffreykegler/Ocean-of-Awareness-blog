<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Marpa v. Perl regexes: some numbers</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2011/11/07#marpa-v-perl-regexes-some-numbers</link>
    <description>&lt;p&gt;
In this post, I pit Marpa against the Perl regex engine.
The example I will use is unanchored searching for balanced parentheses.
I have claimed that many problems now tackled with regexes are better
solved with a more powerful parser, like Marpa.
I believe the numbers in this post back up that claim.
&lt;/p&gt;
&lt;p&gt;
To be very clear,
I am NOT claiming that Marpa should or can replace
regexes in general.
For each character,
all an &lt;a href=&quot;#RE&quot;&gt;RE&lt;/a&gt;
(regular expression) engine needs to do
is to compute a transition from
one &quot;state&quot; to another state based on that character --
essentially a simple lookup.
It's the sort of thing a modern C compiler should optimize
into a series of machine instructions that
you can count
on the fingers of one hand.
&lt;/p&gt;
Marpa is much more powerful than an regular expression engine,
and to deliver this power
Marpa makes a list of all the possibilities
for each
&lt;a href=&quot;#TOKEN&quot;&gt;token&lt;/a&gt;.
Tricks are used to compress these per-token lists,
and Marpa's code to process them is heavily
optimized.
But even so,
Marpa's processing requires more than a handful of
machine instructions.</description>
  </item>
  </channel>
</rss>
