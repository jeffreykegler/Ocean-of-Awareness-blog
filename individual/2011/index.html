<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness   </title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div id="header"
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
  
</div>
  <div id="menu" style="margin:0;padding:10px;width:150px;float:left;">
  <h2>Jeffrey Kegler's blog</h2>
  <p>About Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <h3>Resources</h3>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey Kegler's website</a></p>
  <p><a href="http://www.jeffreykegler.com/marpa">The Marpa website</a></p>
  </div>
  <div id="content" style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 26 Dec 2011</h3>
<br />
<center><a name="a-new-web-site-for-marpa"> <h2>A new web site for Marpa</h2> </a>
</center>
<p>
I have created an
<a href="http://www.jeffreykegler.com/marpa">official web site
for Marpa</a>.
Marpa is attracting new users,
to the point where I thought it might be useful to have a site to act as
a central directory.
The official web site won't have much in the way of new content.
With new content,
I plan to continue to do
what I've been doing -- post it to this blog.
</p>
<p>
I've started the site with an annotated list of the
most important Marpa-related posts in this blog.
I hope this will help people newly interested in
Marpa figure out where they want to start.
Those who've been following this blog for a while
might also want to check the list to see if they've
missed anything worthwhile.
</p>
<br />
<p>posted at: 17:35 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12">/individual/2011/12</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/a-new-web-site-for-marpa.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Tue, 20 Dec 2011</h3>
<br />
<center><a name="marpaxs-is-now-1000000"> <h2>Marpa::XS is now 1.000000</h2> </a>
</center>
<p>
<a href="https://metacpan.org/release/Marpa-XS">
Marpa::XS is now
1.000000</a>.
Marpa::XS is the current lead implementation of Marpa,
an algorithm that I hope will become
standard for
those parsing problems which are too
complex for regular expressions.
Apparently quite a number of people have put
the beta to use.
Feedback has been positive -- often extremely so.
</p>
<h1>What is Marpa?</h1>
<p>
Marpa is a general BNF parser --
it parses anything you can write in BNF, no exceptions.
Left-recursion, right-recursion, ambiguity and
even infinite ambiguity, you name it, Marpa parses it.
If the grammar is of
<a href="#LINEAR">a class in practical use</a>,
Marpa parses it in linear time -- O(n).
</p>
<p>
Marpa's
parse-time error detection is a breakthrough.
When previous parsers failed, they often offered very
little clue as to why.
Marpa knows exactly what input it expects and why.
Marpa is always fully aware of exactly where it is in the parse,
in terms of the rules of the grammar,
and it can share that information with the application.
So good is Marpa at 
error detection,
once considered a desperate last resort,
that error detection can be used as
<a href="http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html">
a parsing technique in itself</a>.

</p>
<p>
While Marpa is intended to computer with production parsers,
it does have special advantages for developers and experimenters.
Marpa is highly tolerant of difficult grammars --
it parses all of them,
and in times which are <a href="#OPTIMAL">considered optimal</a>.
</p>
<h1>New with this release</h1>
<p>
For Marpa::XS 1.000000,
only the version number and the README file were changed
from the previous, beta, release.
</p>
<h1>What is next with Marpa?</h1>
<p>
Marpa::XS is aimed at users who want a stable platform for applications.
To ensure the stability of Marpa::XS,
active development of Marpa is moving into a new fork: Marpa::R2.
This will isolate Marpa::XS users from the accidental changes
and bugs that can be the side effect of active development.
</p>
<p>

Initially, changes to Marpa::XS will be restricted to
bug fixes and those justified from a maintainability standpoint.
The feature set will be kept stable.
(As it stands, Marpa::XS is much more fully featured
than competing parsers.)
If I enhance the features of Marpa::XS,
the new features will be back-ported from Marpa's active development forks,
and I will preserve backward compatibility.
<h1>Limitations</h1>
<p>
Marpa::XS is, as the name suggests, XS only --
installation requires access to a C compiler,
and to many of the <a href="#GNU">GNU utilities and libraries as well</a>.
Marpa::XS has been tested on a wide variety of POSIX systems.
In theory Marpa::XS is NOT restricted to POSIX systems --
all the tools it uses have Windows versions, for example.
However, Marpa::XS has not,
to my knowledge,
been installed on a non-POSIX system.
</p>
<p>
</p><h2>Notes</h2>
<ol>
<li><a name="LINEAR">"in linear time": </a>
To be specific, Marpa parses any LR-regular grammar in linear time -- O(n).
LR-regular is a vast class of grammars that includes LALR,
LR(k) for all k,
and LL(k) for all k.
This means that Marpa parses,
in linear time,
every class of grammar parsed by yacc,
recursive descent and regular expressions.
</li>
<li><a name="OPTIMAL">"considered optimal": </a>

The phrase "considered optimal" elides some
irrelevant bits of theory.
I would be mildly surprised
if it turns out that there is an
O(n) algorithm for general BNF parsing,
but nobody has proved that such a thing cannot exist.
And there is an algorithm which, in theory,
beats Marpa's O(n**3) worst case.
The Valiant algorithm parses general BNF
and is O(n**2.373...) or better.
But Valiant's algorithm is only faster for huge problems,
and for those it
needs a machine with many terabytes of main memory
to deliver on its speed claims.
So it won't be competing with Marpa any time soon.
<li><a name="GNU">"GNU utilities and libraries": </a>
These dependences can be an inconvenience, I admit, but
the alternative is installing
my attempt to portably re-create
all the things the GNU people have developed.
I think that it is clear that the GNU software is the easier
and more reliable alternative.
</p>
<p>
If you browse the package, you may see that it uses TeX as well.
TeX is ONLY needed is you are working on libmarpa,
the highly mathematical, low-level core library that provides
the parse engine.
To do this, you'd need to have studied a lot of the mathematics
of parsing -- and you'd understand why I feel forced to do the
documentation in TeX.
All the non-mathematical parts are either in Perl, or in C code
which can be read and changed on systems which do not have TeX
installed.
</p>
<p>
</p>
</li>
</p>
<br />
<p>posted at: 21:34 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12">/individual/2011/12</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/marpaxs-is-now-1000000.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Wed, 14 Dec 2011</h3>
<br />
<center><a name="how-to-parse-html-part-3"> <h2>How to parse HTML, part 3</h2> </a>
</center>
<p>
When a solution has the same shape
as the problem,
it is a very good thing,
and not just because it looks pretty.
In
<a href="#PREVIOUS">previous posts</a>,
I have described
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>,
a Marpa-based, "Ruby Slippers"
approach to parsing liberal
and defective HTML.
A major advantage
of
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
is that it looks like
the problem it solves.
</p>
<h2>HTML parsing: the problem</h2>
<ol>
<li>
The problem of parsing an HTML document
is essentially
the problem of finding
the hierarchy of its HTML elements.
Conceptually,
HTML elements are delimited by start and end tags.
<li>
The HTML standards specify that certain of the
start and end tags can be omitted.

<li>
In liberal and defective HTML,
any HTML tag might be missing.
<li>
In liberal and defective HTML,
unknown and spurious tags
may be present in the physical input.
</ol>
<h2>HTML parsing: the solution</h2>
<ol>
<li>
The parse engine uses an over-strict grammar,
one which requires all HTML start and end tags.
<li>
When the parse engine runs into a token it cannot accept,
if there is exactly one start or end tag which it
could accept at that point,
the parser uses "the Ruby Slippers".
It invents a virtual token representing the desired
tag, and feeds it to the parse engine.
<li>
If there is more than one virtual token is possible,
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
chooses a token to pass on to the parse engine.
In the current
implementation,
this is done using rules of thumb.

<li>
If no virtual token is possible,
the physical token is treated as "cruft".
The grammar allows cruft to be a part of the contents
of any HTML element,
and the application can decide what to do
with it.
</ol>
<p>
This outline of the solution
follows the structure of the problem point for point.
In turn, the code follows this outline.
It may seem
that I just stated the painfully obvious,
but in fact the design of
the parsers in use today typically
does NOT reflect the structure of their target languages
in any straightforward way.
In particular, the more a parser is
considered "production quality",
the less likely its code will bear any resemblance to
the problem it is solving.
</p>
<h2>Toward hackable parsers</h2>
<p>
A lot could be said about the
aesthetics and philosophy of this.
In this post,
let me cut straight to the bottom line.
</p>
<p>
First and least important,
it is usually easier to code a solution which looks like the problem.
I say "least important,"
because this perspective views the problem as static,
and if the problem is static you can code it up
and forget it.
It does not matter too much whether
the coding effort is fast,
if it only has to be done once.
But what if the problem keeps changing?
</p>
<p>
You might say that most parsing is of the static type,
and that's true.
But that is
because previous technology has left little
choice in the matter.
I believe that,
if programmers had the option of hacking production-quality
parsers, they'd be doing it all the time.
</p>

<p>
In the past,
hacking production quality parsers has been,
for practical purposes, impossible.
Look at those existing utilities which do work with, for
example, C, HTML or Perl.
These usually do NOT even attempt to leverage the production parser
for these languages.
Instead these tools use a new parser,
one created from scratch.
One consequence is that
they must tolerate a considerable amount
of approximation in the parsing.
</p>
<p>
Why don't programmers take the production parsers for a language
as the basis for tools working with that language?
If you look at those production parsers,
you'll see why.
They reflect the structure of the languages so little,
and are so complex,
that they simply are unusable as a starting point
for tools.
<p>
</p>
A Marpa-powered "Ruby Slippers" approach to HTML,
like the one implemented in 
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
but with its HTML interpretation layer rewritten in C,
would be very competitive as a production HTML parser.
Not the least of its advantages would be that it would make
an excellent basis for HTML utilities.
<p>
<h2>Notes</h2>
<ol>
<li><p><a name="PREVIOUS">"previous posts"</a>:
The previous posts in this series were
"<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/how-to-parse-html.html">How
to parse HTML</a>"
and 
"<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/12/how-to-parse-html-part-2.html">How
to parse HTML, part 2</a>".
</p>
</li>
</ol>
<br />
<p>posted at: 17:44 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12">/individual/2011/12</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-3.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Sun, 11 Dec 2011</h3>
<br />
<center><a name="marpaxs-release-candidate-now-available"> <h2>Marpa::XS release candidate now available</h2> </a>
</center>
<p>
I am very happy to announce that
<a href="https://metacpan.org/release/JKEGL/Marpa-XS-0.026000/">
the latest release of Marpa::XS</a>
is a release candidate</a> for the first full release,
Marpa::XS 1.000000.
Most user's experience with the previous beta releases
seems to have been trouble-free.
The one significant issue that was identified
was a failure to properly evaluate null symbols under
<a href="#JIROTKA">
an unusual combination of circumstances</a>.
This problem
(a one line error in the C rewrite of the parse engine)
is fixed in this release.
Unusual as the issue is,
when it does occur it results in a parse failure,
so that
I recommend that all users of Marpa::XS upgrade to
<a href="https://metacpan.org/release/JKEGL/Marpa-XS-0.026000/">
the latest release</a>.
</p>
<p>
Marpa::XS is being kept stable.
Bug fixes, even of minor and cosmetic bugs,
will be made, as 
will changes that improve maintainability.
But no new features will be added.
Interface changes will be especially avoided.

</p>
<h2>What is Marpa?</h2>
<p>Marpa is an advance over recursive descent
and yacc.
I hope the Marpa algorithm
will become the standard parser for
problems too
big for regular expressions.
</p><ul>
<li>Marpa parses,
<a href="#LINEAR">
in linear time</a>,
those
classes of grammar that are currently in practical use.
</li>
<li>The importance of parse-time debugging is often underestimated.
Marpa's parse-time error detection breaks new ground -- Marpa is
fully aware of exactly where in the parse it is at all times,
and of exactly what input it expects and why.
This means parse-time error detection, once a desperate last
resort, now can be used as
<a href="http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html">
a parsing technique in itself</a>.

</li>
<li>Marpa is a general BNF parser -- that means if you feed it anything
written in BNF, it "just parses" it.
This includes grammars which are left-recursive, right-recursive and
ambiguous -- even infinitely ambiguous.
</li>

<li>Marpa never goes exponential -- worst case, even for highly ambiguous
grammars, is O(n**3), which is
<a href="#OPTIMAL">considered optimal</a>.
</li>
</ul>
<h2>New with this release</h2>
<p>
Since the beta release,
several bugs have been fixed,
The most important one was a failure to properly evaluate
null symbols
<a href="#JIROTKA">under certain unusual circumstances</a>.
This problem, identified and described by
Tom&aacute;&#353; Jirotka,
is fixed in
<a href="https://metacpan.org/release/JKEGL/Marpa-XS-0.026000/">
this latest release</a>.
</p>

<p>
In some previous Marpa::XS releases, the
documentation, while part of the distribution,
did not install automatically.
As of this release, that problem is fixed.
The documentation now
installs, as it should,
along with the rest of Marpa::XS.
</p>
<p>
No interface has been deprecated since
Marpa::XS went beta -- the interface has remained stable.
But many interfaces deprecated BEFORE Marpa
went beta were used in the test suite.
To make the test suite more useful for readers,
I eliminated deprecated practices
except in code whose purpose it is
to test that deprecated practice.
Where tests continue to use a deprecated practice,
comments explicitly point this out.
</p>
<h2>What is next with Marpa?</h2>
<p>
Based on the feedback,
I have confidence that Marpa::XS have been extensively
used and found reliable.
With the fixes for this release,
I expect that Marpa::XS can be taken out
of beta and into a full 1.000000 release shortly.
</p>
Development of new features for
Marpa continues, but in another distribution:
<a href="http://search.cpan.org/dist/Marpa-R2/">Marpa::R2</a>.
This isolates Marpa::XS users from the accidental changes
and bugs that can be the side effect of active development.
<br />
<p>posted at: 21:17 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12">/individual/2011/12</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/marpaxs-release-candidate-now-available.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
<h3>Wed, 07 Dec 2011</h3>
<br />
<center><a name="how-to-parse-html-part-2"> <h2>How to parse HTML, part 2</h2> </a>
</center>
<p>
This is the second of a series of posts that details
a Marpa-based, "Ruby Slippers"
approach to parsing liberal
and defective HTML.
This post assumes you have 
read
<a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/how-to-parse-html.html">
the first post</a>.
</p>
<h2>First, reduce the HTML to a token stream</h2>
<p>
Most computer languages can be viewed
as a token stream.
HTML is not an exception.
HTML tokens can be blocks of text;
comments and various other SGML entities;
HTML element start tags;
and HTML element end tags.
The HTML token stream is unusual in that
some of its tokens can
be quite complex internally.
</p>
In parsing computer languages,
it is a frequent practice to divide the
work between a tokenizer ("lexer")
and a <a href="#HIGH-LEVEL">high-level parser</a>.
The lexer takes the raw input
and turns it into a token stream.
Tokenizing HTML is a difficult job,
and one for which there is an excellent CPAN module:
<a href="https://metacpan.org/module/HTML::Parser">HTML::Parser</a>.
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>

relies on
<a href="https://metacpan.org/module/HTML::Parser">HTML::Parser</a>
to do its tokenization.
<p>
</p>
<a href="https://metacpan.org/module/Marpa::HTML">Marpa::HTML</a>
determines the large scale structure of the HTML document --
what I will call in this post, "high-level" parsing.
The result of high-level parsing can be
seen as a hierarchical structure.
The goal of high-level parsing is
to build a hierarchy which reflects
the structure of the document.
Conventionally, this hierarchy is visualized
as an upside-down tree,
one where the "leaves" are the tokens,
and where the "root" node represents the
document as a whole.
<br />
<p>posted at: 11:10 |
path: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12">/individual/2011/12</a> |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/12/how-to-parse-html-part-2.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
  I have not yet decided how to deal with comments at this new blog location.
If the post is Marpa-related,
<a href="https://groups.google.com/forum/?hl=en&fromgroups#%21forum/marpa-parser">
the Marpa mailing list</a>
is a good place to comment.
Also,
I will continue to dual-post for some time,
and have not yet frozen comments on the versions of the
post at
<a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>.
</div>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body>
</html>
