<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 02 Mar 2015</h3>
<br />
<center><a name="peg"> <h2>PEG: Ambiguity, precision and plain old confusion</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <h3>ambiguity Hoffa and precision</h3>
    <p><a href="http://bford.info/packrat/">>PEG parsing</a>
      is a new notation
      for a notorously tricky algorithm with a history that goes back
      the days of the earliest computers.
      In its PEG form,
      this algorithm acquired an seductive new interface,
      one that looks like the best of
      extended BNF combined with the best of regular expressions.
      Looking at a sample of it gives the impression
      that writing a parser has suddenly become a very straightforward
      matter.
    </p><p>For those not yet in the know on this,
      I'll explain with a pair of examples from
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        an excellent 2008 paper by Redziejowski</a>.
      Let's start with these two PEG grammars.
    </p><blockquote><pre>
    ("a"|"aa")"a"
    ("aa"|"a")"a"
    </pre></blockquote><p>
      One of these two PEG grammars accepts
      the string "<tt>aaa</tt>" and "<tt>aa</tt>".
      The other accepts the string
      the string "<tt>aa</tt>" and "<tt>aaa</tt>".
      Can you tell which one?
      Could you sort this out
      if this logic was buried in a large specification?
      (For the answer to the first question,
      see page 4 of
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        Redziejowski 2008</a>.
    </p><p>
      Here is another example:
    </p><blockquote><pre>
    A = "a"A"a"/"aa"
    </pre></blockquote><p>
      What language does this describe?
      It's obviously string of the letter "<tt>a</tt>",
      but which ones?
      Again the answer is on
      page 4 of
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        Redziejowski 2008</a>
      -- it's exactly those strings
      whose length is a power of 2.
    </p><p>With PEG, what you see is not what you get.
      PEG parsing is sometimes called "precise",
      on the idea that PEG parsing is in a sense unambiguous.
      In this case "precise" is taken as synonymous with
      "unique".
      That is, PEG parsing is precise in exactly the same
      sense as the location of Jimmy Hoffa's body
      is a precise location.
      We know there is exactly one such place, but
      without necessarily being able to specify it.
    </p>
    <h3>Syntax-driven?</h3>
    <p>It's important to emphasize that the point of
      a syntax-driven parser generator is that the syntax,
      in fact, describe, in some way the programmer can
      in practice predict, the parser which is generated.
      This is, for most practical grammars, not the case
      with PEG.
      Below I will describe the work of several
      PEG researchers who understand this this issue,
      and who are trying to deal with it.
    </p><p>Before moving on,
      I want to point out why these PEG researchers
      take knowing precisely what language you are parsing
      very seriously.
      This is much more at stake than bragging rights
      over which algorithm is really syntax-driven and
      which is not.
    </p><p>Let me identify two problems.
      The least serious of these is that your PEG grammar
      might not parse all the strings in your language.
      There is, in usual practice, no way to determine
      this from the PEG specification,
      so you have to rely on your test suite.
      But test suites are not adequate to catch all
      possible errors in most applications,
      and this is especially the case with languages.
    </p><p>The second, more serious problem, is often forgotten.
      Your PEG parser might accept strings that are
      <b>not</b>
      in your language.
      No test suite can catch all of these, and few try.
      But if a parser accepts unexpected inputs,
      and applications come to rely on this,
      it becomes a huge problem for maintaining compatibility.
      Failure to accept correct input can be coped with
      in straightforward fashion,
      -- you simply fix the parser to accept the correct input.
      But if you discover you have been accepting incorrect input,
      you have a more difficult choice -- break compatiblity,
      or leave the problem unfixed.
      Leaving the problem unfixed is problematic, because
      acceptance of unexpected inputs is also
      a potential security risk.
    </p><p>The burden of maintaining a PEG parser is worth
      considering carefully.
      Even if you do know the current behavior of your PEG parser,
      you cannot expect to know what it will be if you need to
      change it.
      Small changes in PEG specifications often have big
      implications,
      implications which are hard to predict,
      and hard even to discover when your revised
      PEG parser seems to be working.
      And the larger the PEG parser gets, the worse the
      maintenance problem gets.
    </p><h3>Is PEG unambiguous?</h3>
    <p>PEG is not unambiguous in any
      helpful sense of that word.
      BNF allows you to specify ambiguous grammars,
      and that feature is tied to its power and flexibility
      and often useful in itself.
      PEG will only deliver one of those parses, but without
      an easy way of specifying, or even knowing, which one
      the underlying problem of ambiguity has not really been addressed.
    </p><p>My Marpa parser,
      for example, which is a general BNF parser based on Earley's,
      can simply throw all but one of the parses in an ambiguous
      parse away.
      But I would not say that, if you have an issue with ambiguity,
      Marpa has solved it by arbitrarily throwing away results.
      Marpa, in fact, does allow you to control which parses
      are tossed, by ranking some rules over others,
      and in Marpa's case the ranking works in an intuitive
      way.
      But in all cases, whether you call them ambiguous or not,
      Marpa delivers precisely the parses the grammar and the rule
      rankings specify,
      and it is "precision" in this sense that a grammar writer needs.
    </p><h3>Is there a sensible way to use PEG?</h3><p>
      I've already mentioned my own parser, Marpa,
      and I'll return to that.
      But suppose that you refuse to use Marpa,
      and insist on making
      the best of PEG.
      There are
      several excellent programmers who have committed themselves
      to PEG, while being fully honest about its limitations.
      I've already mentioned one important paper
      Redziejowski -- his collected papers can be
      found here, and many of them treat PEG,
      and they are trustworthy.
      Redziejowski, in his effort to promote PEG,
      can be relied not to sugarcoat PEG's problems.
    </p><p>Roberto Ierusalimschy, author of Lua and one of the best
      programmers of our time,
      has written a PEG-based parser of his own.
      Roberto's is fully aware of PEG's limits,
      and makes a good case for choosing PEG for his parser.
      First, LPEG's is intended for use Lua,
      a ruthlessly minimal language,
      so there is an almost unique emphasis on the size of the code.
      And, indeed, Roberto's version of PEG (LPEG) is small.
      Second, Roberto's intention
      is not to create a syntax-driven competitor of recursive descent,
      but instead to extend regular expressions in a disciplined way.
    </p><h3>Matching the BNF to the PEG spec</h3><p>
      Redziejowski, Ierusalimschy and the other authors
      of
      <a href="x">X</a>
      recognize that inability to know the the language you are
      parsing is no minor issue -- in many applications,
      it is a show-stopper, or at least should be.
      The solution they are pursuing is finding the subset of
      BNF for which the PEG spec
      <b>does</b>
      accept exactly
      the language specified by the BNF.
      This subset is in fact, very restricted -- it is essentially
      LL(1) --
      those languages a top-down parser can parse based on at
      most one character of input.
      A syntax-driven parser for LL(1) was described in 1961(?),
      but there was no followup,
      because LL(1) is just not sufficient for
      most practical languages.
      Redziejowski believes this class of languages which are well-behaved
      for PEG can be extended somewhat --
      those interested can look at his paper.
    </p><h3>Marpa</h3><p>
      In this post,
      I have taken the point of view of programmers using PEG,
      or thinking of doing so.
      My own belief in this matter is that
      very few programmers
      will want to deal with the issues I've just described.
      My reason for this is the Marpa parser --
      a general BNF Earley-drived parser that
    </p>
    <ul>
      <li>has an implementation you can use today;</li>
      <li>allows the application to combine syntax-driven parsing
        with custom procedural logic;</li>
      <li>makes available full, left-eidetic knowledge of the parse to
        the procedural logic;</li>
      <li>and parses a vast class of grammars the linear time,
        including all the LR-regular grammars.</li>
    </ul>
    <p>
      The LR-regular grammars include the LR(k) and LL(k)
      grammars for all
      <i>k</i>, and which can be expected to include any
      grammar that will be found to be well-behaved under PEG.
    </p>
    <h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      <a href="http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 19:56 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2015/03/peg.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
