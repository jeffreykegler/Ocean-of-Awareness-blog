<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Ocean of Awareness</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Mon, 02 Mar 2015</h3>
<br />
<center><a name="peg"> <h2>PEG: Ambiguity, precision and plain old confusion</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <h3>Precise?</h3>
    <p><a href="http://bford.info/packrat/">>PEG parsing</a>
      is a new notation
      for a notorously tricky algorithm with a history that goes back
      the days of the earliest computers.
      In its PEG form,
      this algorithm acquired an seductive new interface,
      one that looks like the best of
      extended BNF combined with the best of regular expressions.
      Looking at a sample of it gives the impression
      that writing a parser has suddenly become a very straightforward
      matter.
    </p><p>For those not yet in the know on this,
      I'll explain with a pair of examples from
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        an excellent 2008 paper by Redziejowski</a>.
      Let's start with these two PEG grammars.
    </p><blockquote><pre>
    ("a"|"aa")"a"
    ("aa"|"a")"a"
    </pre></blockquote><p>
      One of these two PEG grammars accepts
      the string "<tt>aaa</tt>" and "<tt>aa</tt>".
      The other accepts the string
      the string "<tt>aa</tt>" and "<tt>aaa</tt>".
      Can you tell which one?
      Could you sort this out
      if this logic was buried in a large specification?
      (For the answer to the first question,
      see page 4 of
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        Redziejowski 2008</a>.
    </p><p>
      Here is another example:
    </p><blockquote><pre>
    A = "a"A"a"/"aa"
    </pre></blockquote><p>
      What language does this describe?
      It's obviously string of the letter "<tt>a</tt>",
      but which ones?
      Again the answer is on
      page 4 of
      <a href="http://www.romanredz.se/papers/FI2008.pdf">
        Redziejowski 2008</a>
      -- it's exactly those strings
      whose length is a power of 2.
    </p>
    <p>With PEG, what you see is not what you get.
      PEG parsing has been called "precise",
      perhaps based on
      the idea that PEG parsing is in some sense unambiguous.
      In this case "precise" is taken as synonymous with
      "unique".
      That is, PEG parsing is precise in exactly the same
      sense that Jimmy Hoffa's body
      is at a precise location.
      There is (presumably) exactly one such place,
      but we are not necessarily able to specify it.
    </p>
    <h3>Syntax-driven?</h3>
    <p>The point of having
      a syntax-driven parser generator is having the syntax,
      describe,
      in some way the programmer can
      in practice predict,
      the parser which is generated.
      For most practical grammars, PEG is not syntax-driven
      in this sense.
      Below I will describe the work of several
      PEG researchers who understand this this issue,
      and who are trying to deal with it.
      This is much more at stake than bragging rights
      over which algorithm is really syntax-driven and
      which is not,
      and this is why
      those PEG researchers
      have focused on this issue.
    </p>
    <p>When you do not know the language your parser is
      parsing, you have two problems.
      The first, and least serious, of these is that your PEG grammar
      might not parse all the strings in your language.
      If you cannot determine that all acceptable strings
      are parsed by your parser from the PEG specification,
      so you have only your test suite to go by,
      and that is just not enough.
    </p>
    <p>The second problem is more and often forgotten.
      Your PEG parser might accept strings that are
      <b>not</b>
      in your language.
      Rarely do test suites even try to catch more
      than a few of these,
      and no test suite could catch all of them.
      But, while
      failure to accept correct input can be coped with
      simply by fixing the parser to accept the correct input,
      the situation is more complicated
      if you discover you have been accepting incorrect input.
      You have the choice of breaking compatiblity,
      or leaving the problem unfixed.
      As a final thought,
      a parser which
      accepts unacceptable inputs can create
      a security loophole.
    </p><p>The burden of maintaining a PEG parser is worth
      considering.
      Even if you do know the current behavior of your PEG parser,
      you cannot expect to know what it will be if you need to
      change it.
      Small changes in PEG specifications often have big
      implications.
      These implications are not just hard to predict,
      they are hard even to discover after the fact.
      And the larger the PEG parser gets, the worse the
      maintenance problem gets.
    </p>
    <h3>Is PEG unambiguous?</h3>
    <p>PEG is not unambiguous in any
      helpful sense of that word.
      BNF allows you to specify ambiguous grammars,
      and that feature is tied to its power and flexibility
      and often useful in itself.
      PEG will only deliver one of those parses, but without
      an easy way of specifying, or even knowing, which parse
      the underlying problem of ambiguity has not really been addressed.
    </p>
    <p>My Marpa parser,
      for example, which is a general BNF parser based on Earley's,
      can simply throw all but one of the parses in an ambiguous
      parse away.
      But I would not say that, if you have ambiguity is an issue for you,
      that Marpa has solved that issue
      simply by throwing all but
      one arbitrarily chosen result.
      More helpfully, in many cases,
      Marpa allows you to control which parses
      are tossed, by ranking some rules over others,
      and in Marpa's case the ranking works
      together with the BNF
      in an intuitive way.
      But in all cases, whether you call them ambiguous or not,
      Marpa delivers precisely the parses the grammar and the rule
      rankings specify.
      It is "precision" in this sense that a grammar writer is looking for.
    </p>
    <h3>Is there a sensible way to use PEG?</h3>
    <p>
      I've brought up my own parser, Marpa,
      and I'll return to it.
      But, for now,
      let's assume
      that you are not interested in using Marpa.
      Let's assume
      that you are not committed to PEG,
      and want to make the best of that.
      There are
      several excellent programmers who have focused
      on PEG,
      without blinding themselves to its limitations.
      I've already mentioned one important paper
      by Redziejowski -- many of
      <a href="http://www.romanredz.se/pubs.htm">
      his collected papers</a>
        are about PEG,
        and Redziejowski, in his attempts to use PEG,
        never sugarcoat its problems.
      </p>
    <p>Roberto Ierusalimschy, author of Lua and one of the best
      programmers of our time,
      has written a PEG-based parser of his own.
      Roberto's is fully aware of PEG's limits,
      but he has a good case for choosing PEG
      as the basis of his parser generator.
      First, LPEG is intended for use with Lua,
      a ruthlessly minimal language
      which has an almost unique emphasis on the size of the codebase.
      And, indeed, Roberto's version of PEG (LPEG) is small.
      Second, Roberto's intention
      is to extend regular expressions in a disciplined way,
      so that he is willing to accept a parser of limited power.
    </p>
    <h3>Matching the BNF to the PEG spec</h3>
    <p>
      Redziejowski, Ierusalimschy and the other authors
      of
      <a href="x">X</a>
      recognize that inability to know the the language you are
      parsing is no minor issue -- in many applications,
      it is a show-stopper, or at least should be.
      The solution they are pursuing is finding the subset of
      BNF for which the PEG spec
      <b>does</b>
      accept exactly
      the language specified by the BNF.
      This subset is in fact, very restricted -- it is essentially
      LL(1) --
      those languages a top-down parser can parse based on at
      most one character of input.
      A syntax-driven parser for LL(1) was described in 1961(?),
      but there was no followup,
      because LL(1) is just not sufficient for
      most practical languages.
      Redziejowski believes this class of languages which are well-behaved
      for PEG can be extended somewhat --
      those interested can look at his paper.
    </p>
    <h3>Marpa</h3>
    <p>
      In this post,
      I have taken the point of view of programmers using PEG,
      or thinking of doing so.
      My own belief in this matter is that
      very few programmers
      will want to deal with the issues I've just described.
      My reason for this is the Marpa parser --
      a general BNF Earley-drived parser that
    </p>
    <ul>
      <li>has an implementation you can use today;</li>
      <li>allows the application to combine syntax-driven parsing
        with custom procedural logic;</li>
      <li>makes available full, left-eidetic knowledge of the parse to
        the procedural logic;</li>
      <li>and parses a vast class of grammars the linear time,
        including all the LR-regular grammars.</li>
    </ul>
    <p>
      The LR-regular grammars include the LR(k) and LL(k)
      grammars for all
      <i>k</i>, and which can be expected to include any
      grammar that will be found to be well-behaved under PEG.
    </p>
      <h3>Comments</h3>
      <p>Comments on this post can be made in
	<a href="http://groups.google.com/group/marpa-parser">
	  Marpa's Google group</a>,
	or on our IRC channel: #marpa at freenode.net.
	To learn more about Marpa,
	there's
	<a href="http://savage.net.au/Marpa.html">the
	  official web site maintained by Ron Savage</a>.
	I also have
	<a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
      </p>
  </body>
</html>
<br />
<p>posted at: 19:56 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2015/03/peg.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
