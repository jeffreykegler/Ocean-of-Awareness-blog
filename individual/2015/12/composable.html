<html>
<head>
<link rel="alternate" title="Ocean of Awareness RSS" type="application/rss+xml" title="RSS" href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/index.rss" />
<title>Composing grammars</title>
<style type="text/css">
   strong {font-weight: 700;}
</style>
</head>
<body>
<div
  style="color:white;background-color:#38B0C0;padding:1em;clear:left;text-align:center;">
<h1>Ocean of Awareness</h1>
</div>
  <div style="margin:0;padding:10px 30px 10px 10px;width:150px;float:left;border-right:2px solid #38B0C0">
  <p>
  <strong>Jeffrey Kegler's blog</strong>
  about Marpa, his new parsing algorithm,
    and other topics of interest</p>
  <p><a href="http://www.jeffreykegler.com/">Jeffrey's personal website</a></p>
      <p>
	<a href="https://twitter.com/jeffreykegler" class="twitter-follow-button" data-show-count="false">Follow @jeffreykegler</a>
      </p>
      <p style="text-align:center">
	<!-- Place this code where you want the badge to render. -->
	<a href="//plus.google.com/101567692867247957860?prsrc=3" rel="publisher" style="text-decoration:none;">
	<img src="//ssl.gstatic.com/images/icons/gplus-32.png" alt="Google+" style="border:0;width:32px;height:32px;"/></a>
      </p>
  <h3>Marpa resources</h3>
  <p><a href="http://jeffreykegler.github.com/Marpa-web-site/">The Marpa website</a></p>
  <p>The Ocean of Awareness blog: <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog">home page</a>,
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/chronological.html">chronological index</a>,
  and
  <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/metapages/annotated.html">annotated index</a>.
  </p>
  </div>
  <div style="margin-left:190px;border-left:2px solid #38B0C0;padding:25px;">
<h3>Sat, 12 Dec 2015</h3>
<br />
<center><a name="fast_handy"> <h2>Composing grammars</h2> </a>
</center>
<html>
  <head>
  </head>
  <body><p>
      <!--
      marpa_r2_html_fmt --no-added-tag-comment --no-ws-ok-after-start-tag
      -->
    </p>
    <p>A recent Perl 6 advent post presented a very nice vision of
      a future of language-driven programming, one I share.
      It goes on to encourage that its readers to follow up on this vision.
      However,
      I do not think the specific approach that it suggests would be fruitful.
      In this post I'll explain why.
    </p>
    <h2>Composability</h2>
    <p>I will talk about language-driven programming at some point,
      but the points I want to make will be easier to make if I make them
      in terms of another aspect of the vision from the advent post presents
      -- grammar composibility.
      Grammar composibility is nothing but "reuse" in the language-driven programming context.
      Most programmers will be very familiar with it from regular expressions.
    </p>
    <p>
      In the regular expression world reuse is very much both practical and practiced --
      the culture of reuse is so strong there is
      is even a backlash against what some writers call "cargo cult programming".
    </p>
    <p>
      Composability is the ability to take two grammars, or pieces of grammars,
      and to put them together ("compose" them).
      In this post, I will treat both regular expressions and BNF as ways of representing the
      grammar of a language.
      Ideally, when you compose two grammars will parse
    </p><ul>
      <li>a language you can reasonably predict, that is also
      </li>
      <li>the language you can intuitively expect from a composition, and
      </li>
      <li>if each of the two grammars can be parsed in reasonable time,
        the composed language can also be parsed in reasonable time.
      </li>
    </ul>
    <p>
      Not all language representation are composabile.
      Regular expressions are, and BNF is.
      PEG, which looks like a combination of BNF and regular expressions,
      is in fact, neither, and is in fact, among all the ways commonly used
      to represent language, perhaps the least composable.
    </p>
    <h2>Composing regular expressions</h2>
    <p>We'll start with regular expressions, which are as well-behaved under
      composition as a language representation can get.
      The combination of two regular expressions is always another regular expression,
      and is always exactly the one described by the combined regular expression.
      Further, every regular expression is parseable in linear time.
    </p>
    <p>The one downside, oft mentioned by critics, is that regular expression
      do not scale in terms of readability.
      Here, however, the problem is not really one of composability.
      The problem is that regular expressions are quite limited in their capabilities,
      and programmers often use their excellent behavior under composability
      to extent regular expressions to tasks for which they are not well-adopted.
    </p>
    <h2>PEG, Perl 6 grammars and composability</h2>
    <p>When programmers first look at PEG syntax, they often think they've encountered
      paradise. They see both BNF and regular expressions, and imagine they'll have the
      best of each.
    </p>
    <p>
      But the convenient behavior of
      regular expressions depends on their ambiguity -- you simply cannot write
      an ambiguous regular expression -- it's impossible.
      More powerful and more flexible, BNF allows you to describe many more grammars --
      including ambiguous ones.
    </p>
    <p>How does PEG resolve this?  With a Gordian knot approach.
      Whenever it encounters an ambiguity, it throws all but one of the choices away.
      This certainly takes care of the ambiguity, but it gives PEG grammars all
      the predictability of nitroglycerin.
      A PEG grammar does not have to be large to be tricky.
      Consider these two:
       </p>
       <blockquote><pre>
	 ("a"|"aa")"a"
	 ("aa"|"a")"a"
       </pre></blockquote>
       On accepts "aaa" but not "aa".  The other does the reverse.
       For the answer to this, a discussion of what grammars are predictable for PEG and more,
       look at
       <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2015/03/peg.html">
       my previous post on PEG</a>.
    </p>
    <p>Bottom line, for practical grammars, using even one PEG grammar
    means giving up on knowing much about the language you are actually parsing
    except that it passes your test suite.
    If you combine two of them, the odds are against getting anything useful.
    <h2>So what about Perl 6?</h2>
    I devoted some time to PEG, because the parser recommended in the advent post,
    the native Perl 6 parser, is an extended PEG parser.
    These extensions are very interesting from the PEG point of view.
    The PEG "tie breaking" has been changed,
    and backtracking can be used.
    These features mean the Perl 6 parser can be extended to languages
    well beyond what
    ordinary PEG parsers cannot handle.
    But, if you use the extra features, your language descriptions will be even less
    composable than ordinary PEG.
    <h3>A general BNF parser</h3>
    As mentioned, general BNF is composable, and so general BNF parsers like Marpa
    are as composable as regular expressions, with two caveats.
    First, if the two grammars are not doing their own lexing, their lexers will have
    to be compatible.
    <p>Second,
    with regular expressions you had the advantage that <b>every</b>
    regular expression parses in linear time, so that speed will be acceptable.
    Marpa users compose grammars all the time, and have the same result,
    but in Marpa it's not guaranteed -- if you are not careful, and have
    bad luck, your grammar could go cubic.
    <p>
    You can quarantee your Marpa grammar will stay linear if you follow 2 rules:
    <ul>
    <li>keep the grammar unambiguous;</li>
    <li>don't use an unmarked middle recursions.</li>
    </ul>
    Unmarked middle recursions are not things you're likely to need a lot: they
    are those palindromes where you have to count to find the middle:
    grammars like "A ::= a | a A a".
    If you do use a middle recursions at all, it is almost certainly going to
    be marked, like "A ::= b | a A a", which generates strings like "aabaa".
    With Marpa, composability is reality,
    And, as I hope to show in a future post, so is language-driven programming.
    <h2>Closing</h2>
    <p>I'd like to emphasize that I'm a supporter of the Perl 6 effort.
    I certainly <b>should</b> be, after the many favors they've done for me
    and the Marpa community over the years.
    If the points of this post are taken,
    they will disappoint some of the
    hopes for applications of the native Perl 6 parser.
    But these applications have not been central to the Perl 6 effort,
    of which I will be an eager student over the coming months.
    <h3>Comments</h3>
    <p>Comments on this post can be made in
      <a href="http://groups.google.com/group/marpa-parser">
        Marpa's Google group</a>,
      or on our IRC channel: #marpa at freenode.net.
      To learn more about Marpa,
      there's
      <a href="http://savage.net.au/Marpa.html">the
        official web site maintained by Ron Savage</a>.
      I also have
      <a href="http://jeffreykegler.github.io/Marpa-web-site/">a Marpa web site</a>.
    </p>
  </body>
</html>
<br />
<p>posted at: 15:18 |
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2015/12/fast_handy.html">direct link to this entry</a>
</p>
<div style="color:#38B0C0;padding:1px;text-align:center;">
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&sect;
</div>
</div>
</div>
<div id="footer" style="border-top:thick solid #38B0C0;clear:left;padding:1em;">
<p>This is Ocean of Awareness's
  new home.  This blog has been hosted at
  <a href="http://blogs.perl.org/users/jeffrey_kegler/">blogs.perl.org</a>
  but I have succumbed to the lure of static blogging.
</div>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
</body></html>
