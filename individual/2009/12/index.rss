<?xml version="1.0"?>
<!-- name="generator" content="blosxom/2.0" -->
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" "http://my.netscape.com/publish/formats/rss-0.91.dtd">

<rss version="0.91">
  <channel>
    <title>Ocean of Awareness   </title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog</link>
    <description>Ocean of Awareness.</description>
    <language>en</language>

  <item>
    <title>Marpa: Practical General BNF Parsing</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2009/12/31#marpa-practical-general-bnf-parsing</link>
    <description>&lt;p&gt;With a regular expression engine, there
are expectations.
You feed a regular expression to the RE engine, it parses with it.
That simple.

&lt;p&gt;A general BNF parser is one which fulfills the same
expectation for BNF.
Write your language in BNF, you got a parser.
But it hasn't been that simple.

&lt;p&gt;The guys who write the textbooks have pushed
general BNF parsing for years.
Improvements in these algorithms have pushed
the speeds down to linear or close to it
for the kinds of language in practical use.

&lt;p&gt;But the general parsing algorithms have languished
on the textbook pages.
And I did find it wasn't quite
as easy as the academics suggested.
There were some obstacles that they didn't forsee.
But bottom line, they were right.
General BNF parsing is practical.

&lt;p&gt;&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt; is a practical
(if at this point alpha)
general BNF parser
generator.
I have used Marpa to write a practical parser
for a non-trivial task -- HTML parsing.
That HTML parser is &lt;a href=&quot;http://search.cpan.org/~jkegl/Marpa-0.002000/lib/Marpa/UrHTML/Doc/UrHTML.pod&quot;&gt;Marpa::UrHTML&lt;/a&gt;,
and I now use
Marpa::UrHTML
in tasks I do routinely.

&lt;p&gt;Over the next weeks, I will do phased releases of &lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt;.
The HTML parser, &lt;a href=&quot;http://search.cpan.org/~jkegl/Marpa-0.002000/lib/Marpa/UrHTML/Doc/UrHTML.pod&quot;&gt;Marpa::UrHTML, 
is documented&lt;/a&gt; and ready to use in the first release.
Over the next few weeks,
I will document Marpa,
the parse engine itself.

&lt;p&gt;Right now the Marpa parse engine is &quot;pure Perl&quot;, and speeds
are on the order of PPI.
This is acceptable for many applications,
but Marpa can do better.
&lt;a href=&quot;http://search.cpan.org/dist/Marpa/&quot;&gt;Marpa&lt;/a&gt; has as its parse engine a mathematical algorithm
that lends itself to conversion to C.
Further down the road, I'll write a Marpa C library,
and an XS wrapper.</description>
  </item>
  <item>
    <title>Alpha Modules and Perl's use Statement</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2009/12/21#alpha-modules-and-perls-use-statement</link>
    <description>&lt;p&gt;I'm contemplating breaking a very well-established standard: Version arguments to Perl's &quot;use&quot; statement.  The module writer is free to change the semantics of these, but despite the endless eccentricities you find on CPAN in other things, they rarely (never?) do.
&lt;/p&gt;
&lt;p&gt;So I'm having guilt feelings.  Insecurities are coming out.  I'm getting second thoughts.  In this post I will handle these things the way many people do.  Preach.
&lt;/p&gt;
&lt;p&gt;Consider a default module &lt;kbd&gt;use&lt;/kbd&gt; like
&lt;/p&gt;
&lt;pre&gt;    &lt;code class=&quot;prettyprint&quot;&gt;use Marpa;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The standard (and almost universal) semantics is to load whatever version is out there.  This works if you can assume that the modules you're using are well-behaved and upwardly compatible.
Or if you have strict controls on the libraries in the environment in which
you are running.
But what if you are dealing with software 
which is avowedly alpha?
&lt;p&gt;Certainly allowing the user
to say &quot;Just give me anything&quot; is
very much in the Perl spirit.
And it's necessary in some cases.
Programs in a test suite should not be fussy about the version
of the software that gets thrown at them.
Crashing and burning because of new versions of software is their
role in life.
&lt;/p&gt;
&lt;p&gt;But with alpha modules, it's a poor default.
So I'm thinking of having my alpha modules accept
only two forms of the &lt;kbd&gt;use&lt;/kbd&gt;
statement, both with two arguments.
&lt;/p&gt;
&lt;pre&gt;    &lt;code class=&quot;prettyprint&quot;&gt;use Marpa 0.001_037;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The numeric version of the two argument form means gives me version 
0.001_037
and version 
0.001_037 &lt;strong&gt;only&lt;/strong&gt;.
Upgrades result in an error message.
&lt;/p&gt;
&lt;pre&gt;         &lt;code class=&quot;prettyprint&quot;&gt;use Marpa 'alpha';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The two argument form with the &lt;kbd&gt;alpha&lt;/kbd&gt; argument means give me anything alpha or later --
in other words, anything at all.
That's the equivalent of the &quot;wide open city&quot;
default behavior.
But here the user has asked for it explicitly.
&lt;/p&gt;
&lt;p&gt;What do I do with the one argument form?
&lt;/p&gt;
&lt;pre&gt;                 &lt;code class=&quot;prettyprint&quot;&gt;use Marpa;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The one argument form gets you a multi-line error message
which summarizes what
I've just said.
&lt;/p&gt;
&lt;p&gt;
This might make people think before including
a dependency on my new, alpha, module.
But is that a bad thing?
Shouldn't alpha code turn off unsafe defaults?
Perhaps other writers of alpha code should consider non-standard semantics
for the &lt;kbd&gt;use&lt;/kbd&gt; statement.  It will help me with my guilt feelings.</description>
  </item>
  <item>
    <title>In Praise of NYTProf</title>
    <link>http://jeffreykegler.github.com/Ocean-of-Awareness-blog/2009/12/17#in-praise-of-nytprof</link>
    <description>&lt;p&gt;I'd like to add my praise to the heap of it already piled onto &lt;a href=&quot;http://search.cpan.org/dist/Devel-NYTProf/&quot;&gt;NYTProf&lt;/a&gt;.  This is a Perl profiler available on CPAN, with a very attractive HTML interface.&lt;/p&gt;

&lt;p&gt;If you wait for your next efficiency issue before using NYTProf, you're making a mistake.  For me optimizing is no longer NYTProf's primary purpose.  NYTProf is a powerful debugging tool. The count of the number of times each line was executed yields marvelous insights quickly.  Consider an example: a script to process a file.  It is acting strangely.  You don't know where to begin.  Your test file is 1000 lines long.  You notice certain lines in the per-line logic are not being executed 1000 times.  Hmmm.&lt;/p&gt;

&lt;p&gt;Simply checking for lines which are not executed &lt;strong&gt;at all&lt;/strong&gt; is a surprisingly powerful technique.  The HTML format allows you to skim the code, looking for these.  This is particularly useful when the question is not localized or some matter of detail, but whether your overall logic makes sense, and whether your code actually implements the logic/algorithm you intended.&lt;/p&gt;

&lt;p&gt;Adam Kaplan, Tim Bunce and Steve Peters, thank you.&lt;/p&gt;</description>
  </item>
  </channel>
</rss>
